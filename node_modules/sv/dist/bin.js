#!/usr/bin/env node
import require$$0 from 'node:events';
import require$$1, { execSync } from 'node:child_process';
import path$2 from 'node:path';
import fs$3 from 'node:fs';
import process$1$1 from 'node:process';
import { u as up$1, d as dedent, p as parseJson, a as parseScript, b as imports, c as common, e as exports$1, o as object$1, v as variables, _ as _function, f as parseSvelte, g as array$1, w as walk$1, k as kit, h as addFromString, E as Element, j as index, l as parseHtml, m as parseHtml$1, A as AtRule2, n as parseCss, q as pc, r as intro, s as outro, t as log$1, x as cancel, y as box, z as multiselect, B as isCancel, C as confirm, D as createWorkspace, F as setupAddons, G as note, H as select, I as text, J as packageManagerPrompt, K as applyAddons, L as installDependencies, M as formatFiles, N as spinner, O as getHighlighter, P as detectSync, Q as getUserAgent, R as group, S as resolveCommand, T as from$1 } from './install-ClR4mYH4.js';
import 'node:readline';
import 'node:tty';
import { createGunzip } from 'node:zlib';
import { fileURLToPath } from 'node:url';
import { pipeline as pipeline$1 } from 'node:stream/promises';
import { a as commonjsGlobal, b as be, t as templates, c as create$1 } from './main-UNazaUHM.js';
import require$$5 from 'events';
import require$$1$1 from 'fs';
import require$$1$1$1 from 'path';
import 'node:module';
import 'os';
import 'url';
import 'node:fs/promises';
import 'child_process';
import 'process';
import 'stream';
import 'readline';

var name = "sv";
var version = "0.6.5";
var type = "module";
var description = "A CLI for creating and updating SvelteKit projects";
var license = "MIT";
var repository = {
	type: "git",
	url: "https://github.com/sveltejs/cli",
	directory: "packages/cli"
};
var homepage = "https://svelte.dev";
var scripts = {
	check: "tsc",
	format: "pnpm lint --write",
	lint: "prettier --check . --config ../../prettier.config.js --ignore-path ../../.gitignore --ignore-path .gitignore --ignore-path ../../.prettierignore"
};
var files = [
	"dist"
];
var bin = "./dist/bin.js";
var exports = {
	".": {
		types: "./dist/lib/index.d.ts",
		"default": "./dist/index.js"
	},
	"./testing": {
		types: "./dist/lib/testing.d.ts",
		"default": "./dist/testing.js"
	}
};
var devDependencies = {
	"@sveltejs/addons": "workspace:*",
	"@sveltejs/clack-prompts": "workspace:*",
	"@sveltejs/cli-core": "workspace:*",
	"@sveltejs/create": "workspace:*",
	"@types/degit": "^2.8.6",
	"@types/ps-tree": "^1.1.6",
	"@types/tar-fs": "^2.0.4",
	commander: "^12.1.0",
	degit: "^2.8.4",
	empathic: "^1.0.0",
	"package-manager-detector": "^0.2.2",
	picocolors: "^1.1.0",
	"ps-tree": "^1.2.0",
	"tar-fs": "^3.0.6",
	tinyexec: "^0.3.1",
	valibot: "^0.41.0"
};
var keywords = [
	"create",
	"new",
	"project",
	"starter",
	"svelte",
	"sveltekit",
	"template",
	"wizard"
];
var pkg = {
	name: name,
	version: version,
	type: type,
	description: description,
	license: license,
	repository: repository,
	homepage: homepage,
	scripts: scripts,
	files: files,
	bin: bin,
	exports: exports,
	devDependencies: devDependencies,
	keywords: keywords
};

var commander = {};

var argument = {};

var error = {};

/**
 * CommanderError class
 */

let CommanderError$3 = class CommanderError extends Error {
  /**
   * Constructs the CommanderError class
   * @param {number} exitCode suggested exit code which could be used with process.exit
   * @param {string} code an id string representing the error
   * @param {string} message human-readable description of the error
   */
  constructor(exitCode, code, message) {
    super(message);
    // properly capture stack trace in Node.js
    Error.captureStackTrace(this, this.constructor);
    this.name = this.constructor.name;
    this.code = code;
    this.exitCode = exitCode;
    this.nestedError = undefined;
  }
};

/**
 * InvalidArgumentError class
 */
let InvalidArgumentError$4 = class InvalidArgumentError extends CommanderError$3 {
  /**
   * Constructs the InvalidArgumentError class
   * @param {string} [message] explanation of why argument is invalid
   */
  constructor(message) {
    super(1, 'commander.invalidArgument', message);
    // properly capture stack trace in Node.js
    Error.captureStackTrace(this, this.constructor);
    this.name = this.constructor.name;
  }
};

error.CommanderError = CommanderError$3;
error.InvalidArgumentError = InvalidArgumentError$4;

const { InvalidArgumentError: InvalidArgumentError$3 } = error;

let Argument$3 = class Argument {
  /**
   * Initialize a new command argument with the given name and description.
   * The default is that the argument is required, and you can explicitly
   * indicate this with <> around the name. Put [] around the name for an optional argument.
   *
   * @param {string} name
   * @param {string} [description]
   */

  constructor(name, description) {
    this.description = description || '';
    this.variadic = false;
    this.parseArg = undefined;
    this.defaultValue = undefined;
    this.defaultValueDescription = undefined;
    this.argChoices = undefined;

    switch (name[0]) {
      case '<': // e.g. <required>
        this.required = true;
        this._name = name.slice(1, -1);
        break;
      case '[': // e.g. [optional]
        this.required = false;
        this._name = name.slice(1, -1);
        break;
      default:
        this.required = true;
        this._name = name;
        break;
    }

    if (this._name.length > 3 && this._name.slice(-3) === '...') {
      this.variadic = true;
      this._name = this._name.slice(0, -3);
    }
  }

  /**
   * Return argument name.
   *
   * @return {string}
   */

  name() {
    return this._name;
  }

  /**
   * @package
   */

  _concatValue(value, previous) {
    if (previous === this.defaultValue || !Array.isArray(previous)) {
      return [value];
    }

    return previous.concat(value);
  }

  /**
   * Set the default value, and optionally supply the description to be displayed in the help.
   *
   * @param {*} value
   * @param {string} [description]
   * @return {Argument}
   */

  default(value, description) {
    this.defaultValue = value;
    this.defaultValueDescription = description;
    return this;
  }

  /**
   * Set the custom handler for processing CLI command arguments into argument values.
   *
   * @param {Function} [fn]
   * @return {Argument}
   */

  argParser(fn) {
    this.parseArg = fn;
    return this;
  }

  /**
   * Only allow argument value to be one of choices.
   *
   * @param {string[]} values
   * @return {Argument}
   */

  choices(values) {
    this.argChoices = values.slice();
    this.parseArg = (arg, previous) => {
      if (!this.argChoices.includes(arg)) {
        throw new InvalidArgumentError$3(
          `Allowed choices are ${this.argChoices.join(', ')}.`,
        );
      }
      if (this.variadic) {
        return this._concatValue(arg, previous);
      }
      return arg;
    };
    return this;
  }

  /**
   * Make argument required.
   *
   * @returns {Argument}
   */
  argRequired() {
    this.required = true;
    return this;
  }

  /**
   * Make argument optional.
   *
   * @returns {Argument}
   */
  argOptional() {
    this.required = false;
    return this;
  }
};

/**
 * Takes an argument and returns its human readable equivalent for help usage.
 *
 * @param {Argument} arg
 * @return {string}
 * @private
 */

function humanReadableArgName$2(arg) {
  const nameOutput = arg.name() + (arg.variadic === true ? '...' : '');

  return arg.required ? '<' + nameOutput + '>' : '[' + nameOutput + ']';
}

argument.Argument = Argument$3;
argument.humanReadableArgName = humanReadableArgName$2;

var command = {};

var help = {};

const { humanReadableArgName: humanReadableArgName$1 } = argument;

/**
 * TypeScript import types for JSDoc, used by Visual Studio Code IntelliSense and `npm run typescript-checkJS`
 * https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html#import-types
 * @typedef { import("./argument.js").Argument } Argument
 * @typedef { import("./command.js").Command } Command
 * @typedef { import("./option.js").Option } Option
 */

// Although this is a class, methods are static in style to allow override using subclass or just functions.
let Help$3 = class Help {
  constructor() {
    this.helpWidth = undefined;
    this.sortSubcommands = false;
    this.sortOptions = false;
    this.showGlobalOptions = false;
  }

  /**
   * Get an array of the visible subcommands. Includes a placeholder for the implicit help command, if there is one.
   *
   * @param {Command} cmd
   * @returns {Command[]}
   */

  visibleCommands(cmd) {
    const visibleCommands = cmd.commands.filter((cmd) => !cmd._hidden);
    const helpCommand = cmd._getHelpCommand();
    if (helpCommand && !helpCommand._hidden) {
      visibleCommands.push(helpCommand);
    }
    if (this.sortSubcommands) {
      visibleCommands.sort((a, b) => {
        // @ts-ignore: because overloaded return type
        return a.name().localeCompare(b.name());
      });
    }
    return visibleCommands;
  }

  /**
   * Compare options for sort.
   *
   * @param {Option} a
   * @param {Option} b
   * @returns {number}
   */
  compareOptions(a, b) {
    const getSortKey = (option) => {
      // WYSIWYG for order displayed in help. Short used for comparison if present. No special handling for negated.
      return option.short
        ? option.short.replace(/^-/, '')
        : option.long.replace(/^--/, '');
    };
    return getSortKey(a).localeCompare(getSortKey(b));
  }

  /**
   * Get an array of the visible options. Includes a placeholder for the implicit help option, if there is one.
   *
   * @param {Command} cmd
   * @returns {Option[]}
   */

  visibleOptions(cmd) {
    const visibleOptions = cmd.options.filter((option) => !option.hidden);
    // Built-in help option.
    const helpOption = cmd._getHelpOption();
    if (helpOption && !helpOption.hidden) {
      // Automatically hide conflicting flags. Bit dubious but a historical behaviour that is convenient for single-command programs.
      const removeShort = helpOption.short && cmd._findOption(helpOption.short);
      const removeLong = helpOption.long && cmd._findOption(helpOption.long);
      if (!removeShort && !removeLong) {
        visibleOptions.push(helpOption); // no changes needed
      } else if (helpOption.long && !removeLong) {
        visibleOptions.push(
          cmd.createOption(helpOption.long, helpOption.description),
        );
      } else if (helpOption.short && !removeShort) {
        visibleOptions.push(
          cmd.createOption(helpOption.short, helpOption.description),
        );
      }
    }
    if (this.sortOptions) {
      visibleOptions.sort(this.compareOptions);
    }
    return visibleOptions;
  }

  /**
   * Get an array of the visible global options. (Not including help.)
   *
   * @param {Command} cmd
   * @returns {Option[]}
   */

  visibleGlobalOptions(cmd) {
    if (!this.showGlobalOptions) return [];

    const globalOptions = [];
    for (
      let ancestorCmd = cmd.parent;
      ancestorCmd;
      ancestorCmd = ancestorCmd.parent
    ) {
      const visibleOptions = ancestorCmd.options.filter(
        (option) => !option.hidden,
      );
      globalOptions.push(...visibleOptions);
    }
    if (this.sortOptions) {
      globalOptions.sort(this.compareOptions);
    }
    return globalOptions;
  }

  /**
   * Get an array of the arguments if any have a description.
   *
   * @param {Command} cmd
   * @returns {Argument[]}
   */

  visibleArguments(cmd) {
    // Side effect! Apply the legacy descriptions before the arguments are displayed.
    if (cmd._argsDescription) {
      cmd.registeredArguments.forEach((argument) => {
        argument.description =
          argument.description || cmd._argsDescription[argument.name()] || '';
      });
    }

    // If there are any arguments with a description then return all the arguments.
    if (cmd.registeredArguments.find((argument) => argument.description)) {
      return cmd.registeredArguments;
    }
    return [];
  }

  /**
   * Get the command term to show in the list of subcommands.
   *
   * @param {Command} cmd
   * @returns {string}
   */

  subcommandTerm(cmd) {
    // Legacy. Ignores custom usage string, and nested commands.
    const args = cmd.registeredArguments
      .map((arg) => humanReadableArgName$1(arg))
      .join(' ');
    return (
      cmd._name +
      (cmd._aliases[0] ? '|' + cmd._aliases[0] : '') +
      (cmd.options.length ? ' [options]' : '') + // simplistic check for non-help option
      (args ? ' ' + args : '')
    );
  }

  /**
   * Get the option term to show in the list of options.
   *
   * @param {Option} option
   * @returns {string}
   */

  optionTerm(option) {
    return option.flags;
  }

  /**
   * Get the argument term to show in the list of arguments.
   *
   * @param {Argument} argument
   * @returns {string}
   */

  argumentTerm(argument) {
    return argument.name();
  }

  /**
   * Get the longest command term length.
   *
   * @param {Command} cmd
   * @param {Help} helper
   * @returns {number}
   */

  longestSubcommandTermLength(cmd, helper) {
    return helper.visibleCommands(cmd).reduce((max, command) => {
      return Math.max(max, helper.subcommandTerm(command).length);
    }, 0);
  }

  /**
   * Get the longest option term length.
   *
   * @param {Command} cmd
   * @param {Help} helper
   * @returns {number}
   */

  longestOptionTermLength(cmd, helper) {
    return helper.visibleOptions(cmd).reduce((max, option) => {
      return Math.max(max, helper.optionTerm(option).length);
    }, 0);
  }

  /**
   * Get the longest global option term length.
   *
   * @param {Command} cmd
   * @param {Help} helper
   * @returns {number}
   */

  longestGlobalOptionTermLength(cmd, helper) {
    return helper.visibleGlobalOptions(cmd).reduce((max, option) => {
      return Math.max(max, helper.optionTerm(option).length);
    }, 0);
  }

  /**
   * Get the longest argument term length.
   *
   * @param {Command} cmd
   * @param {Help} helper
   * @returns {number}
   */

  longestArgumentTermLength(cmd, helper) {
    return helper.visibleArguments(cmd).reduce((max, argument) => {
      return Math.max(max, helper.argumentTerm(argument).length);
    }, 0);
  }

  /**
   * Get the command usage to be displayed at the top of the built-in help.
   *
   * @param {Command} cmd
   * @returns {string}
   */

  commandUsage(cmd) {
    // Usage
    let cmdName = cmd._name;
    if (cmd._aliases[0]) {
      cmdName = cmdName + '|' + cmd._aliases[0];
    }
    let ancestorCmdNames = '';
    for (
      let ancestorCmd = cmd.parent;
      ancestorCmd;
      ancestorCmd = ancestorCmd.parent
    ) {
      ancestorCmdNames = ancestorCmd.name() + ' ' + ancestorCmdNames;
    }
    return ancestorCmdNames + cmdName + ' ' + cmd.usage();
  }

  /**
   * Get the description for the command.
   *
   * @param {Command} cmd
   * @returns {string}
   */

  commandDescription(cmd) {
    // @ts-ignore: because overloaded return type
    return cmd.description();
  }

  /**
   * Get the subcommand summary to show in the list of subcommands.
   * (Fallback to description for backwards compatibility.)
   *
   * @param {Command} cmd
   * @returns {string}
   */

  subcommandDescription(cmd) {
    // @ts-ignore: because overloaded return type
    return cmd.summary() || cmd.description();
  }

  /**
   * Get the option description to show in the list of options.
   *
   * @param {Option} option
   * @return {string}
   */

  optionDescription(option) {
    const extraInfo = [];

    if (option.argChoices) {
      extraInfo.push(
        // use stringify to match the display of the default value
        `choices: ${option.argChoices.map((choice) => JSON.stringify(choice)).join(', ')}`,
      );
    }
    if (option.defaultValue !== undefined) {
      // default for boolean and negated more for programmer than end user,
      // but show true/false for boolean option as may be for hand-rolled env or config processing.
      const showDefault =
        option.required ||
        option.optional ||
        (option.isBoolean() && typeof option.defaultValue === 'boolean');
      if (showDefault) {
        extraInfo.push(
          `default: ${option.defaultValueDescription || JSON.stringify(option.defaultValue)}`,
        );
      }
    }
    // preset for boolean and negated are more for programmer than end user
    if (option.presetArg !== undefined && option.optional) {
      extraInfo.push(`preset: ${JSON.stringify(option.presetArg)}`);
    }
    if (option.envVar !== undefined) {
      extraInfo.push(`env: ${option.envVar}`);
    }
    if (extraInfo.length > 0) {
      return `${option.description} (${extraInfo.join(', ')})`;
    }

    return option.description;
  }

  /**
   * Get the argument description to show in the list of arguments.
   *
   * @param {Argument} argument
   * @return {string}
   */

  argumentDescription(argument) {
    const extraInfo = [];
    if (argument.argChoices) {
      extraInfo.push(
        // use stringify to match the display of the default value
        `choices: ${argument.argChoices.map((choice) => JSON.stringify(choice)).join(', ')}`,
      );
    }
    if (argument.defaultValue !== undefined) {
      extraInfo.push(
        `default: ${argument.defaultValueDescription || JSON.stringify(argument.defaultValue)}`,
      );
    }
    if (extraInfo.length > 0) {
      const extraDescripton = `(${extraInfo.join(', ')})`;
      if (argument.description) {
        return `${argument.description} ${extraDescripton}`;
      }
      return extraDescripton;
    }
    return argument.description;
  }

  /**
   * Generate the built-in help text.
   *
   * @param {Command} cmd
   * @param {Help} helper
   * @returns {string}
   */

  formatHelp(cmd, helper) {
    const termWidth = helper.padWidth(cmd, helper);
    const helpWidth = helper.helpWidth || 80;
    const itemIndentWidth = 2;
    const itemSeparatorWidth = 2; // between term and description
    function formatItem(term, description) {
      if (description) {
        const fullText = `${term.padEnd(termWidth + itemSeparatorWidth)}${description}`;
        return helper.wrap(
          fullText,
          helpWidth - itemIndentWidth,
          termWidth + itemSeparatorWidth,
        );
      }
      return term;
    }
    function formatList(textArray) {
      return textArray.join('\n').replace(/^/gm, ' '.repeat(itemIndentWidth));
    }

    // Usage
    let output = [`Usage: ${helper.commandUsage(cmd)}`, ''];

    // Description
    const commandDescription = helper.commandDescription(cmd);
    if (commandDescription.length > 0) {
      output = output.concat([
        helper.wrap(commandDescription, helpWidth, 0),
        '',
      ]);
    }

    // Arguments
    const argumentList = helper.visibleArguments(cmd).map((argument) => {
      return formatItem(
        helper.argumentTerm(argument),
        helper.argumentDescription(argument),
      );
    });
    if (argumentList.length > 0) {
      output = output.concat(['Arguments:', formatList(argumentList), '']);
    }

    // Options
    const optionList = helper.visibleOptions(cmd).map((option) => {
      return formatItem(
        helper.optionTerm(option),
        helper.optionDescription(option),
      );
    });
    if (optionList.length > 0) {
      output = output.concat(['Options:', formatList(optionList), '']);
    }

    if (this.showGlobalOptions) {
      const globalOptionList = helper
        .visibleGlobalOptions(cmd)
        .map((option) => {
          return formatItem(
            helper.optionTerm(option),
            helper.optionDescription(option),
          );
        });
      if (globalOptionList.length > 0) {
        output = output.concat([
          'Global Options:',
          formatList(globalOptionList),
          '',
        ]);
      }
    }

    // Commands
    const commandList = helper.visibleCommands(cmd).map((cmd) => {
      return formatItem(
        helper.subcommandTerm(cmd),
        helper.subcommandDescription(cmd),
      );
    });
    if (commandList.length > 0) {
      output = output.concat(['Commands:', formatList(commandList), '']);
    }

    return output.join('\n');
  }

  /**
   * Calculate the pad width from the maximum term length.
   *
   * @param {Command} cmd
   * @param {Help} helper
   * @returns {number}
   */

  padWidth(cmd, helper) {
    return Math.max(
      helper.longestOptionTermLength(cmd, helper),
      helper.longestGlobalOptionTermLength(cmd, helper),
      helper.longestSubcommandTermLength(cmd, helper),
      helper.longestArgumentTermLength(cmd, helper),
    );
  }

  /**
   * Wrap the given string to width characters per line, with lines after the first indented.
   * Do not wrap if insufficient room for wrapping (minColumnWidth), or string is manually formatted.
   *
   * @param {string} str
   * @param {number} width
   * @param {number} indent
   * @param {number} [minColumnWidth=40]
   * @return {string}
   *
   */

  wrap(str, width, indent, minColumnWidth = 40) {
    // Full \s characters, minus the linefeeds.
    const indents =
      ' \\f\\t\\v\u00a0\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff';
    // Detect manually wrapped and indented strings by searching for line break followed by spaces.
    const manualIndent = new RegExp(`[\\n][${indents}]+`);
    if (str.match(manualIndent)) return str;
    // Do not wrap if not enough room for a wrapped column of text (as could end up with a word per line).
    const columnWidth = width - indent;
    if (columnWidth < minColumnWidth) return str;

    const leadingStr = str.slice(0, indent);
    const columnText = str.slice(indent).replace('\r\n', '\n');
    const indentString = ' '.repeat(indent);
    const zeroWidthSpace = '\u200B';
    const breaks = `\\s${zeroWidthSpace}`;
    // Match line end (so empty lines don't collapse),
    // or as much text as will fit in column, or excess text up to first break.
    const regex = new RegExp(
      `\n|.{1,${columnWidth - 1}}([${breaks}]|$)|[^${breaks}]+?([${breaks}]|$)`,
      'g',
    );
    const lines = columnText.match(regex) || [];
    return (
      leadingStr +
      lines
        .map((line, i) => {
          if (line === '\n') return ''; // preserve empty lines
          return (i > 0 ? indentString : '') + line.trimEnd();
        })
        .join('\n')
    );
  }
};

help.Help = Help$3;

var option = {};

const { InvalidArgumentError: InvalidArgumentError$2 } = error;

let Option$3 = class Option {
  /**
   * Initialize a new `Option` with the given `flags` and `description`.
   *
   * @param {string} flags
   * @param {string} [description]
   */

  constructor(flags, description) {
    this.flags = flags;
    this.description = description || '';

    this.required = flags.includes('<'); // A value must be supplied when the option is specified.
    this.optional = flags.includes('['); // A value is optional when the option is specified.
    // variadic test ignores <value,...> et al which might be used to describe custom splitting of single argument
    this.variadic = /\w\.\.\.[>\]]$/.test(flags); // The option can take multiple values.
    this.mandatory = false; // The option must have a value after parsing, which usually means it must be specified on command line.
    const optionFlags = splitOptionFlags(flags);
    this.short = optionFlags.shortFlag;
    this.long = optionFlags.longFlag;
    this.negate = false;
    if (this.long) {
      this.negate = this.long.startsWith('--no-');
    }
    this.defaultValue = undefined;
    this.defaultValueDescription = undefined;
    this.presetArg = undefined;
    this.envVar = undefined;
    this.parseArg = undefined;
    this.hidden = false;
    this.argChoices = undefined;
    this.conflictsWith = [];
    this.implied = undefined;
  }

  /**
   * Set the default value, and optionally supply the description to be displayed in the help.
   *
   * @param {*} value
   * @param {string} [description]
   * @return {Option}
   */

  default(value, description) {
    this.defaultValue = value;
    this.defaultValueDescription = description;
    return this;
  }

  /**
   * Preset to use when option used without option-argument, especially optional but also boolean and negated.
   * The custom processing (parseArg) is called.
   *
   * @example
   * new Option('--color').default('GREYSCALE').preset('RGB');
   * new Option('--donate [amount]').preset('20').argParser(parseFloat);
   *
   * @param {*} arg
   * @return {Option}
   */

  preset(arg) {
    this.presetArg = arg;
    return this;
  }

  /**
   * Add option name(s) that conflict with this option.
   * An error will be displayed if conflicting options are found during parsing.
   *
   * @example
   * new Option('--rgb').conflicts('cmyk');
   * new Option('--js').conflicts(['ts', 'jsx']);
   *
   * @param {(string | string[])} names
   * @return {Option}
   */

  conflicts(names) {
    this.conflictsWith = this.conflictsWith.concat(names);
    return this;
  }

  /**
   * Specify implied option values for when this option is set and the implied options are not.
   *
   * The custom processing (parseArg) is not called on the implied values.
   *
   * @example
   * program
   *   .addOption(new Option('--log', 'write logging information to file'))
   *   .addOption(new Option('--trace', 'log extra details').implies({ log: 'trace.txt' }));
   *
   * @param {object} impliedOptionValues
   * @return {Option}
   */
  implies(impliedOptionValues) {
    let newImplied = impliedOptionValues;
    if (typeof impliedOptionValues === 'string') {
      // string is not documented, but easy mistake and we can do what user probably intended.
      newImplied = { [impliedOptionValues]: true };
    }
    this.implied = Object.assign(this.implied || {}, newImplied);
    return this;
  }

  /**
   * Set environment variable to check for option value.
   *
   * An environment variable is only used if when processed the current option value is
   * undefined, or the source of the current value is 'default' or 'config' or 'env'.
   *
   * @param {string} name
   * @return {Option}
   */

  env(name) {
    this.envVar = name;
    return this;
  }

  /**
   * Set the custom handler for processing CLI option arguments into option values.
   *
   * @param {Function} [fn]
   * @return {Option}
   */

  argParser(fn) {
    this.parseArg = fn;
    return this;
  }

  /**
   * Whether the option is mandatory and must have a value after parsing.
   *
   * @param {boolean} [mandatory=true]
   * @return {Option}
   */

  makeOptionMandatory(mandatory = true) {
    this.mandatory = !!mandatory;
    return this;
  }

  /**
   * Hide option in help.
   *
   * @param {boolean} [hide=true]
   * @return {Option}
   */

  hideHelp(hide = true) {
    this.hidden = !!hide;
    return this;
  }

  /**
   * @package
   */

  _concatValue(value, previous) {
    if (previous === this.defaultValue || !Array.isArray(previous)) {
      return [value];
    }

    return previous.concat(value);
  }

  /**
   * Only allow option value to be one of choices.
   *
   * @param {string[]} values
   * @return {Option}
   */

  choices(values) {
    this.argChoices = values.slice();
    this.parseArg = (arg, previous) => {
      if (!this.argChoices.includes(arg)) {
        throw new InvalidArgumentError$2(
          `Allowed choices are ${this.argChoices.join(', ')}.`,
        );
      }
      if (this.variadic) {
        return this._concatValue(arg, previous);
      }
      return arg;
    };
    return this;
  }

  /**
   * Return option name.
   *
   * @return {string}
   */

  name() {
    if (this.long) {
      return this.long.replace(/^--/, '');
    }
    return this.short.replace(/^-/, '');
  }

  /**
   * Return option name, in a camelcase format that can be used
   * as a object attribute key.
   *
   * @return {string}
   */

  attributeName() {
    return camelcase(this.name().replace(/^no-/, ''));
  }

  /**
   * Check if `arg` matches the short or long flag.
   *
   * @param {string} arg
   * @return {boolean}
   * @package
   */

  is(arg) {
    return this.short === arg || this.long === arg;
  }

  /**
   * Return whether a boolean option.
   *
   * Options are one of boolean, negated, required argument, or optional argument.
   *
   * @return {boolean}
   * @package
   */

  isBoolean() {
    return !this.required && !this.optional && !this.negate;
  }
};

/**
 * This class is to make it easier to work with dual options, without changing the existing
 * implementation. We support separate dual options for separate positive and negative options,
 * like `--build` and `--no-build`, which share a single option value. This works nicely for some
 * use cases, but is tricky for others where we want separate behaviours despite
 * the single shared option value.
 */
let DualOptions$1 = class DualOptions {
  /**
   * @param {Option[]} options
   */
  constructor(options) {
    this.positiveOptions = new Map();
    this.negativeOptions = new Map();
    this.dualOptions = new Set();
    options.forEach((option) => {
      if (option.negate) {
        this.negativeOptions.set(option.attributeName(), option);
      } else {
        this.positiveOptions.set(option.attributeName(), option);
      }
    });
    this.negativeOptions.forEach((value, key) => {
      if (this.positiveOptions.has(key)) {
        this.dualOptions.add(key);
      }
    });
  }

  /**
   * Did the value come from the option, and not from possible matching dual option?
   *
   * @param {*} value
   * @param {Option} option
   * @returns {boolean}
   */
  valueFromOption(value, option) {
    const optionKey = option.attributeName();
    if (!this.dualOptions.has(optionKey)) return true;

    // Use the value to deduce if (probably) came from the option.
    const preset = this.negativeOptions.get(optionKey).presetArg;
    const negativeValue = preset !== undefined ? preset : false;
    return option.negate === (negativeValue === value);
  }
};

/**
 * Convert string from kebab-case to camelCase.
 *
 * @param {string} str
 * @return {string}
 * @private
 */

function camelcase(str) {
  return str.split('-').reduce((str, word) => {
    return str + word[0].toUpperCase() + word.slice(1);
  });
}

/**
 * Split the short and long flag out of something like '-m,--mixed <value>'
 *
 * @private
 */

function splitOptionFlags(flags) {
  let shortFlag;
  let longFlag;
  // Use original very loose parsing to maintain backwards compatibility for now,
  // which allowed for example unintended `-sw, --short-word` [sic].
  const flagParts = flags.split(/[ |,]+/);
  if (flagParts.length > 1 && !/^[[<]/.test(flagParts[1]))
    shortFlag = flagParts.shift();
  longFlag = flagParts.shift();
  // Add support for lone short flag without significantly changing parsing!
  if (!shortFlag && /^-[^-]$/.test(longFlag)) {
    shortFlag = longFlag;
    longFlag = undefined;
  }
  return { shortFlag, longFlag };
}

option.Option = Option$3;
option.DualOptions = DualOptions$1;

var suggestSimilar$2 = {};

const maxDistance = 3;

function editDistance(a, b) {
  // https://en.wikipedia.org/wiki/Damerau–Levenshtein_distance
  // Calculating optimal string alignment distance, no substring is edited more than once.
  // (Simple implementation.)

  // Quick early exit, return worst case.
  if (Math.abs(a.length - b.length) > maxDistance)
    return Math.max(a.length, b.length);

  // distance between prefix substrings of a and b
  const d = [];

  // pure deletions turn a into empty string
  for (let i = 0; i <= a.length; i++) {
    d[i] = [i];
  }
  // pure insertions turn empty string into b
  for (let j = 0; j <= b.length; j++) {
    d[0][j] = j;
  }

  // fill matrix
  for (let j = 1; j <= b.length; j++) {
    for (let i = 1; i <= a.length; i++) {
      let cost = 1;
      if (a[i - 1] === b[j - 1]) {
        cost = 0;
      } else {
        cost = 1;
      }
      d[i][j] = Math.min(
        d[i - 1][j] + 1, // deletion
        d[i][j - 1] + 1, // insertion
        d[i - 1][j - 1] + cost, // substitution
      );
      // transposition
      if (i > 1 && j > 1 && a[i - 1] === b[j - 2] && a[i - 2] === b[j - 1]) {
        d[i][j] = Math.min(d[i][j], d[i - 2][j - 2] + 1);
      }
    }
  }

  return d[a.length][b.length];
}

/**
 * Find close matches, restricted to same number of edits.
 *
 * @param {string} word
 * @param {string[]} candidates
 * @returns {string}
 */

function suggestSimilar$1(word, candidates) {
  if (!candidates || candidates.length === 0) return '';
  // remove possible duplicates
  candidates = Array.from(new Set(candidates));

  const searchingOptions = word.startsWith('--');
  if (searchingOptions) {
    word = word.slice(2);
    candidates = candidates.map((candidate) => candidate.slice(2));
  }

  let similar = [];
  let bestDistance = maxDistance;
  const minSimilarity = 0.4;
  candidates.forEach((candidate) => {
    if (candidate.length <= 1) return; // no one character guesses

    const distance = editDistance(word, candidate);
    const length = Math.max(word.length, candidate.length);
    const similarity = (length - distance) / length;
    if (similarity > minSimilarity) {
      if (distance < bestDistance) {
        // better edit distance, throw away previous worse matches
        bestDistance = distance;
        similar = [candidate];
      } else if (distance === bestDistance) {
        similar.push(candidate);
      }
    }
  });

  similar.sort((a, b) => a.localeCompare(b));
  if (searchingOptions) {
    similar = similar.map((candidate) => `--${candidate}`);
  }

  if (similar.length > 1) {
    return `\n(Did you mean one of ${similar.join(', ')}?)`;
  }
  if (similar.length === 1) {
    return `\n(Did you mean ${similar[0]}?)`;
  }
  return '';
}

suggestSimilar$2.suggestSimilar = suggestSimilar$1;

const EventEmitter$1 = require$$0.EventEmitter;
const childProcess = require$$1;
const path$1 = path$2;
const fs$2 = fs$3;
const process$1 = process$1$1;

const { Argument: Argument$2, humanReadableArgName } = argument;
const { CommanderError: CommanderError$2 } = error;
const { Help: Help$2 } = help;
const { Option: Option$2, DualOptions } = option;
const { suggestSimilar } = suggestSimilar$2;

let Command$2 = class Command extends EventEmitter$1 {
  /**
   * Initialize a new `Command`.
   *
   * @param {string} [name]
   */

  constructor(name) {
    super();
    /** @type {Command[]} */
    this.commands = [];
    /** @type {Option[]} */
    this.options = [];
    this.parent = null;
    this._allowUnknownOption = false;
    this._allowExcessArguments = true;
    /** @type {Argument[]} */
    this.registeredArguments = [];
    this._args = this.registeredArguments; // deprecated old name
    /** @type {string[]} */
    this.args = []; // cli args with options removed
    this.rawArgs = [];
    this.processedArgs = []; // like .args but after custom processing and collecting variadic
    this._scriptPath = null;
    this._name = name || '';
    this._optionValues = {};
    this._optionValueSources = {}; // default, env, cli etc
    this._storeOptionsAsProperties = false;
    this._actionHandler = null;
    this._executableHandler = false;
    this._executableFile = null; // custom name for executable
    this._executableDir = null; // custom search directory for subcommands
    this._defaultCommandName = null;
    this._exitCallback = null;
    this._aliases = [];
    this._combineFlagAndOptionalValue = true;
    this._description = '';
    this._summary = '';
    this._argsDescription = undefined; // legacy
    this._enablePositionalOptions = false;
    this._passThroughOptions = false;
    this._lifeCycleHooks = {}; // a hash of arrays
    /** @type {(boolean | string)} */
    this._showHelpAfterError = false;
    this._showSuggestionAfterError = true;

    // see .configureOutput() for docs
    this._outputConfiguration = {
      writeOut: (str) => process$1.stdout.write(str),
      writeErr: (str) => process$1.stderr.write(str),
      getOutHelpWidth: () =>
        process$1.stdout.isTTY ? process$1.stdout.columns : undefined,
      getErrHelpWidth: () =>
        process$1.stderr.isTTY ? process$1.stderr.columns : undefined,
      outputError: (str, write) => write(str),
    };

    this._hidden = false;
    /** @type {(Option | null | undefined)} */
    this._helpOption = undefined; // Lazy created on demand. May be null if help option is disabled.
    this._addImplicitHelpCommand = undefined; // undecided whether true or false yet, not inherited
    /** @type {Command} */
    this._helpCommand = undefined; // lazy initialised, inherited
    this._helpConfiguration = {};
  }

  /**
   * Copy settings that are useful to have in common across root command and subcommands.
   *
   * (Used internally when adding a command using `.command()` so subcommands inherit parent settings.)
   *
   * @param {Command} sourceCommand
   * @return {Command} `this` command for chaining
   */
  copyInheritedSettings(sourceCommand) {
    this._outputConfiguration = sourceCommand._outputConfiguration;
    this._helpOption = sourceCommand._helpOption;
    this._helpCommand = sourceCommand._helpCommand;
    this._helpConfiguration = sourceCommand._helpConfiguration;
    this._exitCallback = sourceCommand._exitCallback;
    this._storeOptionsAsProperties = sourceCommand._storeOptionsAsProperties;
    this._combineFlagAndOptionalValue =
      sourceCommand._combineFlagAndOptionalValue;
    this._allowExcessArguments = sourceCommand._allowExcessArguments;
    this._enablePositionalOptions = sourceCommand._enablePositionalOptions;
    this._showHelpAfterError = sourceCommand._showHelpAfterError;
    this._showSuggestionAfterError = sourceCommand._showSuggestionAfterError;

    return this;
  }

  /**
   * @returns {Command[]}
   * @private
   */

  _getCommandAndAncestors() {
    const result = [];
    // eslint-disable-next-line @typescript-eslint/no-this-alias
    for (let command = this; command; command = command.parent) {
      result.push(command);
    }
    return result;
  }

  /**
   * Define a command.
   *
   * There are two styles of command: pay attention to where to put the description.
   *
   * @example
   * // Command implemented using action handler (description is supplied separately to `.command`)
   * program
   *   .command('clone <source> [destination]')
   *   .description('clone a repository into a newly created directory')
   *   .action((source, destination) => {
   *     console.log('clone command called');
   *   });
   *
   * // Command implemented using separate executable file (description is second parameter to `.command`)
   * program
   *   .command('start <service>', 'start named service')
   *   .command('stop [service]', 'stop named service, or all if no name supplied');
   *
   * @param {string} nameAndArgs - command name and arguments, args are `<required>` or `[optional]` and last may also be `variadic...`
   * @param {(object | string)} [actionOptsOrExecDesc] - configuration options (for action), or description (for executable)
   * @param {object} [execOpts] - configuration options (for executable)
   * @return {Command} returns new command for action handler, or `this` for executable command
   */

  command(nameAndArgs, actionOptsOrExecDesc, execOpts) {
    let desc = actionOptsOrExecDesc;
    let opts = execOpts;
    if (typeof desc === 'object' && desc !== null) {
      opts = desc;
      desc = null;
    }
    opts = opts || {};
    const [, name, args] = nameAndArgs.match(/([^ ]+) *(.*)/);

    const cmd = this.createCommand(name);
    if (desc) {
      cmd.description(desc);
      cmd._executableHandler = true;
    }
    if (opts.isDefault) this._defaultCommandName = cmd._name;
    cmd._hidden = !!(opts.noHelp || opts.hidden); // noHelp is deprecated old name for hidden
    cmd._executableFile = opts.executableFile || null; // Custom name for executable file, set missing to null to match constructor
    if (args) cmd.arguments(args);
    this._registerCommand(cmd);
    cmd.parent = this;
    cmd.copyInheritedSettings(this);

    if (desc) return this;
    return cmd;
  }

  /**
   * Factory routine to create a new unattached command.
   *
   * See .command() for creating an attached subcommand, which uses this routine to
   * create the command. You can override createCommand to customise subcommands.
   *
   * @param {string} [name]
   * @return {Command} new command
   */

  createCommand(name) {
    return new Command(name);
  }

  /**
   * You can customise the help with a subclass of Help by overriding createHelp,
   * or by overriding Help properties using configureHelp().
   *
   * @return {Help}
   */

  createHelp() {
    return Object.assign(new Help$2(), this.configureHelp());
  }

  /**
   * You can customise the help by overriding Help properties using configureHelp(),
   * or with a subclass of Help by overriding createHelp().
   *
   * @param {object} [configuration] - configuration options
   * @return {(Command | object)} `this` command for chaining, or stored configuration
   */

  configureHelp(configuration) {
    if (configuration === undefined) return this._helpConfiguration;

    this._helpConfiguration = configuration;
    return this;
  }

  /**
   * The default output goes to stdout and stderr. You can customise this for special
   * applications. You can also customise the display of errors by overriding outputError.
   *
   * The configuration properties are all functions:
   *
   *     // functions to change where being written, stdout and stderr
   *     writeOut(str)
   *     writeErr(str)
   *     // matching functions to specify width for wrapping help
   *     getOutHelpWidth()
   *     getErrHelpWidth()
   *     // functions based on what is being written out
   *     outputError(str, write) // used for displaying errors, and not used for displaying help
   *
   * @param {object} [configuration] - configuration options
   * @return {(Command | object)} `this` command for chaining, or stored configuration
   */

  configureOutput(configuration) {
    if (configuration === undefined) return this._outputConfiguration;

    Object.assign(this._outputConfiguration, configuration);
    return this;
  }

  /**
   * Display the help or a custom message after an error occurs.
   *
   * @param {(boolean|string)} [displayHelp]
   * @return {Command} `this` command for chaining
   */
  showHelpAfterError(displayHelp = true) {
    if (typeof displayHelp !== 'string') displayHelp = !!displayHelp;
    this._showHelpAfterError = displayHelp;
    return this;
  }

  /**
   * Display suggestion of similar commands for unknown commands, or options for unknown options.
   *
   * @param {boolean} [displaySuggestion]
   * @return {Command} `this` command for chaining
   */
  showSuggestionAfterError(displaySuggestion = true) {
    this._showSuggestionAfterError = !!displaySuggestion;
    return this;
  }

  /**
   * Add a prepared subcommand.
   *
   * See .command() for creating an attached subcommand which inherits settings from its parent.
   *
   * @param {Command} cmd - new subcommand
   * @param {object} [opts] - configuration options
   * @return {Command} `this` command for chaining
   */

  addCommand(cmd, opts) {
    if (!cmd._name) {
      throw new Error(`Command passed to .addCommand() must have a name
- specify the name in Command constructor or using .name()`);
    }

    opts = opts || {};
    if (opts.isDefault) this._defaultCommandName = cmd._name;
    if (opts.noHelp || opts.hidden) cmd._hidden = true; // modifying passed command due to existing implementation

    this._registerCommand(cmd);
    cmd.parent = this;
    cmd._checkForBrokenPassThrough();

    return this;
  }

  /**
   * Factory routine to create a new unattached argument.
   *
   * See .argument() for creating an attached argument, which uses this routine to
   * create the argument. You can override createArgument to return a custom argument.
   *
   * @param {string} name
   * @param {string} [description]
   * @return {Argument} new argument
   */

  createArgument(name, description) {
    return new Argument$2(name, description);
  }

  /**
   * Define argument syntax for command.
   *
   * The default is that the argument is required, and you can explicitly
   * indicate this with <> around the name. Put [] around the name for an optional argument.
   *
   * @example
   * program.argument('<input-file>');
   * program.argument('[output-file]');
   *
   * @param {string} name
   * @param {string} [description]
   * @param {(Function|*)} [fn] - custom argument processing function
   * @param {*} [defaultValue]
   * @return {Command} `this` command for chaining
   */
  argument(name, description, fn, defaultValue) {
    const argument = this.createArgument(name, description);
    if (typeof fn === 'function') {
      argument.default(defaultValue).argParser(fn);
    } else {
      argument.default(fn);
    }
    this.addArgument(argument);
    return this;
  }

  /**
   * Define argument syntax for command, adding multiple at once (without descriptions).
   *
   * See also .argument().
   *
   * @example
   * program.arguments('<cmd> [env]');
   *
   * @param {string} names
   * @return {Command} `this` command for chaining
   */

  arguments(names) {
    names
      .trim()
      .split(/ +/)
      .forEach((detail) => {
        this.argument(detail);
      });
    return this;
  }

  /**
   * Define argument syntax for command, adding a prepared argument.
   *
   * @param {Argument} argument
   * @return {Command} `this` command for chaining
   */
  addArgument(argument) {
    const previousArgument = this.registeredArguments.slice(-1)[0];
    if (previousArgument && previousArgument.variadic) {
      throw new Error(
        `only the last argument can be variadic '${previousArgument.name()}'`,
      );
    }
    if (
      argument.required &&
      argument.defaultValue !== undefined &&
      argument.parseArg === undefined
    ) {
      throw new Error(
        `a default value for a required argument is never used: '${argument.name()}'`,
      );
    }
    this.registeredArguments.push(argument);
    return this;
  }

  /**
   * Customise or override default help command. By default a help command is automatically added if your command has subcommands.
   *
   * @example
   *    program.helpCommand('help [cmd]');
   *    program.helpCommand('help [cmd]', 'show help');
   *    program.helpCommand(false); // suppress default help command
   *    program.helpCommand(true); // add help command even if no subcommands
   *
   * @param {string|boolean} enableOrNameAndArgs - enable with custom name and/or arguments, or boolean to override whether added
   * @param {string} [description] - custom description
   * @return {Command} `this` command for chaining
   */

  helpCommand(enableOrNameAndArgs, description) {
    if (typeof enableOrNameAndArgs === 'boolean') {
      this._addImplicitHelpCommand = enableOrNameAndArgs;
      return this;
    }

    enableOrNameAndArgs = enableOrNameAndArgs ?? 'help [command]';
    const [, helpName, helpArgs] = enableOrNameAndArgs.match(/([^ ]+) *(.*)/);
    const helpDescription = description ?? 'display help for command';

    const helpCommand = this.createCommand(helpName);
    helpCommand.helpOption(false);
    if (helpArgs) helpCommand.arguments(helpArgs);
    if (helpDescription) helpCommand.description(helpDescription);

    this._addImplicitHelpCommand = true;
    this._helpCommand = helpCommand;

    return this;
  }

  /**
   * Add prepared custom help command.
   *
   * @param {(Command|string|boolean)} helpCommand - custom help command, or deprecated enableOrNameAndArgs as for `.helpCommand()`
   * @param {string} [deprecatedDescription] - deprecated custom description used with custom name only
   * @return {Command} `this` command for chaining
   */
  addHelpCommand(helpCommand, deprecatedDescription) {
    // If not passed an object, call through to helpCommand for backwards compatibility,
    // as addHelpCommand was originally used like helpCommand is now.
    if (typeof helpCommand !== 'object') {
      this.helpCommand(helpCommand, deprecatedDescription);
      return this;
    }

    this._addImplicitHelpCommand = true;
    this._helpCommand = helpCommand;
    return this;
  }

  /**
   * Lazy create help command.
   *
   * @return {(Command|null)}
   * @package
   */
  _getHelpCommand() {
    const hasImplicitHelpCommand =
      this._addImplicitHelpCommand ??
      (this.commands.length &&
        !this._actionHandler &&
        !this._findCommand('help'));

    if (hasImplicitHelpCommand) {
      if (this._helpCommand === undefined) {
        this.helpCommand(undefined, undefined); // use default name and description
      }
      return this._helpCommand;
    }
    return null;
  }

  /**
   * Add hook for life cycle event.
   *
   * @param {string} event
   * @param {Function} listener
   * @return {Command} `this` command for chaining
   */

  hook(event, listener) {
    const allowedValues = ['preSubcommand', 'preAction', 'postAction'];
    if (!allowedValues.includes(event)) {
      throw new Error(`Unexpected value for event passed to hook : '${event}'.
Expecting one of '${allowedValues.join("', '")}'`);
    }
    if (this._lifeCycleHooks[event]) {
      this._lifeCycleHooks[event].push(listener);
    } else {
      this._lifeCycleHooks[event] = [listener];
    }
    return this;
  }

  /**
   * Register callback to use as replacement for calling process.exit.
   *
   * @param {Function} [fn] optional callback which will be passed a CommanderError, defaults to throwing
   * @return {Command} `this` command for chaining
   */

  exitOverride(fn) {
    if (fn) {
      this._exitCallback = fn;
    } else {
      this._exitCallback = (err) => {
        if (err.code !== 'commander.executeSubCommandAsync') {
          throw err;
        }
      };
    }
    return this;
  }

  /**
   * Call process.exit, and _exitCallback if defined.
   *
   * @param {number} exitCode exit code for using with process.exit
   * @param {string} code an id string representing the error
   * @param {string} message human-readable description of the error
   * @return never
   * @private
   */

  _exit(exitCode, code, message) {
    if (this._exitCallback) {
      this._exitCallback(new CommanderError$2(exitCode, code, message));
      // Expecting this line is not reached.
    }
    process$1.exit(exitCode);
  }

  /**
   * Register callback `fn` for the command.
   *
   * @example
   * program
   *   .command('serve')
   *   .description('start service')
   *   .action(function() {
   *      // do work here
   *   });
   *
   * @param {Function} fn
   * @return {Command} `this` command for chaining
   */

  action(fn) {
    const listener = (args) => {
      // The .action callback takes an extra parameter which is the command or options.
      const expectedArgsCount = this.registeredArguments.length;
      const actionArgs = args.slice(0, expectedArgsCount);
      if (this._storeOptionsAsProperties) {
        actionArgs[expectedArgsCount] = this; // backwards compatible "options"
      } else {
        actionArgs[expectedArgsCount] = this.opts();
      }
      actionArgs.push(this);

      return fn.apply(this, actionArgs);
    };
    this._actionHandler = listener;
    return this;
  }

  /**
   * Factory routine to create a new unattached option.
   *
   * See .option() for creating an attached option, which uses this routine to
   * create the option. You can override createOption to return a custom option.
   *
   * @param {string} flags
   * @param {string} [description]
   * @return {Option} new option
   */

  createOption(flags, description) {
    return new Option$2(flags, description);
  }

  /**
   * Wrap parseArgs to catch 'commander.invalidArgument'.
   *
   * @param {(Option | Argument)} target
   * @param {string} value
   * @param {*} previous
   * @param {string} invalidArgumentMessage
   * @private
   */

  _callParseArg(target, value, previous, invalidArgumentMessage) {
    try {
      return target.parseArg(value, previous);
    } catch (err) {
      if (err.code === 'commander.invalidArgument') {
        const message = `${invalidArgumentMessage} ${err.message}`;
        this.error(message, { exitCode: err.exitCode, code: err.code });
      }
      throw err;
    }
  }

  /**
   * Check for option flag conflicts.
   * Register option if no conflicts found, or throw on conflict.
   *
   * @param {Option} option
   * @private
   */

  _registerOption(option) {
    const matchingOption =
      (option.short && this._findOption(option.short)) ||
      (option.long && this._findOption(option.long));
    if (matchingOption) {
      const matchingFlag =
        option.long && this._findOption(option.long)
          ? option.long
          : option.short;
      throw new Error(`Cannot add option '${option.flags}'${this._name && ` to command '${this._name}'`} due to conflicting flag '${matchingFlag}'
-  already used by option '${matchingOption.flags}'`);
    }

    this.options.push(option);
  }

  /**
   * Check for command name and alias conflicts with existing commands.
   * Register command if no conflicts found, or throw on conflict.
   *
   * @param {Command} command
   * @private
   */

  _registerCommand(command) {
    const knownBy = (cmd) => {
      return [cmd.name()].concat(cmd.aliases());
    };

    const alreadyUsed = knownBy(command).find((name) =>
      this._findCommand(name),
    );
    if (alreadyUsed) {
      const existingCmd = knownBy(this._findCommand(alreadyUsed)).join('|');
      const newCmd = knownBy(command).join('|');
      throw new Error(
        `cannot add command '${newCmd}' as already have command '${existingCmd}'`,
      );
    }

    this.commands.push(command);
  }

  /**
   * Add an option.
   *
   * @param {Option} option
   * @return {Command} `this` command for chaining
   */
  addOption(option) {
    this._registerOption(option);

    const oname = option.name();
    const name = option.attributeName();

    // store default value
    if (option.negate) {
      // --no-foo is special and defaults foo to true, unless a --foo option is already defined
      const positiveLongFlag = option.long.replace(/^--no-/, '--');
      if (!this._findOption(positiveLongFlag)) {
        this.setOptionValueWithSource(
          name,
          option.defaultValue === undefined ? true : option.defaultValue,
          'default',
        );
      }
    } else if (option.defaultValue !== undefined) {
      this.setOptionValueWithSource(name, option.defaultValue, 'default');
    }

    // handler for cli and env supplied values
    const handleOptionValue = (val, invalidValueMessage, valueSource) => {
      // val is null for optional option used without an optional-argument.
      // val is undefined for boolean and negated option.
      if (val == null && option.presetArg !== undefined) {
        val = option.presetArg;
      }

      // custom processing
      const oldValue = this.getOptionValue(name);
      if (val !== null && option.parseArg) {
        val = this._callParseArg(option, val, oldValue, invalidValueMessage);
      } else if (val !== null && option.variadic) {
        val = option._concatValue(val, oldValue);
      }

      // Fill-in appropriate missing values. Long winded but easy to follow.
      if (val == null) {
        if (option.negate) {
          val = false;
        } else if (option.isBoolean() || option.optional) {
          val = true;
        } else {
          val = ''; // not normal, parseArg might have failed or be a mock function for testing
        }
      }
      this.setOptionValueWithSource(name, val, valueSource);
    };

    this.on('option:' + oname, (val) => {
      const invalidValueMessage = `error: option '${option.flags}' argument '${val}' is invalid.`;
      handleOptionValue(val, invalidValueMessage, 'cli');
    });

    if (option.envVar) {
      this.on('optionEnv:' + oname, (val) => {
        const invalidValueMessage = `error: option '${option.flags}' value '${val}' from env '${option.envVar}' is invalid.`;
        handleOptionValue(val, invalidValueMessage, 'env');
      });
    }

    return this;
  }

  /**
   * Internal implementation shared by .option() and .requiredOption()
   *
   * @return {Command} `this` command for chaining
   * @private
   */
  _optionEx(config, flags, description, fn, defaultValue) {
    if (typeof flags === 'object' && flags instanceof Option$2) {
      throw new Error(
        'To add an Option object use addOption() instead of option() or requiredOption()',
      );
    }
    const option = this.createOption(flags, description);
    option.makeOptionMandatory(!!config.mandatory);
    if (typeof fn === 'function') {
      option.default(defaultValue).argParser(fn);
    } else if (fn instanceof RegExp) {
      // deprecated
      const regex = fn;
      fn = (val, def) => {
        const m = regex.exec(val);
        return m ? m[0] : def;
      };
      option.default(defaultValue).argParser(fn);
    } else {
      option.default(fn);
    }

    return this.addOption(option);
  }

  /**
   * Define option with `flags`, `description`, and optional argument parsing function or `defaultValue` or both.
   *
   * The `flags` string contains the short and/or long flags, separated by comma, a pipe or space. A required
   * option-argument is indicated by `<>` and an optional option-argument by `[]`.
   *
   * See the README for more details, and see also addOption() and requiredOption().
   *
   * @example
   * program
   *     .option('-p, --pepper', 'add pepper')
   *     .option('-p, --pizza-type <TYPE>', 'type of pizza') // required option-argument
   *     .option('-c, --cheese [CHEESE]', 'add extra cheese', 'mozzarella') // optional option-argument with default
   *     .option('-t, --tip <VALUE>', 'add tip to purchase cost', parseFloat) // custom parse function
   *
   * @param {string} flags
   * @param {string} [description]
   * @param {(Function|*)} [parseArg] - custom option processing function or default value
   * @param {*} [defaultValue]
   * @return {Command} `this` command for chaining
   */

  option(flags, description, parseArg, defaultValue) {
    return this._optionEx({}, flags, description, parseArg, defaultValue);
  }

  /**
   * Add a required option which must have a value after parsing. This usually means
   * the option must be specified on the command line. (Otherwise the same as .option().)
   *
   * The `flags` string contains the short and/or long flags, separated by comma, a pipe or space.
   *
   * @param {string} flags
   * @param {string} [description]
   * @param {(Function|*)} [parseArg] - custom option processing function or default value
   * @param {*} [defaultValue]
   * @return {Command} `this` command for chaining
   */

  requiredOption(flags, description, parseArg, defaultValue) {
    return this._optionEx(
      { mandatory: true },
      flags,
      description,
      parseArg,
      defaultValue,
    );
  }

  /**
   * Alter parsing of short flags with optional values.
   *
   * @example
   * // for `.option('-f,--flag [value]'):
   * program.combineFlagAndOptionalValue(true);  // `-f80` is treated like `--flag=80`, this is the default behaviour
   * program.combineFlagAndOptionalValue(false) // `-fb` is treated like `-f -b`
   *
   * @param {boolean} [combine] - if `true` or omitted, an optional value can be specified directly after the flag.
   * @return {Command} `this` command for chaining
   */
  combineFlagAndOptionalValue(combine = true) {
    this._combineFlagAndOptionalValue = !!combine;
    return this;
  }

  /**
   * Allow unknown options on the command line.
   *
   * @param {boolean} [allowUnknown] - if `true` or omitted, no error will be thrown for unknown options.
   * @return {Command} `this` command for chaining
   */
  allowUnknownOption(allowUnknown = true) {
    this._allowUnknownOption = !!allowUnknown;
    return this;
  }

  /**
   * Allow excess command-arguments on the command line. Pass false to make excess arguments an error.
   *
   * @param {boolean} [allowExcess] - if `true` or omitted, no error will be thrown for excess arguments.
   * @return {Command} `this` command for chaining
   */
  allowExcessArguments(allowExcess = true) {
    this._allowExcessArguments = !!allowExcess;
    return this;
  }

  /**
   * Enable positional options. Positional means global options are specified before subcommands which lets
   * subcommands reuse the same option names, and also enables subcommands to turn on passThroughOptions.
   * The default behaviour is non-positional and global options may appear anywhere on the command line.
   *
   * @param {boolean} [positional]
   * @return {Command} `this` command for chaining
   */
  enablePositionalOptions(positional = true) {
    this._enablePositionalOptions = !!positional;
    return this;
  }

  /**
   * Pass through options that come after command-arguments rather than treat them as command-options,
   * so actual command-options come before command-arguments. Turning this on for a subcommand requires
   * positional options to have been enabled on the program (parent commands).
   * The default behaviour is non-positional and options may appear before or after command-arguments.
   *
   * @param {boolean} [passThrough] for unknown options.
   * @return {Command} `this` command for chaining
   */
  passThroughOptions(passThrough = true) {
    this._passThroughOptions = !!passThrough;
    this._checkForBrokenPassThrough();
    return this;
  }

  /**
   * @private
   */

  _checkForBrokenPassThrough() {
    if (
      this.parent &&
      this._passThroughOptions &&
      !this.parent._enablePositionalOptions
    ) {
      throw new Error(
        `passThroughOptions cannot be used for '${this._name}' without turning on enablePositionalOptions for parent command(s)`,
      );
    }
  }

  /**
   * Whether to store option values as properties on command object,
   * or store separately (specify false). In both cases the option values can be accessed using .opts().
   *
   * @param {boolean} [storeAsProperties=true]
   * @return {Command} `this` command for chaining
   */

  storeOptionsAsProperties(storeAsProperties = true) {
    if (this.options.length) {
      throw new Error('call .storeOptionsAsProperties() before adding options');
    }
    if (Object.keys(this._optionValues).length) {
      throw new Error(
        'call .storeOptionsAsProperties() before setting option values',
      );
    }
    this._storeOptionsAsProperties = !!storeAsProperties;
    return this;
  }

  /**
   * Retrieve option value.
   *
   * @param {string} key
   * @return {object} value
   */

  getOptionValue(key) {
    if (this._storeOptionsAsProperties) {
      return this[key];
    }
    return this._optionValues[key];
  }

  /**
   * Store option value.
   *
   * @param {string} key
   * @param {object} value
   * @return {Command} `this` command for chaining
   */

  setOptionValue(key, value) {
    return this.setOptionValueWithSource(key, value, undefined);
  }

  /**
   * Store option value and where the value came from.
   *
   * @param {string} key
   * @param {object} value
   * @param {string} source - expected values are default/config/env/cli/implied
   * @return {Command} `this` command for chaining
   */

  setOptionValueWithSource(key, value, source) {
    if (this._storeOptionsAsProperties) {
      this[key] = value;
    } else {
      this._optionValues[key] = value;
    }
    this._optionValueSources[key] = source;
    return this;
  }

  /**
   * Get source of option value.
   * Expected values are default | config | env | cli | implied
   *
   * @param {string} key
   * @return {string}
   */

  getOptionValueSource(key) {
    return this._optionValueSources[key];
  }

  /**
   * Get source of option value. See also .optsWithGlobals().
   * Expected values are default | config | env | cli | implied
   *
   * @param {string} key
   * @return {string}
   */

  getOptionValueSourceWithGlobals(key) {
    // global overwrites local, like optsWithGlobals
    let source;
    this._getCommandAndAncestors().forEach((cmd) => {
      if (cmd.getOptionValueSource(key) !== undefined) {
        source = cmd.getOptionValueSource(key);
      }
    });
    return source;
  }

  /**
   * Get user arguments from implied or explicit arguments.
   * Side-effects: set _scriptPath if args included script. Used for default program name, and subcommand searches.
   *
   * @private
   */

  _prepareUserArgs(argv, parseOptions) {
    if (argv !== undefined && !Array.isArray(argv)) {
      throw new Error('first parameter to parse must be array or undefined');
    }
    parseOptions = parseOptions || {};

    // auto-detect argument conventions if nothing supplied
    if (argv === undefined && parseOptions.from === undefined) {
      if (process$1.versions?.electron) {
        parseOptions.from = 'electron';
      }
      // check node specific options for scenarios where user CLI args follow executable without scriptname
      const execArgv = process$1.execArgv ?? [];
      if (
        execArgv.includes('-e') ||
        execArgv.includes('--eval') ||
        execArgv.includes('-p') ||
        execArgv.includes('--print')
      ) {
        parseOptions.from = 'eval'; // internal usage, not documented
      }
    }

    // default to using process.argv
    if (argv === undefined) {
      argv = process$1.argv;
    }
    this.rawArgs = argv.slice();

    // extract the user args and scriptPath
    let userArgs;
    switch (parseOptions.from) {
      case undefined:
      case 'node':
        this._scriptPath = argv[1];
        userArgs = argv.slice(2);
        break;
      case 'electron':
        // @ts-ignore: because defaultApp is an unknown property
        if (process$1.defaultApp) {
          this._scriptPath = argv[1];
          userArgs = argv.slice(2);
        } else {
          userArgs = argv.slice(1);
        }
        break;
      case 'user':
        userArgs = argv.slice(0);
        break;
      case 'eval':
        userArgs = argv.slice(1);
        break;
      default:
        throw new Error(
          `unexpected parse option { from: '${parseOptions.from}' }`,
        );
    }

    // Find default name for program from arguments.
    if (!this._name && this._scriptPath)
      this.nameFromFilename(this._scriptPath);
    this._name = this._name || 'program';

    return userArgs;
  }

  /**
   * Parse `argv`, setting options and invoking commands when defined.
   *
   * Use parseAsync instead of parse if any of your action handlers are async.
   *
   * Call with no parameters to parse `process.argv`. Detects Electron and special node options like `node --eval`. Easy mode!
   *
   * Or call with an array of strings to parse, and optionally where the user arguments start by specifying where the arguments are `from`:
   * - `'node'`: default, `argv[0]` is the application and `argv[1]` is the script being run, with user arguments after that
   * - `'electron'`: `argv[0]` is the application and `argv[1]` varies depending on whether the electron application is packaged
   * - `'user'`: just user arguments
   *
   * @example
   * program.parse(); // parse process.argv and auto-detect electron and special node flags
   * program.parse(process.argv); // assume argv[0] is app and argv[1] is script
   * program.parse(my-args, { from: 'user' }); // just user supplied arguments, nothing special about argv[0]
   *
   * @param {string[]} [argv] - optional, defaults to process.argv
   * @param {object} [parseOptions] - optionally specify style of options with from: node/user/electron
   * @param {string} [parseOptions.from] - where the args are from: 'node', 'user', 'electron'
   * @return {Command} `this` command for chaining
   */

  parse(argv, parseOptions) {
    const userArgs = this._prepareUserArgs(argv, parseOptions);
    this._parseCommand([], userArgs);

    return this;
  }

  /**
   * Parse `argv`, setting options and invoking commands when defined.
   *
   * Call with no parameters to parse `process.argv`. Detects Electron and special node options like `node --eval`. Easy mode!
   *
   * Or call with an array of strings to parse, and optionally where the user arguments start by specifying where the arguments are `from`:
   * - `'node'`: default, `argv[0]` is the application and `argv[1]` is the script being run, with user arguments after that
   * - `'electron'`: `argv[0]` is the application and `argv[1]` varies depending on whether the electron application is packaged
   * - `'user'`: just user arguments
   *
   * @example
   * await program.parseAsync(); // parse process.argv and auto-detect electron and special node flags
   * await program.parseAsync(process.argv); // assume argv[0] is app and argv[1] is script
   * await program.parseAsync(my-args, { from: 'user' }); // just user supplied arguments, nothing special about argv[0]
   *
   * @param {string[]} [argv]
   * @param {object} [parseOptions]
   * @param {string} parseOptions.from - where the args are from: 'node', 'user', 'electron'
   * @return {Promise}
   */

  async parseAsync(argv, parseOptions) {
    const userArgs = this._prepareUserArgs(argv, parseOptions);
    await this._parseCommand([], userArgs);

    return this;
  }

  /**
   * Execute a sub-command executable.
   *
   * @private
   */

  _executeSubCommand(subcommand, args) {
    args = args.slice();
    let launchWithNode = false; // Use node for source targets so do not need to get permissions correct, and on Windows.
    const sourceExt = ['.js', '.ts', '.tsx', '.mjs', '.cjs'];

    function findFile(baseDir, baseName) {
      // Look for specified file
      const localBin = path$1.resolve(baseDir, baseName);
      if (fs$2.existsSync(localBin)) return localBin;

      // Stop looking if candidate already has an expected extension.
      if (sourceExt.includes(path$1.extname(baseName))) return undefined;

      // Try all the extensions.
      const foundExt = sourceExt.find((ext) =>
        fs$2.existsSync(`${localBin}${ext}`),
      );
      if (foundExt) return `${localBin}${foundExt}`;

      return undefined;
    }

    // Not checking for help first. Unlikely to have mandatory and executable, and can't robustly test for help flags in external command.
    this._checkForMissingMandatoryOptions();
    this._checkForConflictingOptions();

    // executableFile and executableDir might be full path, or just a name
    let executableFile =
      subcommand._executableFile || `${this._name}-${subcommand._name}`;
    let executableDir = this._executableDir || '';
    if (this._scriptPath) {
      let resolvedScriptPath; // resolve possible symlink for installed npm binary
      try {
        resolvedScriptPath = fs$2.realpathSync(this._scriptPath);
      } catch (err) {
        resolvedScriptPath = this._scriptPath;
      }
      executableDir = path$1.resolve(
        path$1.dirname(resolvedScriptPath),
        executableDir,
      );
    }

    // Look for a local file in preference to a command in PATH.
    if (executableDir) {
      let localFile = findFile(executableDir, executableFile);

      // Legacy search using prefix of script name instead of command name
      if (!localFile && !subcommand._executableFile && this._scriptPath) {
        const legacyName = path$1.basename(
          this._scriptPath,
          path$1.extname(this._scriptPath),
        );
        if (legacyName !== this._name) {
          localFile = findFile(
            executableDir,
            `${legacyName}-${subcommand._name}`,
          );
        }
      }
      executableFile = localFile || executableFile;
    }

    launchWithNode = sourceExt.includes(path$1.extname(executableFile));

    let proc;
    if (process$1.platform !== 'win32') {
      if (launchWithNode) {
        args.unshift(executableFile);
        // add executable arguments to spawn
        args = incrementNodeInspectorPort(process$1.execArgv).concat(args);

        proc = childProcess.spawn(process$1.argv[0], args, { stdio: 'inherit' });
      } else {
        proc = childProcess.spawn(executableFile, args, { stdio: 'inherit' });
      }
    } else {
      args.unshift(executableFile);
      // add executable arguments to spawn
      args = incrementNodeInspectorPort(process$1.execArgv).concat(args);
      proc = childProcess.spawn(process$1.execPath, args, { stdio: 'inherit' });
    }

    if (!proc.killed) {
      // testing mainly to avoid leak warnings during unit tests with mocked spawn
      const signals = ['SIGUSR1', 'SIGUSR2', 'SIGTERM', 'SIGINT', 'SIGHUP'];
      signals.forEach((signal) => {
        process$1.on(signal, () => {
          if (proc.killed === false && proc.exitCode === null) {
            // @ts-ignore because signals not typed to known strings
            proc.kill(signal);
          }
        });
      });
    }

    // By default terminate process when spawned process terminates.
    const exitCallback = this._exitCallback;
    proc.on('close', (code) => {
      code = code ?? 1; // code is null if spawned process terminated due to a signal
      if (!exitCallback) {
        process$1.exit(code);
      } else {
        exitCallback(
          new CommanderError$2(
            code,
            'commander.executeSubCommandAsync',
            '(close)',
          ),
        );
      }
    });
    proc.on('error', (err) => {
      // @ts-ignore: because err.code is an unknown property
      if (err.code === 'ENOENT') {
        const executableDirMessage = executableDir
          ? `searched for local subcommand relative to directory '${executableDir}'`
          : 'no directory for search for local subcommand, use .executableDir() to supply a custom directory';
        const executableMissing = `'${executableFile}' does not exist
 - if '${subcommand._name}' is not meant to be an executable command, remove description parameter from '.command()' and use '.description()' instead
 - if the default executable name is not suitable, use the executableFile option to supply a custom name or path
 - ${executableDirMessage}`;
        throw new Error(executableMissing);
        // @ts-ignore: because err.code is an unknown property
      } else if (err.code === 'EACCES') {
        throw new Error(`'${executableFile}' not executable`);
      }
      if (!exitCallback) {
        process$1.exit(1);
      } else {
        const wrappedError = new CommanderError$2(
          1,
          'commander.executeSubCommandAsync',
          '(error)',
        );
        wrappedError.nestedError = err;
        exitCallback(wrappedError);
      }
    });

    // Store the reference to the child process
    this.runningCommand = proc;
  }

  /**
   * @private
   */

  _dispatchSubcommand(commandName, operands, unknown) {
    const subCommand = this._findCommand(commandName);
    if (!subCommand) this.help({ error: true });

    let promiseChain;
    promiseChain = this._chainOrCallSubCommandHook(
      promiseChain,
      subCommand,
      'preSubcommand',
    );
    promiseChain = this._chainOrCall(promiseChain, () => {
      if (subCommand._executableHandler) {
        this._executeSubCommand(subCommand, operands.concat(unknown));
      } else {
        return subCommand._parseCommand(operands, unknown);
      }
    });
    return promiseChain;
  }

  /**
   * Invoke help directly if possible, or dispatch if necessary.
   * e.g. help foo
   *
   * @private
   */

  _dispatchHelpCommand(subcommandName) {
    if (!subcommandName) {
      this.help();
    }
    const subCommand = this._findCommand(subcommandName);
    if (subCommand && !subCommand._executableHandler) {
      subCommand.help();
    }

    // Fallback to parsing the help flag to invoke the help.
    return this._dispatchSubcommand(
      subcommandName,
      [],
      [this._getHelpOption()?.long ?? this._getHelpOption()?.short ?? '--help'],
    );
  }

  /**
   * Check this.args against expected this.registeredArguments.
   *
   * @private
   */

  _checkNumberOfArguments() {
    // too few
    this.registeredArguments.forEach((arg, i) => {
      if (arg.required && this.args[i] == null) {
        this.missingArgument(arg.name());
      }
    });
    // too many
    if (
      this.registeredArguments.length > 0 &&
      this.registeredArguments[this.registeredArguments.length - 1].variadic
    ) {
      return;
    }
    if (this.args.length > this.registeredArguments.length) {
      this._excessArguments(this.args);
    }
  }

  /**
   * Process this.args using this.registeredArguments and save as this.processedArgs!
   *
   * @private
   */

  _processArguments() {
    const myParseArg = (argument, value, previous) => {
      // Extra processing for nice error message on parsing failure.
      let parsedValue = value;
      if (value !== null && argument.parseArg) {
        const invalidValueMessage = `error: command-argument value '${value}' is invalid for argument '${argument.name()}'.`;
        parsedValue = this._callParseArg(
          argument,
          value,
          previous,
          invalidValueMessage,
        );
      }
      return parsedValue;
    };

    this._checkNumberOfArguments();

    const processedArgs = [];
    this.registeredArguments.forEach((declaredArg, index) => {
      let value = declaredArg.defaultValue;
      if (declaredArg.variadic) {
        // Collect together remaining arguments for passing together as an array.
        if (index < this.args.length) {
          value = this.args.slice(index);
          if (declaredArg.parseArg) {
            value = value.reduce((processed, v) => {
              return myParseArg(declaredArg, v, processed);
            }, declaredArg.defaultValue);
          }
        } else if (value === undefined) {
          value = [];
        }
      } else if (index < this.args.length) {
        value = this.args[index];
        if (declaredArg.parseArg) {
          value = myParseArg(declaredArg, value, declaredArg.defaultValue);
        }
      }
      processedArgs[index] = value;
    });
    this.processedArgs = processedArgs;
  }

  /**
   * Once we have a promise we chain, but call synchronously until then.
   *
   * @param {(Promise|undefined)} promise
   * @param {Function} fn
   * @return {(Promise|undefined)}
   * @private
   */

  _chainOrCall(promise, fn) {
    // thenable
    if (promise && promise.then && typeof promise.then === 'function') {
      // already have a promise, chain callback
      return promise.then(() => fn());
    }
    // callback might return a promise
    return fn();
  }

  /**
   *
   * @param {(Promise|undefined)} promise
   * @param {string} event
   * @return {(Promise|undefined)}
   * @private
   */

  _chainOrCallHooks(promise, event) {
    let result = promise;
    const hooks = [];
    this._getCommandAndAncestors()
      .reverse()
      .filter((cmd) => cmd._lifeCycleHooks[event] !== undefined)
      .forEach((hookedCommand) => {
        hookedCommand._lifeCycleHooks[event].forEach((callback) => {
          hooks.push({ hookedCommand, callback });
        });
      });
    if (event === 'postAction') {
      hooks.reverse();
    }

    hooks.forEach((hookDetail) => {
      result = this._chainOrCall(result, () => {
        return hookDetail.callback(hookDetail.hookedCommand, this);
      });
    });
    return result;
  }

  /**
   *
   * @param {(Promise|undefined)} promise
   * @param {Command} subCommand
   * @param {string} event
   * @return {(Promise|undefined)}
   * @private
   */

  _chainOrCallSubCommandHook(promise, subCommand, event) {
    let result = promise;
    if (this._lifeCycleHooks[event] !== undefined) {
      this._lifeCycleHooks[event].forEach((hook) => {
        result = this._chainOrCall(result, () => {
          return hook(this, subCommand);
        });
      });
    }
    return result;
  }

  /**
   * Process arguments in context of this command.
   * Returns action result, in case it is a promise.
   *
   * @private
   */

  _parseCommand(operands, unknown) {
    const parsed = this.parseOptions(unknown);
    this._parseOptionsEnv(); // after cli, so parseArg not called on both cli and env
    this._parseOptionsImplied();
    operands = operands.concat(parsed.operands);
    unknown = parsed.unknown;
    this.args = operands.concat(unknown);

    if (operands && this._findCommand(operands[0])) {
      return this._dispatchSubcommand(operands[0], operands.slice(1), unknown);
    }
    if (
      this._getHelpCommand() &&
      operands[0] === this._getHelpCommand().name()
    ) {
      return this._dispatchHelpCommand(operands[1]);
    }
    if (this._defaultCommandName) {
      this._outputHelpIfRequested(unknown); // Run the help for default command from parent rather than passing to default command
      return this._dispatchSubcommand(
        this._defaultCommandName,
        operands,
        unknown,
      );
    }
    if (
      this.commands.length &&
      this.args.length === 0 &&
      !this._actionHandler &&
      !this._defaultCommandName
    ) {
      // probably missing subcommand and no handler, user needs help (and exit)
      this.help({ error: true });
    }

    this._outputHelpIfRequested(parsed.unknown);
    this._checkForMissingMandatoryOptions();
    this._checkForConflictingOptions();

    // We do not always call this check to avoid masking a "better" error, like unknown command.
    const checkForUnknownOptions = () => {
      if (parsed.unknown.length > 0) {
        this.unknownOption(parsed.unknown[0]);
      }
    };

    const commandEvent = `command:${this.name()}`;
    if (this._actionHandler) {
      checkForUnknownOptions();
      this._processArguments();

      let promiseChain;
      promiseChain = this._chainOrCallHooks(promiseChain, 'preAction');
      promiseChain = this._chainOrCall(promiseChain, () =>
        this._actionHandler(this.processedArgs),
      );
      if (this.parent) {
        promiseChain = this._chainOrCall(promiseChain, () => {
          this.parent.emit(commandEvent, operands, unknown); // legacy
        });
      }
      promiseChain = this._chainOrCallHooks(promiseChain, 'postAction');
      return promiseChain;
    }
    if (this.parent && this.parent.listenerCount(commandEvent)) {
      checkForUnknownOptions();
      this._processArguments();
      this.parent.emit(commandEvent, operands, unknown); // legacy
    } else if (operands.length) {
      if (this._findCommand('*')) {
        // legacy default command
        return this._dispatchSubcommand('*', operands, unknown);
      }
      if (this.listenerCount('command:*')) {
        // skip option check, emit event for possible misspelling suggestion
        this.emit('command:*', operands, unknown);
      } else if (this.commands.length) {
        this.unknownCommand();
      } else {
        checkForUnknownOptions();
        this._processArguments();
      }
    } else if (this.commands.length) {
      checkForUnknownOptions();
      // This command has subcommands and nothing hooked up at this level, so display help (and exit).
      this.help({ error: true });
    } else {
      checkForUnknownOptions();
      this._processArguments();
      // fall through for caller to handle after calling .parse()
    }
  }

  /**
   * Find matching command.
   *
   * @private
   * @return {Command | undefined}
   */
  _findCommand(name) {
    if (!name) return undefined;
    return this.commands.find(
      (cmd) => cmd._name === name || cmd._aliases.includes(name),
    );
  }

  /**
   * Return an option matching `arg` if any.
   *
   * @param {string} arg
   * @return {Option}
   * @package
   */

  _findOption(arg) {
    return this.options.find((option) => option.is(arg));
  }

  /**
   * Display an error message if a mandatory option does not have a value.
   * Called after checking for help flags in leaf subcommand.
   *
   * @private
   */

  _checkForMissingMandatoryOptions() {
    // Walk up hierarchy so can call in subcommand after checking for displaying help.
    this._getCommandAndAncestors().forEach((cmd) => {
      cmd.options.forEach((anOption) => {
        if (
          anOption.mandatory &&
          cmd.getOptionValue(anOption.attributeName()) === undefined
        ) {
          cmd.missingMandatoryOptionValue(anOption);
        }
      });
    });
  }

  /**
   * Display an error message if conflicting options are used together in this.
   *
   * @private
   */
  _checkForConflictingLocalOptions() {
    const definedNonDefaultOptions = this.options.filter((option) => {
      const optionKey = option.attributeName();
      if (this.getOptionValue(optionKey) === undefined) {
        return false;
      }
      return this.getOptionValueSource(optionKey) !== 'default';
    });

    const optionsWithConflicting = definedNonDefaultOptions.filter(
      (option) => option.conflictsWith.length > 0,
    );

    optionsWithConflicting.forEach((option) => {
      const conflictingAndDefined = definedNonDefaultOptions.find((defined) =>
        option.conflictsWith.includes(defined.attributeName()),
      );
      if (conflictingAndDefined) {
        this._conflictingOption(option, conflictingAndDefined);
      }
    });
  }

  /**
   * Display an error message if conflicting options are used together.
   * Called after checking for help flags in leaf subcommand.
   *
   * @private
   */
  _checkForConflictingOptions() {
    // Walk up hierarchy so can call in subcommand after checking for displaying help.
    this._getCommandAndAncestors().forEach((cmd) => {
      cmd._checkForConflictingLocalOptions();
    });
  }

  /**
   * Parse options from `argv` removing known options,
   * and return argv split into operands and unknown arguments.
   *
   * Examples:
   *
   *     argv => operands, unknown
   *     --known kkk op => [op], []
   *     op --known kkk => [op], []
   *     sub --unknown uuu op => [sub], [--unknown uuu op]
   *     sub -- --unknown uuu op => [sub --unknown uuu op], []
   *
   * @param {string[]} argv
   * @return {{operands: string[], unknown: string[]}}
   */

  parseOptions(argv) {
    const operands = []; // operands, not options or values
    const unknown = []; // first unknown option and remaining unknown args
    let dest = operands;
    const args = argv.slice();

    function maybeOption(arg) {
      return arg.length > 1 && arg[0] === '-';
    }

    // parse options
    let activeVariadicOption = null;
    while (args.length) {
      const arg = args.shift();

      // literal
      if (arg === '--') {
        if (dest === unknown) dest.push(arg);
        dest.push(...args);
        break;
      }

      if (activeVariadicOption && !maybeOption(arg)) {
        this.emit(`option:${activeVariadicOption.name()}`, arg);
        continue;
      }
      activeVariadicOption = null;

      if (maybeOption(arg)) {
        const option = this._findOption(arg);
        // recognised option, call listener to assign value with possible custom processing
        if (option) {
          if (option.required) {
            const value = args.shift();
            if (value === undefined) this.optionMissingArgument(option);
            this.emit(`option:${option.name()}`, value);
          } else if (option.optional) {
            let value = null;
            // historical behaviour is optional value is following arg unless an option
            if (args.length > 0 && !maybeOption(args[0])) {
              value = args.shift();
            }
            this.emit(`option:${option.name()}`, value);
          } else {
            // boolean flag
            this.emit(`option:${option.name()}`);
          }
          activeVariadicOption = option.variadic ? option : null;
          continue;
        }
      }

      // Look for combo options following single dash, eat first one if known.
      if (arg.length > 2 && arg[0] === '-' && arg[1] !== '-') {
        const option = this._findOption(`-${arg[1]}`);
        if (option) {
          if (
            option.required ||
            (option.optional && this._combineFlagAndOptionalValue)
          ) {
            // option with value following in same argument
            this.emit(`option:${option.name()}`, arg.slice(2));
          } else {
            // boolean option, emit and put back remainder of arg for further processing
            this.emit(`option:${option.name()}`);
            args.unshift(`-${arg.slice(2)}`);
          }
          continue;
        }
      }

      // Look for known long flag with value, like --foo=bar
      if (/^--[^=]+=/.test(arg)) {
        const index = arg.indexOf('=');
        const option = this._findOption(arg.slice(0, index));
        if (option && (option.required || option.optional)) {
          this.emit(`option:${option.name()}`, arg.slice(index + 1));
          continue;
        }
      }

      // Not a recognised option by this command.
      // Might be a command-argument, or subcommand option, or unknown option, or help command or option.

      // An unknown option means further arguments also classified as unknown so can be reprocessed by subcommands.
      if (maybeOption(arg)) {
        dest = unknown;
      }

      // If using positionalOptions, stop processing our options at subcommand.
      if (
        (this._enablePositionalOptions || this._passThroughOptions) &&
        operands.length === 0 &&
        unknown.length === 0
      ) {
        if (this._findCommand(arg)) {
          operands.push(arg);
          if (args.length > 0) unknown.push(...args);
          break;
        } else if (
          this._getHelpCommand() &&
          arg === this._getHelpCommand().name()
        ) {
          operands.push(arg);
          if (args.length > 0) operands.push(...args);
          break;
        } else if (this._defaultCommandName) {
          unknown.push(arg);
          if (args.length > 0) unknown.push(...args);
          break;
        }
      }

      // If using passThroughOptions, stop processing options at first command-argument.
      if (this._passThroughOptions) {
        dest.push(arg);
        if (args.length > 0) dest.push(...args);
        break;
      }

      // add arg
      dest.push(arg);
    }

    return { operands, unknown };
  }

  /**
   * Return an object containing local option values as key-value pairs.
   *
   * @return {object}
   */
  opts() {
    if (this._storeOptionsAsProperties) {
      // Preserve original behaviour so backwards compatible when still using properties
      const result = {};
      const len = this.options.length;

      for (let i = 0; i < len; i++) {
        const key = this.options[i].attributeName();
        result[key] =
          key === this._versionOptionName ? this._version : this[key];
      }
      return result;
    }

    return this._optionValues;
  }

  /**
   * Return an object containing merged local and global option values as key-value pairs.
   *
   * @return {object}
   */
  optsWithGlobals() {
    // globals overwrite locals
    return this._getCommandAndAncestors().reduce(
      (combinedOptions, cmd) => Object.assign(combinedOptions, cmd.opts()),
      {},
    );
  }

  /**
   * Display error message and exit (or call exitOverride).
   *
   * @param {string} message
   * @param {object} [errorOptions]
   * @param {string} [errorOptions.code] - an id string representing the error
   * @param {number} [errorOptions.exitCode] - used with process.exit
   */
  error(message, errorOptions) {
    // output handling
    this._outputConfiguration.outputError(
      `${message}\n`,
      this._outputConfiguration.writeErr,
    );
    if (typeof this._showHelpAfterError === 'string') {
      this._outputConfiguration.writeErr(`${this._showHelpAfterError}\n`);
    } else if (this._showHelpAfterError) {
      this._outputConfiguration.writeErr('\n');
      this.outputHelp({ error: true });
    }

    // exit handling
    const config = errorOptions || {};
    const exitCode = config.exitCode || 1;
    const code = config.code || 'commander.error';
    this._exit(exitCode, code, message);
  }

  /**
   * Apply any option related environment variables, if option does
   * not have a value from cli or client code.
   *
   * @private
   */
  _parseOptionsEnv() {
    this.options.forEach((option) => {
      if (option.envVar && option.envVar in process$1.env) {
        const optionKey = option.attributeName();
        // Priority check. Do not overwrite cli or options from unknown source (client-code).
        if (
          this.getOptionValue(optionKey) === undefined ||
          ['default', 'config', 'env'].includes(
            this.getOptionValueSource(optionKey),
          )
        ) {
          if (option.required || option.optional) {
            // option can take a value
            // keep very simple, optional always takes value
            this.emit(`optionEnv:${option.name()}`, process$1.env[option.envVar]);
          } else {
            // boolean
            // keep very simple, only care that envVar defined and not the value
            this.emit(`optionEnv:${option.name()}`);
          }
        }
      }
    });
  }

  /**
   * Apply any implied option values, if option is undefined or default value.
   *
   * @private
   */
  _parseOptionsImplied() {
    const dualHelper = new DualOptions(this.options);
    const hasCustomOptionValue = (optionKey) => {
      return (
        this.getOptionValue(optionKey) !== undefined &&
        !['default', 'implied'].includes(this.getOptionValueSource(optionKey))
      );
    };
    this.options
      .filter(
        (option) =>
          option.implied !== undefined &&
          hasCustomOptionValue(option.attributeName()) &&
          dualHelper.valueFromOption(
            this.getOptionValue(option.attributeName()),
            option,
          ),
      )
      .forEach((option) => {
        Object.keys(option.implied)
          .filter((impliedKey) => !hasCustomOptionValue(impliedKey))
          .forEach((impliedKey) => {
            this.setOptionValueWithSource(
              impliedKey,
              option.implied[impliedKey],
              'implied',
            );
          });
      });
  }

  /**
   * Argument `name` is missing.
   *
   * @param {string} name
   * @private
   */

  missingArgument(name) {
    const message = `error: missing required argument '${name}'`;
    this.error(message, { code: 'commander.missingArgument' });
  }

  /**
   * `Option` is missing an argument.
   *
   * @param {Option} option
   * @private
   */

  optionMissingArgument(option) {
    const message = `error: option '${option.flags}' argument missing`;
    this.error(message, { code: 'commander.optionMissingArgument' });
  }

  /**
   * `Option` does not have a value, and is a mandatory option.
   *
   * @param {Option} option
   * @private
   */

  missingMandatoryOptionValue(option) {
    const message = `error: required option '${option.flags}' not specified`;
    this.error(message, { code: 'commander.missingMandatoryOptionValue' });
  }

  /**
   * `Option` conflicts with another option.
   *
   * @param {Option} option
   * @param {Option} conflictingOption
   * @private
   */
  _conflictingOption(option, conflictingOption) {
    // The calling code does not know whether a negated option is the source of the
    // value, so do some work to take an educated guess.
    const findBestOptionFromValue = (option) => {
      const optionKey = option.attributeName();
      const optionValue = this.getOptionValue(optionKey);
      const negativeOption = this.options.find(
        (target) => target.negate && optionKey === target.attributeName(),
      );
      const positiveOption = this.options.find(
        (target) => !target.negate && optionKey === target.attributeName(),
      );
      if (
        negativeOption &&
        ((negativeOption.presetArg === undefined && optionValue === false) ||
          (negativeOption.presetArg !== undefined &&
            optionValue === negativeOption.presetArg))
      ) {
        return negativeOption;
      }
      return positiveOption || option;
    };

    const getErrorMessage = (option) => {
      const bestOption = findBestOptionFromValue(option);
      const optionKey = bestOption.attributeName();
      const source = this.getOptionValueSource(optionKey);
      if (source === 'env') {
        return `environment variable '${bestOption.envVar}'`;
      }
      return `option '${bestOption.flags}'`;
    };

    const message = `error: ${getErrorMessage(option)} cannot be used with ${getErrorMessage(conflictingOption)}`;
    this.error(message, { code: 'commander.conflictingOption' });
  }

  /**
   * Unknown option `flag`.
   *
   * @param {string} flag
   * @private
   */

  unknownOption(flag) {
    if (this._allowUnknownOption) return;
    let suggestion = '';

    if (flag.startsWith('--') && this._showSuggestionAfterError) {
      // Looping to pick up the global options too
      let candidateFlags = [];
      // eslint-disable-next-line @typescript-eslint/no-this-alias
      let command = this;
      do {
        const moreFlags = command
          .createHelp()
          .visibleOptions(command)
          .filter((option) => option.long)
          .map((option) => option.long);
        candidateFlags = candidateFlags.concat(moreFlags);
        command = command.parent;
      } while (command && !command._enablePositionalOptions);
      suggestion = suggestSimilar(flag, candidateFlags);
    }

    const message = `error: unknown option '${flag}'${suggestion}`;
    this.error(message, { code: 'commander.unknownOption' });
  }

  /**
   * Excess arguments, more than expected.
   *
   * @param {string[]} receivedArgs
   * @private
   */

  _excessArguments(receivedArgs) {
    if (this._allowExcessArguments) return;

    const expected = this.registeredArguments.length;
    const s = expected === 1 ? '' : 's';
    const forSubcommand = this.parent ? ` for '${this.name()}'` : '';
    const message = `error: too many arguments${forSubcommand}. Expected ${expected} argument${s} but got ${receivedArgs.length}.`;
    this.error(message, { code: 'commander.excessArguments' });
  }

  /**
   * Unknown command.
   *
   * @private
   */

  unknownCommand() {
    const unknownName = this.args[0];
    let suggestion = '';

    if (this._showSuggestionAfterError) {
      const candidateNames = [];
      this.createHelp()
        .visibleCommands(this)
        .forEach((command) => {
          candidateNames.push(command.name());
          // just visible alias
          if (command.alias()) candidateNames.push(command.alias());
        });
      suggestion = suggestSimilar(unknownName, candidateNames);
    }

    const message = `error: unknown command '${unknownName}'${suggestion}`;
    this.error(message, { code: 'commander.unknownCommand' });
  }

  /**
   * Get or set the program version.
   *
   * This method auto-registers the "-V, --version" option which will print the version number.
   *
   * You can optionally supply the flags and description to override the defaults.
   *
   * @param {string} [str]
   * @param {string} [flags]
   * @param {string} [description]
   * @return {(this | string | undefined)} `this` command for chaining, or version string if no arguments
   */

  version(str, flags, description) {
    if (str === undefined) return this._version;
    this._version = str;
    flags = flags || '-V, --version';
    description = description || 'output the version number';
    const versionOption = this.createOption(flags, description);
    this._versionOptionName = versionOption.attributeName();
    this._registerOption(versionOption);

    this.on('option:' + versionOption.name(), () => {
      this._outputConfiguration.writeOut(`${str}\n`);
      this._exit(0, 'commander.version', str);
    });
    return this;
  }

  /**
   * Set the description.
   *
   * @param {string} [str]
   * @param {object} [argsDescription]
   * @return {(string|Command)}
   */
  description(str, argsDescription) {
    if (str === undefined && argsDescription === undefined)
      return this._description;
    this._description = str;
    if (argsDescription) {
      this._argsDescription = argsDescription;
    }
    return this;
  }

  /**
   * Set the summary. Used when listed as subcommand of parent.
   *
   * @param {string} [str]
   * @return {(string|Command)}
   */
  summary(str) {
    if (str === undefined) return this._summary;
    this._summary = str;
    return this;
  }

  /**
   * Set an alias for the command.
   *
   * You may call more than once to add multiple aliases. Only the first alias is shown in the auto-generated help.
   *
   * @param {string} [alias]
   * @return {(string|Command)}
   */

  alias(alias) {
    if (alias === undefined) return this._aliases[0]; // just return first, for backwards compatibility

    /** @type {Command} */
    // eslint-disable-next-line @typescript-eslint/no-this-alias
    let command = this;
    if (
      this.commands.length !== 0 &&
      this.commands[this.commands.length - 1]._executableHandler
    ) {
      // assume adding alias for last added executable subcommand, rather than this
      command = this.commands[this.commands.length - 1];
    }

    if (alias === command._name)
      throw new Error("Command alias can't be the same as its name");
    const matchingCommand = this.parent?._findCommand(alias);
    if (matchingCommand) {
      // c.f. _registerCommand
      const existingCmd = [matchingCommand.name()]
        .concat(matchingCommand.aliases())
        .join('|');
      throw new Error(
        `cannot add alias '${alias}' to command '${this.name()}' as already have command '${existingCmd}'`,
      );
    }

    command._aliases.push(alias);
    return this;
  }

  /**
   * Set aliases for the command.
   *
   * Only the first alias is shown in the auto-generated help.
   *
   * @param {string[]} [aliases]
   * @return {(string[]|Command)}
   */

  aliases(aliases) {
    // Getter for the array of aliases is the main reason for having aliases() in addition to alias().
    if (aliases === undefined) return this._aliases;

    aliases.forEach((alias) => this.alias(alias));
    return this;
  }

  /**
   * Set / get the command usage `str`.
   *
   * @param {string} [str]
   * @return {(string|Command)}
   */

  usage(str) {
    if (str === undefined) {
      if (this._usage) return this._usage;

      const args = this.registeredArguments.map((arg) => {
        return humanReadableArgName(arg);
      });
      return []
        .concat(
          this.options.length || this._helpOption !== null ? '[options]' : [],
          this.commands.length ? '[command]' : [],
          this.registeredArguments.length ? args : [],
        )
        .join(' ');
    }

    this._usage = str;
    return this;
  }

  /**
   * Get or set the name of the command.
   *
   * @param {string} [str]
   * @return {(string|Command)}
   */

  name(str) {
    if (str === undefined) return this._name;
    this._name = str;
    return this;
  }

  /**
   * Set the name of the command from script filename, such as process.argv[1],
   * or require.main.filename, or __filename.
   *
   * (Used internally and public although not documented in README.)
   *
   * @example
   * program.nameFromFilename(require.main.filename);
   *
   * @param {string} filename
   * @return {Command}
   */

  nameFromFilename(filename) {
    this._name = path$1.basename(filename, path$1.extname(filename));

    return this;
  }

  /**
   * Get or set the directory for searching for executable subcommands of this command.
   *
   * @example
   * program.executableDir(__dirname);
   * // or
   * program.executableDir('subcommands');
   *
   * @param {string} [path]
   * @return {(string|null|Command)}
   */

  executableDir(path) {
    if (path === undefined) return this._executableDir;
    this._executableDir = path;
    return this;
  }

  /**
   * Return program help documentation.
   *
   * @param {{ error: boolean }} [contextOptions] - pass {error:true} to wrap for stderr instead of stdout
   * @return {string}
   */

  helpInformation(contextOptions) {
    const helper = this.createHelp();
    if (helper.helpWidth === undefined) {
      helper.helpWidth =
        contextOptions && contextOptions.error
          ? this._outputConfiguration.getErrHelpWidth()
          : this._outputConfiguration.getOutHelpWidth();
    }
    return helper.formatHelp(this, helper);
  }

  /**
   * @private
   */

  _getHelpContext(contextOptions) {
    contextOptions = contextOptions || {};
    const context = { error: !!contextOptions.error };
    let write;
    if (context.error) {
      write = (arg) => this._outputConfiguration.writeErr(arg);
    } else {
      write = (arg) => this._outputConfiguration.writeOut(arg);
    }
    context.write = contextOptions.write || write;
    context.command = this;
    return context;
  }

  /**
   * Output help information for this command.
   *
   * Outputs built-in help, and custom text added using `.addHelpText()`.
   *
   * @param {{ error: boolean } | Function} [contextOptions] - pass {error:true} to write to stderr instead of stdout
   */

  outputHelp(contextOptions) {
    let deprecatedCallback;
    if (typeof contextOptions === 'function') {
      deprecatedCallback = contextOptions;
      contextOptions = undefined;
    }
    const context = this._getHelpContext(contextOptions);

    this._getCommandAndAncestors()
      .reverse()
      .forEach((command) => command.emit('beforeAllHelp', context));
    this.emit('beforeHelp', context);

    let helpInformation = this.helpInformation(context);
    if (deprecatedCallback) {
      helpInformation = deprecatedCallback(helpInformation);
      if (
        typeof helpInformation !== 'string' &&
        !Buffer.isBuffer(helpInformation)
      ) {
        throw new Error('outputHelp callback must return a string or a Buffer');
      }
    }
    context.write(helpInformation);

    if (this._getHelpOption()?.long) {
      this.emit(this._getHelpOption().long); // deprecated
    }
    this.emit('afterHelp', context);
    this._getCommandAndAncestors().forEach((command) =>
      command.emit('afterAllHelp', context),
    );
  }

  /**
   * You can pass in flags and a description to customise the built-in help option.
   * Pass in false to disable the built-in help option.
   *
   * @example
   * program.helpOption('-?, --help' 'show help'); // customise
   * program.helpOption(false); // disable
   *
   * @param {(string | boolean)} flags
   * @param {string} [description]
   * @return {Command} `this` command for chaining
   */

  helpOption(flags, description) {
    // Support disabling built-in help option.
    if (typeof flags === 'boolean') {
      if (flags) {
        this._helpOption = this._helpOption ?? undefined; // preserve existing option
      } else {
        this._helpOption = null; // disable
      }
      return this;
    }

    // Customise flags and description.
    flags = flags ?? '-h, --help';
    description = description ?? 'display help for command';
    this._helpOption = this.createOption(flags, description);

    return this;
  }

  /**
   * Lazy create help option.
   * Returns null if has been disabled with .helpOption(false).
   *
   * @returns {(Option | null)} the help option
   * @package
   */
  _getHelpOption() {
    // Lazy create help option on demand.
    if (this._helpOption === undefined) {
      this.helpOption(undefined, undefined);
    }
    return this._helpOption;
  }

  /**
   * Supply your own option to use for the built-in help option.
   * This is an alternative to using helpOption() to customise the flags and description etc.
   *
   * @param {Option} option
   * @return {Command} `this` command for chaining
   */
  addHelpOption(option) {
    this._helpOption = option;
    return this;
  }

  /**
   * Output help information and exit.
   *
   * Outputs built-in help, and custom text added using `.addHelpText()`.
   *
   * @param {{ error: boolean }} [contextOptions] - pass {error:true} to write to stderr instead of stdout
   */

  help(contextOptions) {
    this.outputHelp(contextOptions);
    let exitCode = process$1.exitCode || 0;
    if (
      exitCode === 0 &&
      contextOptions &&
      typeof contextOptions !== 'function' &&
      contextOptions.error
    ) {
      exitCode = 1;
    }
    // message: do not have all displayed text available so only passing placeholder.
    this._exit(exitCode, 'commander.help', '(outputHelp)');
  }

  /**
   * Add additional text to be displayed with the built-in help.
   *
   * Position is 'before' or 'after' to affect just this command,
   * and 'beforeAll' or 'afterAll' to affect this command and all its subcommands.
   *
   * @param {string} position - before or after built-in help
   * @param {(string | Function)} text - string to add, or a function returning a string
   * @return {Command} `this` command for chaining
   */
  addHelpText(position, text) {
    const allowedValues = ['beforeAll', 'before', 'after', 'afterAll'];
    if (!allowedValues.includes(position)) {
      throw new Error(`Unexpected value for position to addHelpText.
Expecting one of '${allowedValues.join("', '")}'`);
    }
    const helpEvent = `${position}Help`;
    this.on(helpEvent, (context) => {
      let helpStr;
      if (typeof text === 'function') {
        helpStr = text({ error: context.error, command: context.command });
      } else {
        helpStr = text;
      }
      // Ignore falsy value when nothing to output.
      if (helpStr) {
        context.write(`${helpStr}\n`);
      }
    });
    return this;
  }

  /**
   * Output help information if help flags specified
   *
   * @param {Array} args - array of options to search for help flags
   * @private
   */

  _outputHelpIfRequested(args) {
    const helpOption = this._getHelpOption();
    const helpRequested = helpOption && args.find((arg) => helpOption.is(arg));
    if (helpRequested) {
      this.outputHelp();
      // (Do not have all displayed text available so only passing placeholder.)
      this._exit(0, 'commander.helpDisplayed', '(outputHelp)');
    }
  }
};

/**
 * Scan arguments and increment port number for inspect calls (to avoid conflicts when spawning new command).
 *
 * @param {string[]} args - array of arguments from node.execArgv
 * @returns {string[]}
 * @private
 */

function incrementNodeInspectorPort(args) {
  // Testing for these options:
  //  --inspect[=[host:]port]
  //  --inspect-brk[=[host:]port]
  //  --inspect-port=[host:]port
  return args.map((arg) => {
    if (!arg.startsWith('--inspect')) {
      return arg;
    }
    let debugOption;
    let debugHost = '127.0.0.1';
    let debugPort = '9229';
    let match;
    if ((match = arg.match(/^(--inspect(-brk)?)$/)) !== null) {
      // e.g. --inspect
      debugOption = match[1];
    } else if (
      (match = arg.match(/^(--inspect(-brk|-port)?)=([^:]+)$/)) !== null
    ) {
      debugOption = match[1];
      if (/^\d+$/.test(match[3])) {
        // e.g. --inspect=1234
        debugPort = match[3];
      } else {
        // e.g. --inspect=localhost
        debugHost = match[3];
      }
    } else if (
      (match = arg.match(/^(--inspect(-brk|-port)?)=([^:]+):(\d+)$/)) !== null
    ) {
      // e.g. --inspect=localhost:1234
      debugOption = match[1];
      debugHost = match[3];
      debugPort = match[4];
    }

    if (debugOption && debugPort !== '0') {
      return `${debugOption}=${debugHost}:${parseInt(debugPort) + 1}`;
    }
    return arg;
  });
}

command.Command = Command$2;

const { Argument: Argument$1 } = argument;
const { Command: Command$1 } = command;
const { CommanderError: CommanderError$1, InvalidArgumentError: InvalidArgumentError$1 } = error;
const { Help: Help$1 } = help;
const { Option: Option$1 } = option;

commander.program = new Command$1();

commander.createCommand = (name) => new Command$1(name);
commander.createOption = (flags, description) => new Option$1(flags, description);
commander.createArgument = (name, description) => new Argument$1(name, description);

/**
 * Expose classes
 */

commander.Command = Command$1;
commander.Option = Option$1;
commander.Argument = Argument$1;
commander.Help = Help$1;

commander.CommanderError = CommanderError$1;
commander.InvalidArgumentError = InvalidArgumentError$1;
commander.InvalidOptionArgumentError = InvalidArgumentError$1; // Deprecated

// wrapper to provide named exports for ESM.
const {
  program,
  createCommand,
  createArgument,
  createOption,
  CommanderError,
  InvalidArgumentError,
  InvalidOptionArgumentError, // deprecated old name
  Command,
  Argument,
  Option,
  Help,
} = commander;

// src/actions/await/awaitAsync.ts

// src/storages/globalConfig/globalConfig.ts
var store;
function getGlobalConfig(config2) {
  return {
    lang: config2?.lang ?? store?.lang,
    message: config2?.message,
    abortEarly: config2?.abortEarly ?? store?.abortEarly,
    abortPipeEarly: config2?.abortPipeEarly ?? store?.abortPipeEarly
  };
}

// src/storages/globalMessage/globalMessage.ts
var store2;
function getGlobalMessage(lang) {
  return store2?.get(lang);
}

// src/storages/schemaMessage/schemaMessage.ts
var store3;
function getSchemaMessage(lang) {
  return store3?.get(lang);
}

// src/storages/specificMessage/specificMessage.ts
var store4;
function getSpecificMessage(reference, lang) {
  return store4?.get(reference)?.get(lang);
}

// src/utils/_stringify/_stringify.ts
function _stringify(input) {
  const type = typeof input;
  if (type === "string") {
    return `"${input}"`;
  }
  if (type === "number" || type === "bigint" || type === "boolean") {
    return `${input}`;
  }
  if (type === "object" || type === "function") {
    return (input && Object.getPrototypeOf(input)?.constructor?.name) ?? "null";
  }
  return type;
}

// src/utils/_addIssue/_addIssue.ts
function _addIssue(context, label, dataset, config2, other) {
  const input = other && "input" in other ? other.input : dataset.value;
  const expected = other?.expected ?? context.expects ?? null;
  const received = other?.received ?? _stringify(input);
  const issue = {
    kind: context.kind,
    type: context.type,
    input,
    expected,
    received,
    message: `Invalid ${label}: ${expected ? `Expected ${expected} but r` : "R"}eceived ${received}`,
    // @ts-expect-error
    requirement: context.requirement,
    path: other?.path,
    issues: other?.issues,
    lang: config2.lang,
    abortEarly: config2.abortEarly,
    abortPipeEarly: config2.abortPipeEarly
  };
  const isSchema = context.kind === "schema";
  const message = other?.message ?? // @ts-expect-error
  context.message ?? getSpecificMessage(context.reference, issue.lang) ?? (isSchema ? getSchemaMessage(issue.lang) : null) ?? config2.message ?? getGlobalMessage(issue.lang);
  if (message) {
    issue.message = typeof message === "function" ? message(issue) : message;
  }
  if (isSchema) {
    dataset.typed = false;
  }
  if (dataset.issues) {
    dataset.issues.push(issue);
  } else {
    dataset.issues = [issue];
  }
}

// src/utils/_joinExpects/_joinExpects.ts
function _joinExpects(values, separator) {
  const list = [...new Set(values)];
  if (list.length > 1) {
    return `(${list.join(` ${separator} `)})`;
  }
  return list[0] ?? "never";
}

// src/utils/ValiError/ValiError.ts
var ValiError = class extends Error {
  /**
   * The error issues.
   */
  issues;
  /**
   * Creates a Valibot error with useful information.
   *
   * @param issues The error issues.
   */
  constructor(issues) {
    super(issues[0].message);
    this.name = "ValiError";
    this.issues = issues;
  }
};

// src/actions/transform/transform.ts
function transform(operation) {
  return {
    kind: "transformation",
    type: "transform",
    reference: transform,
    async: false,
    operation,
    _run(dataset) {
      dataset.value = this.operation(dataset.value);
      return dataset;
    }
  };
}

// src/methods/getDefault/getDefault.ts
function getDefault(schema, dataset, config2) {
  return typeof schema.default === "function" ? (
    // @ts-expect-error
    schema.default(dataset, config2)
  ) : (
    // @ts-expect-error
    schema.default
  );
}

// src/schemas/array/array.ts
function array(item, message) {
  return {
    kind: "schema",
    type: "array",
    reference: array,
    expects: "Array",
    async: false,
    item,
    message,
    _run(dataset, config2) {
      const input = dataset.value;
      if (Array.isArray(input)) {
        dataset.typed = true;
        dataset.value = [];
        for (let key = 0; key < input.length; key++) {
          const value2 = input[key];
          const itemDataset = this.item._run({ typed: false, value: value2 }, config2);
          if (itemDataset.issues) {
            const pathItem = {
              type: "array",
              origin: "value",
              input,
              key,
              value: value2
            };
            for (const issue of itemDataset.issues) {
              if (issue.path) {
                issue.path.unshift(pathItem);
              } else {
                issue.path = [pathItem];
              }
              dataset.issues?.push(issue);
            }
            if (!dataset.issues) {
              dataset.issues = itemDataset.issues;
            }
            if (config2.abortEarly) {
              dataset.typed = false;
              break;
            }
          }
          if (!itemDataset.typed) {
            dataset.typed = false;
          }
          dataset.value.push(itemDataset.value);
        }
      } else {
        _addIssue(this, "type", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/schemas/boolean/boolean.ts
function boolean(message) {
  return {
    kind: "schema",
    type: "boolean",
    reference: boolean,
    expects: "boolean",
    async: false,
    message,
    _run(dataset, config2) {
      if (typeof dataset.value === "boolean") {
        dataset.typed = true;
      } else {
        _addIssue(this, "type", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/schemas/object/object.ts
function object(entries, message) {
  return {
    kind: "schema",
    type: "object",
    reference: object,
    expects: "Object",
    async: false,
    entries,
    message,
    _run(dataset, config2) {
      const input = dataset.value;
      if (input && typeof input === "object") {
        dataset.typed = true;
        dataset.value = {};
        for (const key in this.entries) {
          const value2 = input[key];
          const valueDataset = this.entries[key]._run(
            { typed: false, value: value2 },
            config2
          );
          if (valueDataset.issues) {
            const pathItem = {
              type: "object",
              origin: "value",
              input,
              key,
              value: value2
            };
            for (const issue of valueDataset.issues) {
              if (issue.path) {
                issue.path.unshift(pathItem);
              } else {
                issue.path = [pathItem];
              }
              dataset.issues?.push(issue);
            }
            if (!dataset.issues) {
              dataset.issues = valueDataset.issues;
            }
            if (config2.abortEarly) {
              dataset.typed = false;
              break;
            }
          }
          if (!valueDataset.typed) {
            dataset.typed = false;
          }
          if (valueDataset.value !== void 0 || key in input) {
            dataset.value[key] = valueDataset.value;
          }
        }
      } else {
        _addIssue(this, "type", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/schemas/optional/optional.ts
function optional(wrapped, ...args) {
  const schema = {
    kind: "schema",
    type: "optional",
    reference: optional,
    expects: `(${wrapped.expects} | undefined)`,
    async: false,
    wrapped,
    _run(dataset, config2) {
      if (dataset.value === void 0) {
        if ("default" in this) {
          dataset.value = getDefault(
            this,
            dataset,
            config2
          );
        }
        if (dataset.value === void 0) {
          dataset.typed = true;
          return dataset;
        }
      }
      return this.wrapped._run(dataset, config2);
    }
  };
  if (0 in args) {
    schema.default = args[0];
  }
  return schema;
}

// src/schemas/picklist/picklist.ts
function picklist(options, message) {
  return {
    kind: "schema",
    type: "picklist",
    reference: picklist,
    expects: _joinExpects(options.map(_stringify), "|"),
    async: false,
    options,
    message,
    _run(dataset, config2) {
      if (this.options.includes(dataset.value)) {
        dataset.typed = true;
      } else {
        _addIssue(this, "type", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/schemas/strictObject/strictObject.ts
function strictObject(entries, message) {
  return {
    kind: "schema",
    type: "strict_object",
    reference: strictObject,
    expects: "Object",
    async: false,
    entries,
    message,
    _run(dataset, config2) {
      const input = dataset.value;
      if (input && typeof input === "object") {
        dataset.typed = true;
        dataset.value = {};
        for (const key in this.entries) {
          const value2 = input[key];
          const valueDataset = this.entries[key]._run(
            { typed: false, value: value2 },
            config2
          );
          if (valueDataset.issues) {
            const pathItem = {
              type: "object",
              origin: "value",
              input,
              key,
              value: value2
            };
            for (const issue of valueDataset.issues) {
              if (issue.path) {
                issue.path.unshift(pathItem);
              } else {
                issue.path = [pathItem];
              }
              dataset.issues?.push(issue);
            }
            if (!dataset.issues) {
              dataset.issues = valueDataset.issues;
            }
            if (config2.abortEarly) {
              dataset.typed = false;
              break;
            }
          }
          if (!valueDataset.typed) {
            dataset.typed = false;
          }
          if (valueDataset.value !== void 0 || key in input) {
            dataset.value[key] = valueDataset.value;
          }
        }
        if (!dataset.issues || !config2.abortEarly) {
          for (const key in input) {
            if (!(key in this.entries)) {
              const value2 = input[key];
              _addIssue(this, "type", dataset, config2, {
                input: value2,
                expected: "never",
                path: [
                  {
                    type: "object",
                    origin: "value",
                    input,
                    key,
                    value: value2
                  }
                ]
              });
              break;
            }
          }
        }
      } else {
        _addIssue(this, "type", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/schemas/string/string.ts
function string(message) {
  return {
    kind: "schema",
    type: "string",
    reference: string,
    expects: "string",
    async: false,
    message,
    _run(dataset, config2) {
      if (typeof dataset.value === "string") {
        dataset.typed = true;
      } else {
        _addIssue(this, "type", dataset, config2);
      }
      return dataset;
    }
  };
}

// src/schemas/union/utils/_subIssues/_subIssues.ts
function _subIssues(datasets) {
  let issues;
  if (datasets) {
    for (const dataset of datasets) {
      if (issues) {
        issues.push(...dataset.issues);
      } else {
        issues = dataset.issues;
      }
    }
  }
  return issues;
}

// src/schemas/union/union.ts
function union(options, message) {
  return {
    kind: "schema",
    type: "union",
    reference: union,
    expects: _joinExpects(
      options.map((option) => option.expects),
      "|"
    ),
    async: false,
    options,
    message,
    _run(dataset, config2) {
      let validDataset;
      let typedDatasets;
      let untypedDatasets;
      for (const schema of this.options) {
        const optionDataset = schema._run(
          { typed: false, value: dataset.value },
          config2
        );
        if (optionDataset.typed) {
          if (optionDataset.issues) {
            if (typedDatasets) {
              typedDatasets.push(optionDataset);
            } else {
              typedDatasets = [optionDataset];
            }
          } else {
            validDataset = optionDataset;
            break;
          }
        } else {
          if (untypedDatasets) {
            untypedDatasets.push(optionDataset);
          } else {
            untypedDatasets = [optionDataset];
          }
        }
      }
      if (validDataset) {
        return validDataset;
      }
      if (typedDatasets) {
        if (typedDatasets.length === 1) {
          return typedDatasets[0];
        }
        _addIssue(this, "type", dataset, config2, {
          issues: _subIssues(typedDatasets)
        });
        dataset.typed = true;
      } else if (untypedDatasets?.length === 1) {
        return untypedDatasets[0];
      } else {
        _addIssue(this, "type", dataset, config2, {
          issues: _subIssues(untypedDatasets)
        });
      }
      return dataset;
    }
  };
}

// src/methods/parse/parse.ts
function parse(schema, input, config2) {
  const dataset = schema._run(
    { typed: false, value: input },
    getGlobalConfig(config2)
  );
  if (dataset.issues) {
    throw new ValiError(dataset.issues);
  }
  return dataset.value;
}

// src/methods/pipe/pipe.ts
function pipe$1(...pipe2) {
  return {
    ...pipe2[0],
    pipe: pipe2,
    _run(dataset, config2) {
      for (const item of pipe2) {
        if (item.kind !== "metadata") {
          if (dataset.issues && (item.kind === "schema" || item.kind === "transformation")) {
            dataset.typed = false;
            break;
          }
          if (!dataset.issues || !config2.abortEarly && !config2.abortPipeEarly) {
            dataset = item._run(dataset, config2);
          }
        }
      }
      return dataset;
    }
  };
}

function up(options) {
	return up$1("package.json", options);
}

function defineAddon(config) {
  return config;
}
function defineAddonOptions(options) {
  return options;
}
var eastasianwidth = { exports: {} };
(function(module) {
  var eaw = {};
  {
    module.exports = eaw;
  }
  eaw.eastAsianWidth = function(character) {
    var x = character.charCodeAt(0);
    var y = character.length == 2 ? character.charCodeAt(1) : 0;
    var codePoint = x;
    if (55296 <= x && x <= 56319 && (56320 <= y && y <= 57343)) {
      x &= 1023;
      y &= 1023;
      codePoint = x << 10 | y;
      codePoint += 65536;
    }
    if (12288 == codePoint || 65281 <= codePoint && codePoint <= 65376 || 65504 <= codePoint && codePoint <= 65510) {
      return "F";
    }
    if (8361 == codePoint || 65377 <= codePoint && codePoint <= 65470 || 65474 <= codePoint && codePoint <= 65479 || 65482 <= codePoint && codePoint <= 65487 || 65490 <= codePoint && codePoint <= 65495 || 65498 <= codePoint && codePoint <= 65500 || 65512 <= codePoint && codePoint <= 65518) {
      return "H";
    }
    if (4352 <= codePoint && codePoint <= 4447 || 4515 <= codePoint && codePoint <= 4519 || 4602 <= codePoint && codePoint <= 4607 || 9001 <= codePoint && codePoint <= 9002 || 11904 <= codePoint && codePoint <= 11929 || 11931 <= codePoint && codePoint <= 12019 || 12032 <= codePoint && codePoint <= 12245 || 12272 <= codePoint && codePoint <= 12283 || 12289 <= codePoint && codePoint <= 12350 || 12353 <= codePoint && codePoint <= 12438 || 12441 <= codePoint && codePoint <= 12543 || 12549 <= codePoint && codePoint <= 12589 || 12593 <= codePoint && codePoint <= 12686 || 12688 <= codePoint && codePoint <= 12730 || 12736 <= codePoint && codePoint <= 12771 || 12784 <= codePoint && codePoint <= 12830 || 12832 <= codePoint && codePoint <= 12871 || 12880 <= codePoint && codePoint <= 13054 || 13056 <= codePoint && codePoint <= 19903 || 19968 <= codePoint && codePoint <= 42124 || 42128 <= codePoint && codePoint <= 42182 || 43360 <= codePoint && codePoint <= 43388 || 44032 <= codePoint && codePoint <= 55203 || 55216 <= codePoint && codePoint <= 55238 || 55243 <= codePoint && codePoint <= 55291 || 63744 <= codePoint && codePoint <= 64255 || 65040 <= codePoint && codePoint <= 65049 || 65072 <= codePoint && codePoint <= 65106 || 65108 <= codePoint && codePoint <= 65126 || 65128 <= codePoint && codePoint <= 65131 || 110592 <= codePoint && codePoint <= 110593 || 127488 <= codePoint && codePoint <= 127490 || 127504 <= codePoint && codePoint <= 127546 || 127552 <= codePoint && codePoint <= 127560 || 127568 <= codePoint && codePoint <= 127569 || 131072 <= codePoint && codePoint <= 194367 || 177984 <= codePoint && codePoint <= 196605 || 196608 <= codePoint && codePoint <= 262141) {
      return "W";
    }
    if (32 <= codePoint && codePoint <= 126 || 162 <= codePoint && codePoint <= 163 || 165 <= codePoint && codePoint <= 166 || 172 == codePoint || 175 == codePoint || 10214 <= codePoint && codePoint <= 10221 || 10629 <= codePoint && codePoint <= 10630) {
      return "Na";
    }
    if (161 == codePoint || 164 == codePoint || 167 <= codePoint && codePoint <= 168 || 170 == codePoint || 173 <= codePoint && codePoint <= 174 || 176 <= codePoint && codePoint <= 180 || 182 <= codePoint && codePoint <= 186 || 188 <= codePoint && codePoint <= 191 || 198 == codePoint || 208 == codePoint || 215 <= codePoint && codePoint <= 216 || 222 <= codePoint && codePoint <= 225 || 230 == codePoint || 232 <= codePoint && codePoint <= 234 || 236 <= codePoint && codePoint <= 237 || 240 == codePoint || 242 <= codePoint && codePoint <= 243 || 247 <= codePoint && codePoint <= 250 || 252 == codePoint || 254 == codePoint || 257 == codePoint || 273 == codePoint || 275 == codePoint || 283 == codePoint || 294 <= codePoint && codePoint <= 295 || 299 == codePoint || 305 <= codePoint && codePoint <= 307 || 312 == codePoint || 319 <= codePoint && codePoint <= 322 || 324 == codePoint || 328 <= codePoint && codePoint <= 331 || 333 == codePoint || 338 <= codePoint && codePoint <= 339 || 358 <= codePoint && codePoint <= 359 || 363 == codePoint || 462 == codePoint || 464 == codePoint || 466 == codePoint || 468 == codePoint || 470 == codePoint || 472 == codePoint || 474 == codePoint || 476 == codePoint || 593 == codePoint || 609 == codePoint || 708 == codePoint || 711 == codePoint || 713 <= codePoint && codePoint <= 715 || 717 == codePoint || 720 == codePoint || 728 <= codePoint && codePoint <= 731 || 733 == codePoint || 735 == codePoint || 768 <= codePoint && codePoint <= 879 || 913 <= codePoint && codePoint <= 929 || 931 <= codePoint && codePoint <= 937 || 945 <= codePoint && codePoint <= 961 || 963 <= codePoint && codePoint <= 969 || 1025 == codePoint || 1040 <= codePoint && codePoint <= 1103 || 1105 == codePoint || 8208 == codePoint || 8211 <= codePoint && codePoint <= 8214 || 8216 <= codePoint && codePoint <= 8217 || 8220 <= codePoint && codePoint <= 8221 || 8224 <= codePoint && codePoint <= 8226 || 8228 <= codePoint && codePoint <= 8231 || 8240 == codePoint || 8242 <= codePoint && codePoint <= 8243 || 8245 == codePoint || 8251 == codePoint || 8254 == codePoint || 8308 == codePoint || 8319 == codePoint || 8321 <= codePoint && codePoint <= 8324 || 8364 == codePoint || 8451 == codePoint || 8453 == codePoint || 8457 == codePoint || 8467 == codePoint || 8470 == codePoint || 8481 <= codePoint && codePoint <= 8482 || 8486 == codePoint || 8491 == codePoint || 8531 <= codePoint && codePoint <= 8532 || 8539 <= codePoint && codePoint <= 8542 || 8544 <= codePoint && codePoint <= 8555 || 8560 <= codePoint && codePoint <= 8569 || 8585 == codePoint || 8592 <= codePoint && codePoint <= 8601 || 8632 <= codePoint && codePoint <= 8633 || 8658 == codePoint || 8660 == codePoint || 8679 == codePoint || 8704 == codePoint || 8706 <= codePoint && codePoint <= 8707 || 8711 <= codePoint && codePoint <= 8712 || 8715 == codePoint || 8719 == codePoint || 8721 == codePoint || 8725 == codePoint || 8730 == codePoint || 8733 <= codePoint && codePoint <= 8736 || 8739 == codePoint || 8741 == codePoint || 8743 <= codePoint && codePoint <= 8748 || 8750 == codePoint || 8756 <= codePoint && codePoint <= 8759 || 8764 <= codePoint && codePoint <= 8765 || 8776 == codePoint || 8780 == codePoint || 8786 == codePoint || 8800 <= codePoint && codePoint <= 8801 || 8804 <= codePoint && codePoint <= 8807 || 8810 <= codePoint && codePoint <= 8811 || 8814 <= codePoint && codePoint <= 8815 || 8834 <= codePoint && codePoint <= 8835 || 8838 <= codePoint && codePoint <= 8839 || 8853 == codePoint || 8857 == codePoint || 8869 == codePoint || 8895 == codePoint || 8978 == codePoint || 9312 <= codePoint && codePoint <= 9449 || 9451 <= codePoint && codePoint <= 9547 || 9552 <= codePoint && codePoint <= 9587 || 9600 <= codePoint && codePoint <= 9615 || 9618 <= codePoint && codePoint <= 9621 || 9632 <= codePoint && codePoint <= 9633 || 9635 <= codePoint && codePoint <= 9641 || 9650 <= codePoint && codePoint <= 9651 || 9654 <= codePoint && codePoint <= 9655 || 9660 <= codePoint && codePoint <= 9661 || 9664 <= codePoint && codePoint <= 9665 || 9670 <= codePoint && codePoint <= 9672 || 9675 == codePoint || 9678 <= codePoint && codePoint <= 9681 || 9698 <= codePoint && codePoint <= 9701 || 9711 == codePoint || 9733 <= codePoint && codePoint <= 9734 || 9737 == codePoint || 9742 <= codePoint && codePoint <= 9743 || 9748 <= codePoint && codePoint <= 9749 || 9756 == codePoint || 9758 == codePoint || 9792 == codePoint || 9794 == codePoint || 9824 <= codePoint && codePoint <= 9825 || 9827 <= codePoint && codePoint <= 9829 || 9831 <= codePoint && codePoint <= 9834 || 9836 <= codePoint && codePoint <= 9837 || 9839 == codePoint || 9886 <= codePoint && codePoint <= 9887 || 9918 <= codePoint && codePoint <= 9919 || 9924 <= codePoint && codePoint <= 9933 || 9935 <= codePoint && codePoint <= 9953 || 9955 == codePoint || 9960 <= codePoint && codePoint <= 9983 || 10045 == codePoint || 10071 == codePoint || 10102 <= codePoint && codePoint <= 10111 || 11093 <= codePoint && codePoint <= 11097 || 12872 <= codePoint && codePoint <= 12879 || 57344 <= codePoint && codePoint <= 63743 || 65024 <= codePoint && codePoint <= 65039 || 65533 == codePoint || 127232 <= codePoint && codePoint <= 127242 || 127248 <= codePoint && codePoint <= 127277 || 127280 <= codePoint && codePoint <= 127337 || 127344 <= codePoint && codePoint <= 127386 || 917760 <= codePoint && codePoint <= 917999 || 983040 <= codePoint && codePoint <= 1048573 || 1048576 <= codePoint && codePoint <= 1114109) {
      return "A";
    }
    return "N";
  };
  eaw.characterLength = function(character) {
    var code = this.eastAsianWidth(character);
    if (code == "F" || code == "W" || code == "A") {
      return 2;
    } else {
      return 1;
    }
  };
  function stringToArray(string) {
    return string.match(/[\uD800-\uDBFF][\uDC00-\uDFFF]|[^\uD800-\uDFFF]/g) || [];
  }
  eaw.length = function(string) {
    var characters = stringToArray(string);
    var len = 0;
    for (var i = 0; i < characters.length; i++) {
      len = len + this.characterLength(characters[i]);
    }
    return len;
  };
  eaw.slice = function(text2, start, end) {
    textLen = eaw.length(text2);
    start = start ? start : 0;
    end = end ? end : 1;
    if (start < 0) {
      start = textLen + start;
    }
    if (end < 0) {
      end = textLen + end;
    }
    var result = "";
    var eawLen = 0;
    var chars = stringToArray(text2);
    for (var i = 0; i < chars.length; i++) {
      var char = chars[i];
      var charLen = eaw.length(char);
      if (eawLen >= start - (charLen == 2 ? 1 : 0)) {
        if (eawLen + charLen <= end) {
          result += char;
        } else {
          break;
        }
      }
      eawLen += charLen;
    }
    return result;
  };
})(eastasianwidth);
const ANSI_BACKGROUND_OFFSET = 10;
const wrapAnsi16 = (offset = 0) => (code) => `\x1B[${code + offset}m`;
const wrapAnsi256 = (offset = 0) => (code) => `\x1B[${38 + offset};5;${code}m`;
const wrapAnsi16m = (offset = 0) => (red, green, blue) => `\x1B[${38 + offset};2;${red};${green};${blue}m`;
const styles = {
  modifier: {
    reset: [0, 0],
    // 21 isn't widely supported and 22 does the same thing
    bold: [1, 22],
    dim: [2, 22],
    italic: [3, 23],
    underline: [4, 24],
    overline: [53, 55],
    inverse: [7, 27],
    hidden: [8, 28],
    strikethrough: [9, 29]
  },
  color: {
    black: [30, 39],
    red: [31, 39],
    green: [32, 39],
    yellow: [33, 39],
    blue: [34, 39],
    magenta: [35, 39],
    cyan: [36, 39],
    white: [37, 39],
    // Bright color
    blackBright: [90, 39],
    gray: [90, 39],
    // Alias of `blackBright`
    grey: [90, 39],
    // Alias of `blackBright`
    redBright: [91, 39],
    greenBright: [92, 39],
    yellowBright: [93, 39],
    blueBright: [94, 39],
    magentaBright: [95, 39],
    cyanBright: [96, 39],
    whiteBright: [97, 39]
  },
  bgColor: {
    bgBlack: [40, 49],
    bgRed: [41, 49],
    bgGreen: [42, 49],
    bgYellow: [43, 49],
    bgBlue: [44, 49],
    bgMagenta: [45, 49],
    bgCyan: [46, 49],
    bgWhite: [47, 49],
    // Bright color
    bgBlackBright: [100, 49],
    bgGray: [100, 49],
    // Alias of `bgBlackBright`
    bgGrey: [100, 49],
    // Alias of `bgBlackBright`
    bgRedBright: [101, 49],
    bgGreenBright: [102, 49],
    bgYellowBright: [103, 49],
    bgBlueBright: [104, 49],
    bgMagentaBright: [105, 49],
    bgCyanBright: [106, 49],
    bgWhiteBright: [107, 49]
  }
};
Object.keys(styles.modifier);
const foregroundColorNames = Object.keys(styles.color);
const backgroundColorNames = Object.keys(styles.bgColor);
[...foregroundColorNames, ...backgroundColorNames];
function assembleStyles() {
  const codes = /* @__PURE__ */ new Map();
  for (const [groupName, group2] of Object.entries(styles)) {
    for (const [styleName, style] of Object.entries(group2)) {
      styles[styleName] = {
        open: `\x1B[${style[0]}m`,
        close: `\x1B[${style[1]}m`
      };
      group2[styleName] = styles[styleName];
      codes.set(style[0], style[1]);
    }
    Object.defineProperty(styles, groupName, {
      value: group2,
      enumerable: false
    });
  }
  Object.defineProperty(styles, "codes", {
    value: codes,
    enumerable: false
  });
  styles.color.close = "\x1B[39m";
  styles.bgColor.close = "\x1B[49m";
  styles.color.ansi = wrapAnsi16();
  styles.color.ansi256 = wrapAnsi256();
  styles.color.ansi16m = wrapAnsi16m();
  styles.bgColor.ansi = wrapAnsi16(ANSI_BACKGROUND_OFFSET);
  styles.bgColor.ansi256 = wrapAnsi256(ANSI_BACKGROUND_OFFSET);
  styles.bgColor.ansi16m = wrapAnsi16m(ANSI_BACKGROUND_OFFSET);
  Object.defineProperties(styles, {
    rgbToAnsi256: {
      value: (red, green, blue) => {
        if (red === green && green === blue) {
          if (red < 8) {
            return 16;
          }
          if (red > 248) {
            return 231;
          }
          return Math.round((red - 8) / 247 * 24) + 232;
        }
        return 16 + 36 * Math.round(red / 255 * 5) + 6 * Math.round(green / 255 * 5) + Math.round(blue / 255 * 5);
      },
      enumerable: false
    },
    hexToRgb: {
      value: (hex) => {
        const matches = /[a-f\d]{6}|[a-f\d]{3}/i.exec(hex.toString(16));
        if (!matches) {
          return [0, 0, 0];
        }
        let [colorString] = matches;
        if (colorString.length === 3) {
          colorString = [...colorString].map((character) => character + character).join("");
        }
        const integer = Number.parseInt(colorString, 16);
        return [
          /* eslint-disable no-bitwise */
          integer >> 16 & 255,
          integer >> 8 & 255,
          integer & 255
          /* eslint-enable no-bitwise */
        ];
      },
      enumerable: false
    },
    hexToAnsi256: {
      value: (hex) => styles.rgbToAnsi256(...styles.hexToRgb(hex)),
      enumerable: false
    },
    ansi256ToAnsi: {
      value: (code) => {
        if (code < 8) {
          return 30 + code;
        }
        if (code < 16) {
          return 90 + (code - 8);
        }
        let red;
        let green;
        let blue;
        if (code >= 232) {
          red = ((code - 232) * 10 + 8) / 255;
          green = red;
          blue = red;
        } else {
          code -= 16;
          const remainder = code % 36;
          red = Math.floor(code / 36) / 5;
          green = Math.floor(remainder / 6) / 5;
          blue = remainder % 6 / 5;
        }
        const value = Math.max(red, green, blue) * 2;
        if (value === 0) {
          return 30;
        }
        let result = 30 + (Math.round(blue) << 2 | Math.round(green) << 1 | Math.round(red));
        if (value === 2) {
          result += 60;
        }
        return result;
      },
      enumerable: false
    },
    rgbToAnsi: {
      value: (red, green, blue) => styles.ansi256ToAnsi(styles.rgbToAnsi256(red, green, blue)),
      enumerable: false
    },
    hexToAnsi: {
      value: (hex) => styles.ansi256ToAnsi(styles.hexToAnsi256(hex)),
      enumerable: false
    }
  });
  return styles;
}
assembleStyles();
var picocolors$1$1 = { exports: {} };
let p$1 = process || {}, argv$1 = p$1.argv || [], env$1 = p$1.env || {};
let isColorSupported$1 = !(!!env$1.NO_COLOR || argv$1.includes("--no-color")) && (!!env$1.FORCE_COLOR || argv$1.includes("--color") || p$1.platform === "win32" || (p$1.stdout || {}).isTTY && env$1.TERM !== "dumb" || !!env$1.CI);
let formatter$1 = (open, close, replace = open) => (input) => {
  let string = "" + input, index = string.indexOf(close, open.length);
  return ~index ? open + replaceClose$1(string, close, replace, index) + close : open + string + close;
};
let replaceClose$1 = (string, close, replace, index) => {
  let result = "", cursor2 = 0;
  do {
    result += string.substring(cursor2, index) + replace;
    cursor2 = index + close.length;
    index = string.indexOf(close, cursor2);
  } while (~index);
  return result + string.substring(cursor2);
};
let createColors$1 = (enabled = isColorSupported$1) => {
  let f = enabled ? formatter$1 : () => String;
  return {
    isColorSupported: enabled,
    reset: f("\x1B[0m", "\x1B[0m"),
    bold: f("\x1B[1m", "\x1B[22m", "\x1B[22m\x1B[1m"),
    dim: f("\x1B[2m", "\x1B[22m", "\x1B[22m\x1B[2m"),
    italic: f("\x1B[3m", "\x1B[23m"),
    underline: f("\x1B[4m", "\x1B[24m"),
    inverse: f("\x1B[7m", "\x1B[27m"),
    hidden: f("\x1B[8m", "\x1B[28m"),
    strikethrough: f("\x1B[9m", "\x1B[29m"),
    black: f("\x1B[30m", "\x1B[39m"),
    red: f("\x1B[31m", "\x1B[39m"),
    green: f("\x1B[32m", "\x1B[39m"),
    yellow: f("\x1B[33m", "\x1B[39m"),
    blue: f("\x1B[34m", "\x1B[39m"),
    magenta: f("\x1B[35m", "\x1B[39m"),
    cyan: f("\x1B[36m", "\x1B[39m"),
    white: f("\x1B[37m", "\x1B[39m"),
    gray: f("\x1B[90m", "\x1B[39m"),
    bgBlack: f("\x1B[40m", "\x1B[49m"),
    bgRed: f("\x1B[41m", "\x1B[49m"),
    bgGreen: f("\x1B[42m", "\x1B[49m"),
    bgYellow: f("\x1B[43m", "\x1B[49m"),
    bgBlue: f("\x1B[44m", "\x1B[49m"),
    bgMagenta: f("\x1B[45m", "\x1B[49m"),
    bgCyan: f("\x1B[46m", "\x1B[49m"),
    bgWhite: f("\x1B[47m", "\x1B[49m"),
    blackBright: f("\x1B[90m", "\x1B[39m"),
    redBright: f("\x1B[91m", "\x1B[39m"),
    greenBright: f("\x1B[92m", "\x1B[39m"),
    yellowBright: f("\x1B[93m", "\x1B[39m"),
    blueBright: f("\x1B[94m", "\x1B[39m"),
    magentaBright: f("\x1B[95m", "\x1B[39m"),
    cyanBright: f("\x1B[96m", "\x1B[39m"),
    whiteBright: f("\x1B[97m", "\x1B[39m"),
    bgBlackBright: f("\x1B[100m", "\x1B[49m"),
    bgRedBright: f("\x1B[101m", "\x1B[49m"),
    bgGreenBright: f("\x1B[102m", "\x1B[49m"),
    bgYellowBright: f("\x1B[103m", "\x1B[49m"),
    bgBlueBright: f("\x1B[104m", "\x1B[49m"),
    bgMagentaBright: f("\x1B[105m", "\x1B[49m"),
    bgCyanBright: f("\x1B[106m", "\x1B[49m"),
    bgWhiteBright: f("\x1B[107m", "\x1B[49m")
  };
};
picocolors$1$1.exports = createColors$1();
picocolors$1$1.exports.createColors = createColors$1;
process$1$1.platform.startsWith("win");
function isUnicodeSupported() {
  if (process$1$1.platform !== "win32") {
    return process$1$1.env.TERM !== "linux";
  }
  return Boolean(process$1$1.env.CI) || Boolean(process$1$1.env.WT_SESSION) || Boolean(process$1$1.env.TERMINUS_SUBLIME) || process$1$1.env.ConEmuTask === "{cmd::Cmder}" || process$1$1.env.TERM_PROGRAM === "Terminus-Sublime" || process$1$1.env.TERM_PROGRAM === "vscode" || process$1$1.env.TERM === "xterm-256color" || process$1$1.env.TERM === "alacritty" || process$1$1.env.TERMINAL_EMULATOR === "JetBrains-JediTerm";
}
function getDefaultExportFromCjs$1(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
var picocolors$2 = { exports: {} };
let p$2 = process || {}, argv$2 = p$2.argv || [], env$2 = p$2.env || {};
let isColorSupported$2 = !(!!env$2.NO_COLOR || argv$2.includes("--no-color")) && (!!env$2.FORCE_COLOR || argv$2.includes("--color") || p$2.platform === "win32" || (p$2.stdout || {}).isTTY && env$2.TERM !== "dumb" || !!env$2.CI);
let formatter$2 = (open, close, replace = open) => (input) => {
  let string = "" + input, index = string.indexOf(close, open.length);
  return ~index ? open + replaceClose$2(string, close, replace, index) + close : open + string + close;
};
let replaceClose$2 = (string, close, replace, index) => {
  let result = "", cursor2 = 0;
  do {
    result += string.substring(cursor2, index) + replace;
    cursor2 = index + close.length;
    index = string.indexOf(close, cursor2);
  } while (~index);
  return result + string.substring(cursor2);
};
let createColors$2 = (enabled = isColorSupported$2) => {
  let f = enabled ? formatter$2 : () => String;
  return {
    isColorSupported: enabled,
    reset: f("\x1B[0m", "\x1B[0m"),
    bold: f("\x1B[1m", "\x1B[22m", "\x1B[22m\x1B[1m"),
    dim: f("\x1B[2m", "\x1B[22m", "\x1B[22m\x1B[2m"),
    italic: f("\x1B[3m", "\x1B[23m"),
    underline: f("\x1B[4m", "\x1B[24m"),
    inverse: f("\x1B[7m", "\x1B[27m"),
    hidden: f("\x1B[8m", "\x1B[28m"),
    strikethrough: f("\x1B[9m", "\x1B[29m"),
    black: f("\x1B[30m", "\x1B[39m"),
    red: f("\x1B[31m", "\x1B[39m"),
    green: f("\x1B[32m", "\x1B[39m"),
    yellow: f("\x1B[33m", "\x1B[39m"),
    blue: f("\x1B[34m", "\x1B[39m"),
    magenta: f("\x1B[35m", "\x1B[39m"),
    cyan: f("\x1B[36m", "\x1B[39m"),
    white: f("\x1B[37m", "\x1B[39m"),
    gray: f("\x1B[90m", "\x1B[39m"),
    bgBlack: f("\x1B[40m", "\x1B[49m"),
    bgRed: f("\x1B[41m", "\x1B[49m"),
    bgGreen: f("\x1B[42m", "\x1B[49m"),
    bgYellow: f("\x1B[43m", "\x1B[49m"),
    bgBlue: f("\x1B[44m", "\x1B[49m"),
    bgMagenta: f("\x1B[45m", "\x1B[49m"),
    bgCyan: f("\x1B[46m", "\x1B[49m"),
    bgWhite: f("\x1B[47m", "\x1B[49m"),
    blackBright: f("\x1B[90m", "\x1B[39m"),
    redBright: f("\x1B[91m", "\x1B[39m"),
    greenBright: f("\x1B[92m", "\x1B[39m"),
    yellowBright: f("\x1B[93m", "\x1B[39m"),
    blueBright: f("\x1B[94m", "\x1B[39m"),
    magentaBright: f("\x1B[95m", "\x1B[39m"),
    cyanBright: f("\x1B[96m", "\x1B[39m"),
    whiteBright: f("\x1B[97m", "\x1B[39m"),
    bgBlackBright: f("\x1B[100m", "\x1B[49m"),
    bgRedBright: f("\x1B[101m", "\x1B[49m"),
    bgGreenBright: f("\x1B[102m", "\x1B[49m"),
    bgYellowBright: f("\x1B[103m", "\x1B[49m"),
    bgBlueBright: f("\x1B[104m", "\x1B[49m"),
    bgMagentaBright: f("\x1B[105m", "\x1B[49m"),
    bgCyanBright: f("\x1B[106m", "\x1B[49m"),
    bgWhiteBright: f("\x1B[107m", "\x1B[49m")
  };
};
picocolors$2.exports = createColors$2();
picocolors$2.exports.createColors = createColors$2;
var picocolorsExports$1 = picocolors$2.exports;
var color = /* @__PURE__ */ getDefaultExportFromCjs$1(picocolorsExports$1);
const unicode = isUnicodeSupported();
const s = (c, fallback) => unicode ? c : fallback;
const S_STEP_SUBMIT = s("\u25C7", "o");
const S_BAR = s("\u2502", "|");
const S_INFO = s("\u25CF", "\u2022");
const S_SUCCESS = s("\u25C6", "*");
const S_WARN = s("\u25B2", "!");
const S_ERROR = s("\u25A0", "x");
const log = {
  message: (message = "", { symbol: symbol2 = color.gray(S_BAR) } = {}) => {
    const parts = [color.gray(S_BAR)];
    if (message) {
      const [firstLine, ...lines] = message.split("\n");
      parts.push(`${symbol2}  ${firstLine}`, ...lines.map((ln) => `${color.gray(S_BAR)}  ${ln}`));
    }
    process$1$1.stdout.write(`${parts.join("\n")}
`);
  },
  info: (message) => {
    log.message(message, { symbol: color.blue(S_INFO) });
  },
  success: (message) => {
    log.message(message, { symbol: color.green(S_SUCCESS) });
  },
  step: (message) => {
    log.message(message, { symbol: color.green(S_STEP_SUBMIT) });
  },
  warn: (message) => {
    log.message(message, { symbol: color.yellow(S_WARN) });
  },
  /** alias for `log.warn()`. */
  warning: (message) => {
    log.warn(message);
  },
  error: (message) => {
    log.message(message, { symbol: color.red(S_ERROR) });
  }
};
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
var picocolors$1 = { exports: {} };
let p = process || {}, argv = p.argv || [], env = p.env || {};
let isColorSupported = !(!!env.NO_COLOR || argv.includes("--no-color")) && (!!env.FORCE_COLOR || argv.includes("--color") || p.platform === "win32" || (p.stdout || {}).isTTY && env.TERM !== "dumb" || !!env.CI);
let formatter = (open, close, replace = open) => (input) => {
  let string = "" + input, index = string.indexOf(close, open.length);
  return ~index ? open + replaceClose(string, close, replace, index) + close : open + string + close;
};
let replaceClose = (string, close, replace, index) => {
  let result = "", cursor = 0;
  do {
    result += string.substring(cursor, index) + replace;
    cursor = index + close.length;
    index = string.indexOf(close, cursor);
  } while (~index);
  return result + string.substring(cursor);
};
let createColors = (enabled = isColorSupported) => {
  let f = enabled ? formatter : () => String;
  return {
    isColorSupported: enabled,
    reset: f("\x1B[0m", "\x1B[0m"),
    bold: f("\x1B[1m", "\x1B[22m", "\x1B[22m\x1B[1m"),
    dim: f("\x1B[2m", "\x1B[22m", "\x1B[22m\x1B[2m"),
    italic: f("\x1B[3m", "\x1B[23m"),
    underline: f("\x1B[4m", "\x1B[24m"),
    inverse: f("\x1B[7m", "\x1B[27m"),
    hidden: f("\x1B[8m", "\x1B[28m"),
    strikethrough: f("\x1B[9m", "\x1B[29m"),
    black: f("\x1B[30m", "\x1B[39m"),
    red: f("\x1B[31m", "\x1B[39m"),
    green: f("\x1B[32m", "\x1B[39m"),
    yellow: f("\x1B[33m", "\x1B[39m"),
    blue: f("\x1B[34m", "\x1B[39m"),
    magenta: f("\x1B[35m", "\x1B[39m"),
    cyan: f("\x1B[36m", "\x1B[39m"),
    white: f("\x1B[37m", "\x1B[39m"),
    gray: f("\x1B[90m", "\x1B[39m"),
    bgBlack: f("\x1B[40m", "\x1B[49m"),
    bgRed: f("\x1B[41m", "\x1B[49m"),
    bgGreen: f("\x1B[42m", "\x1B[49m"),
    bgYellow: f("\x1B[43m", "\x1B[49m"),
    bgBlue: f("\x1B[44m", "\x1B[49m"),
    bgMagenta: f("\x1B[45m", "\x1B[49m"),
    bgCyan: f("\x1B[46m", "\x1B[49m"),
    bgWhite: f("\x1B[47m", "\x1B[49m"),
    blackBright: f("\x1B[90m", "\x1B[39m"),
    redBright: f("\x1B[91m", "\x1B[39m"),
    greenBright: f("\x1B[92m", "\x1B[39m"),
    yellowBright: f("\x1B[93m", "\x1B[39m"),
    blueBright: f("\x1B[94m", "\x1B[39m"),
    magentaBright: f("\x1B[95m", "\x1B[39m"),
    cyanBright: f("\x1B[96m", "\x1B[39m"),
    whiteBright: f("\x1B[97m", "\x1B[39m"),
    bgBlackBright: f("\x1B[100m", "\x1B[49m"),
    bgRedBright: f("\x1B[101m", "\x1B[49m"),
    bgGreenBright: f("\x1B[102m", "\x1B[49m"),
    bgYellowBright: f("\x1B[103m", "\x1B[49m"),
    bgBlueBright: f("\x1B[104m", "\x1B[49m"),
    bgMagentaBright: f("\x1B[105m", "\x1B[49m"),
    bgCyanBright: f("\x1B[106m", "\x1B[49m"),
    bgWhiteBright: f("\x1B[107m", "\x1B[49m")
  };
};
picocolors$1.exports = createColors();
picocolors$1.exports.createColors = createColors;
var picocolorsExports = picocolors$1.exports;
var picocolors = /* @__PURE__ */ getDefaultExportFromCjs(picocolorsExports);
function createPrinter(...conditions) {
  const printers = conditions.map((condition) => {
    return (content, alt = "") => condition ? content : alt;
  });
  return printers;
}
var utils = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  createPrinter
});

const PORTS = {
  mysql: "3306",
  postgresql: "5432",
  sqlite: ""
};
const options$4 = defineAddonOptions({
  database: {
    question: "Which database would you like to use?",
    type: "select",
    default: "sqlite",
    options: [
      { value: "postgresql", label: "PostgreSQL" },
      { value: "mysql", label: "MySQL" },
      { value: "sqlite", label: "SQLite" }
    ]
  },
  postgresql: {
    question: "Which PostgreSQL client would you like to use?",
    type: "select",
    group: "client",
    default: "postgres.js",
    options: [
      { value: "postgres.js", label: "Postgres.JS", hint: "recommended for most users" },
      { value: "neon", label: "Neon", hint: "popular hosted platform" }
    ],
    condition: ({ database }) => database === "postgresql"
  },
  mysql: {
    question: "Which MySQL client would you like to use?",
    type: "select",
    group: "client",
    default: "mysql2",
    options: [
      { value: "mysql2", hint: "recommended for most users" },
      { value: "planetscale", label: "PlanetScale", hint: "popular hosted platform" }
    ],
    condition: ({ database }) => database === "mysql"
  },
  sqlite: {
    question: "Which SQLite client would you like to use?",
    type: "select",
    group: "client",
    default: "libsql",
    options: [
      { value: "better-sqlite3", hint: "for traditional Node environments" },
      { value: "libsql", label: "libSQL", hint: "for serverless environments" },
      { value: "turso", label: "Turso", hint: "popular hosted platform" }
    ],
    condition: ({ database }) => database === "sqlite"
  },
  docker: {
    question: "Do you want to run the database locally with docker-compose?",
    default: false,
    type: "boolean",
    condition: ({ database, mysql, postgresql }) => database === "mysql" && mysql === "mysql2" || database === "postgresql" && postgresql === "postgres.js"
  }
});
var drizzle = defineAddon({
  id: "drizzle",
  shortDescription: "database orm",
  homepage: "https://orm.drizzle.team",
  options: options$4,
  setup: ({ kit, unsupported }) => {
    if (!kit) unsupported("Requires SvelteKit");
  },
  run: ({ sv, typescript, options: options2, kit }) => {
    const ext = typescript ? "ts" : "js";
    sv.dependency("drizzle-orm", "^0.33.0");
    sv.devDependency("drizzle-kit", "^0.22.0");
    if (options2.mysql === "mysql2") sv.dependency("mysql2", "^3.11.0");
    if (options2.mysql === "planetscale") sv.dependency("@planetscale/database", "^1.18.0");
    if (options2.postgresql === "neon") sv.dependency("@neondatabase/serverless", "^0.9.4");
    if (options2.postgresql === "postgres.js") sv.dependency("postgres", "^3.4.4");
    if (options2.sqlite === "better-sqlite3") {
      sv.dependency("better-sqlite3", "^11.1.2");
      sv.devDependency("@types/better-sqlite3", "^7.6.11");
    }
    if (options2.sqlite === "libsql" || options2.sqlite === "turso")
      sv.dependency("@libsql/client", "^0.9.0");
    sv.file(".env", (content) => generateEnvFileContent(content, options2));
    sv.file(".env.example", (content) => generateEnvFileContent(content, options2));
    if (options2.docker && (options2.mysql === "mysql2" || options2.postgresql === "postgres.js")) {
      sv.file("docker-compose.yml", (content) => {
        if (content.length > 0) return content;
        const imageName = options2.database === "mysql" ? "mysql" : "postgres";
        const port = PORTS[options2.database];
        const USER = "root";
        const PASSWORD = "mysecretpassword";
        const DB_NAME = "local";
        let dbSpecificContent = "";
        if (options2.mysql === "mysql2") {
          dbSpecificContent = `
                      MYSQL_ROOT_PASSWORD: ${PASSWORD}
                      MYSQL_DATABASE: ${DB_NAME}
                `;
        }
        if (options2.postgresql === "postgres.js") {
          dbSpecificContent = `
                      POSTGRES_USER: ${USER}
                      POSTGRES_PASSWORD: ${PASSWORD}
                      POSTGRES_DB: ${DB_NAME}
                `;
        }
        content = dedent`
                services:
                  db:
                    image: ${imageName}
                    restart: always
                    ports:
                      - ${port}:${port}
                    environment: ${dbSpecificContent}
                `;
        return content;
      });
    }
    sv.file("package.json", (content) => {
      const { data, generateCode } = parseJson(content);
      data.scripts ?? (data.scripts = {});
      const scripts = data.scripts;
      if (options2.docker) scripts["db:start"] ?? (scripts["db:start"] = "docker compose up");
      scripts["db:push"] ?? (scripts["db:push"] = "drizzle-kit push");
      scripts["db:migrate"] ?? (scripts["db:migrate"] = "drizzle-kit migrate");
      scripts["db:studio"] ?? (scripts["db:studio"] = "drizzle-kit studio");
      return generateCode();
    });
    if (options2.database === "sqlite") {
      sv.file(".gitignore", (content) => {
        if (content.length === 0) return content;
        if (!content.includes("\n*.db")) {
          content = content.trimEnd() + "\n\n# SQLite\n*.db";
        }
        return content;
      });
    }
    sv.file(`drizzle.config.${ext}`, (content) => {
      const { ast, generateCode } = parseScript(content);
      imports.addNamed(ast, "drizzle-kit", { defineConfig: "defineConfig" });
      const envCheckStatement = common.statementFromString(
        "if (!process.env.DATABASE_URL) throw new Error('DATABASE_URL is not set');"
      );
      common.addStatement(ast, envCheckStatement);
      const fallback = common.expressionFromString("defineConfig({})");
      const { value: exportDefault } = exports$1.defaultExport(ast, fallback);
      if (exportDefault.type !== "CallExpression") return content;
      const objExpression = exportDefault.arguments?.[0];
      if (!objExpression || objExpression.type !== "ObjectExpression") return content;
      const driver = options2.sqlite === "turso" ? common.createLiteral("turso") : void 0;
      const authToken = options2.sqlite === "turso" ? common.expressionFromString("process.env.DATABASE_AUTH_TOKEN") : void 0;
      object$1.properties(objExpression, {
        schema: common.createLiteral(`./src/lib/server/db/schema.${typescript ? "ts" : "js"}`),
        dbCredentials: object$1.create({
          url: common.expressionFromString("process.env.DATABASE_URL"),
          authToken
        }),
        verbose: { type: "BooleanLiteral", value: true },
        strict: { type: "BooleanLiteral", value: true },
        driver
      });
      object$1.overrideProperties(objExpression, {
        dialect: common.createLiteral(options2.database)
      });
      if (options2.database !== "sqlite") object$1.removeProperty(objExpression, "driver");
      return generateCode();
    });
    sv.file(`${kit?.libDirectory}/server/db/schema.${ext}`, (content) => {
      const { ast, generateCode } = parseScript(content);
      let userSchemaExpression;
      if (options2.database === "sqlite") {
        imports.addNamed(ast, "drizzle-orm/sqlite-core", {
          sqliteTable: "sqliteTable",
          text: "text",
          integer: "integer"
        });
        userSchemaExpression = common.expressionFromString(`sqliteTable('user', {
					id: integer('id').primaryKey(),
					age: integer('age')
				})`);
      }
      if (options2.database === "mysql") {
        imports.addNamed(ast, "drizzle-orm/mysql-core", {
          mysqlTable: "mysqlTable",
          serial: "serial",
          text: "text",
          int: "int"
        });
        userSchemaExpression = common.expressionFromString(`mysqlTable('user', {
					id: serial('id').primaryKey(),
					age: int('age'),
				})`);
      }
      if (options2.database === "postgresql") {
        imports.addNamed(ast, "drizzle-orm/pg-core", {
          pgTable: "pgTable",
          serial: "serial",
          text: "text",
          integer: "integer"
        });
        userSchemaExpression = common.expressionFromString(`pgTable('user', {
					id: serial('id').primaryKey(),
					age: integer('age'),
				})`);
      }
      if (!userSchemaExpression) throw new Error("unreachable state...");
      const userIdentifier = variables.declaration(ast, "const", "user", userSchemaExpression);
      exports$1.namedExport(ast, "user", userIdentifier);
      return generateCode();
    });
    sv.file(`${kit?.libDirectory}/server/db/index.${ext}`, (content) => {
      const { ast, generateCode } = parseScript(content);
      imports.addNamed(ast, "$env/dynamic/private", { env: "env" });
      const dbURLCheck = common.statementFromString(
        "if (!env.DATABASE_URL) throw new Error('DATABASE_URL is not set');"
      );
      common.addStatement(ast, dbURLCheck);
      let clientExpression;
      if (options2.sqlite === "better-sqlite3") {
        imports.addDefault(ast, "better-sqlite3", "Database");
        imports.addNamed(ast, "drizzle-orm/better-sqlite3", { drizzle: "drizzle" });
        clientExpression = common.expressionFromString("new Database(env.DATABASE_URL)");
      }
      if (options2.sqlite === "libsql" || options2.sqlite === "turso") {
        imports.addNamed(ast, "@libsql/client", { createClient: "createClient" });
        imports.addNamed(ast, "drizzle-orm/libsql", { drizzle: "drizzle" });
        if (options2.sqlite === "turso") {
          imports.addNamed(ast, "$app/environment", { dev: "dev" });
          const authTokenCheck = common.statementFromString(
            "if (!dev && !env.DATABASE_AUTH_TOKEN) throw new Error('DATABASE_AUTH_TOKEN is not set');"
          );
          common.addStatement(ast, authTokenCheck);
          clientExpression = common.expressionFromString(
            "createClient({ url: env.DATABASE_URL, authToken: env.DATABASE_AUTH_TOKEN })"
          );
        } else {
          clientExpression = common.expressionFromString("createClient({ url: env.DATABASE_URL })");
        }
      }
      if (options2.mysql === "mysql2") {
        imports.addDefault(ast, "mysql2/promise", "mysql");
        imports.addNamed(ast, "drizzle-orm/mysql2", { drizzle: "drizzle" });
        clientExpression = common.expressionFromString(
          "await mysql.createConnection(env.DATABASE_URL)"
        );
      }
      if (options2.mysql === "planetscale") {
        imports.addNamed(ast, "@planetscale/database", { Client: "Client" });
        imports.addNamed(ast, "drizzle-orm/planetscale-serverless", { drizzle: "drizzle" });
        clientExpression = common.expressionFromString("new Client({ url: env.DATABASE_URL })");
      }
      if (options2.postgresql === "neon") {
        imports.addNamed(ast, "@neondatabase/serverless", { neon: "neon" });
        imports.addNamed(ast, "drizzle-orm/neon-http", { drizzle: "drizzle" });
        clientExpression = common.expressionFromString("neon(env.DATABASE_URL)");
      }
      if (options2.postgresql === "postgres.js") {
        imports.addDefault(ast, "postgres", "postgres");
        imports.addNamed(ast, "drizzle-orm/postgres-js", { drizzle: "drizzle" });
        clientExpression = common.expressionFromString("postgres(env.DATABASE_URL)");
      }
      if (!clientExpression) throw new Error("unreachable state...");
      const clientIdentifier = variables.declaration(ast, "const", "client", clientExpression);
      common.addStatement(ast, clientIdentifier);
      const drizzleCall = _function.callByIdentifier("drizzle", ["client"]);
      const db = variables.declaration(ast, "const", "db", drizzleCall);
      exports$1.namedExport(ast, "db", db);
      return generateCode();
    });
  },
  nextSteps: ({ options: options2, highlighter, packageManager }) => {
    const steps = [
      `You will need to set ${highlighter.env("DATABASE_URL")} in your production environment`
    ];
    if (options2.docker) {
      steps.push(
        `Run ${highlighter.command(`${packageManager} run db:start`)} to start the docker container`
      );
    }
    steps.push(
      `Run ${highlighter.command(`${packageManager} run db:push`)} to update your database schema`
    );
    return steps;
  }
});
function generateEnvFileContent(content, opts) {
  const DB_URL_KEY = "DATABASE_URL";
  if (opts.docker) {
    const protocol = opts.database === "mysql" ? "mysql" : "postgres";
    const port = PORTS[opts.database];
    content = addEnvVar(
      content,
      DB_URL_KEY,
      `"${protocol}://root:mysecretpassword@localhost:${port}/local"`
    );
    return content;
  }
  if (opts.sqlite === "better-sqlite3" || opts.sqlite === "libsql") {
    const dbFile = opts.sqlite === "libsql" ? "file:local.db" : "local.db";
    content = addEnvVar(content, DB_URL_KEY, dbFile);
    return content;
  }
  content = addEnvComment(content, "Replace with your DB credentials!");
  if (opts.sqlite === "turso") {
    content = addEnvVar(content, DB_URL_KEY, '"libsql://db-name-user.turso.io"');
    content = addEnvVar(content, "DATABASE_AUTH_TOKEN", '""');
    content = addEnvComment(content, "A local DB can also be used in dev as well");
    content = addEnvComment(content, `${DB_URL_KEY}="file:local.db"`);
  }
  if (opts.database === "mysql") {
    content = addEnvVar(content, DB_URL_KEY, '"mysql://user:password@host:port/db-name"');
  }
  if (opts.database === "postgresql") {
    content = addEnvVar(content, DB_URL_KEY, '"postgres://user:password@host:port/db-name"');
  }
  return content;
}
function addEnvVar(content, key, value) {
  if (!content.includes(key + "=")) {
    content = appendEnvContent(content, `${key}=${value}`);
  }
  return content;
}
function addEnvComment(content, comment) {
  const commented = `# ${comment}`;
  if (!content.includes(commented)) {
    content = appendEnvContent(content, commented);
  }
  return content;
}
function appendEnvContent(existing, content) {
  const withNewLine = !existing.length || existing.endsWith("\n") ? existing : existing + "\n";
  return withNewLine + content + "\n";
}

function addEslintConfigPrettier(content) {
  const { ast, generateCode } = parseScript(content);
  const importNodes = ast.body.filter((n) => n.type === "ImportDeclaration");
  const sveltePluginImport = importNodes.find(
    (n) => n.type === "ImportDeclaration" && n.source.value === "eslint-plugin-svelte" && n.specifiers?.some((n2) => n2.type === "ImportDefaultSpecifier")
  );
  let svelteImportName;
  for (const specifier of sveltePluginImport?.specifiers ?? []) {
    if (specifier.type === "ImportDefaultSpecifier" && specifier.local?.name) {
      svelteImportName = specifier.local.name;
    }
  }
  svelteImportName ?? (svelteImportName = "svelte");
  imports.addDefault(ast, "eslint-plugin-svelte", svelteImportName);
  imports.addDefault(ast, "eslint-config-prettier", "prettier");
  const fallbackConfig = common.expressionFromString("[]");
  const defaultExport = exports$1.defaultExport(ast, fallbackConfig);
  const eslintConfig = defaultExport.value;
  if (eslintConfig.type !== "ArrayExpression" && eslintConfig.type !== "CallExpression")
    return content;
  const prettier = common.expressionFromString("prettier");
  const sveltePrettierConfig = common.expressionFromString(
    `${svelteImportName}.configs['flat/prettier']`
  );
  const configSpread = common.createSpreadElement(sveltePrettierConfig);
  const nodesToInsert = [];
  if (!common.hasNode(eslintConfig, prettier)) nodesToInsert.push(prettier);
  if (!common.hasNode(eslintConfig, configSpread)) nodesToInsert.push(configSpread);
  const elements = eslintConfig.type == "ArrayExpression" ? eslintConfig.elements : eslintConfig.arguments;
  const idx = elements.findIndex(
    (el) => el?.type === "SpreadElement" && el.argument.type === "MemberExpression" && el.argument.object.type === "MemberExpression" && el.argument.object.property.type === "Identifier" && el.argument.object.property.name === "configs" && el.argument.object.object.type === "Identifier" && el.argument.object.object.name === svelteImportName
  );
  if (idx !== -1) {
    elements.splice(idx + 1, 0, ...nodesToInsert);
  } else {
    elements.push(...nodesToInsert);
  }
  return generateCode();
}
function addToDemoPage(content, path) {
  const { template, generateCode } = parseSvelte(content);
  for (const node of template.ast.childNodes) {
    if (node.type === "tag" && node.attribs["href"] === `/demo/${path}`) {
      return content;
    }
  }
  const newLine = template.source ? "\n" : "";
  const src = template.source + `${newLine}<a href="/demo/${path}">${path}</a>`;
  return generateCode({ template: src });
}

var eslint = defineAddon({
  id: "eslint",
  shortDescription: "linter",
  homepage: "https://eslint.org",
  options: {},
  run: ({ sv, typescript, dependencyVersion }) => {
    const prettierInstalled = Boolean(dependencyVersion("prettier"));
    sv.devDependency("eslint", "^9.7.0");
    sv.devDependency("globals", "^15.0.0");
    sv.devDependency("eslint-plugin-svelte", "^2.36.0");
    if (typescript) sv.devDependency("typescript-eslint", "^8.0.0");
    if (prettierInstalled) sv.devDependency("eslint-config-prettier", "^9.1.0");
    sv.file("package.json", (content) => {
      const { data, generateCode } = parseJson(content);
      data.scripts ?? (data.scripts = {});
      const scripts = data.scripts;
      const LINT_CMD = "eslint .";
      scripts["lint"] ?? (scripts["lint"] = LINT_CMD);
      if (!scripts["lint"].includes(LINT_CMD)) scripts["lint"] += ` && ${LINT_CMD}`;
      return generateCode();
    });
    sv.file(".vscode/settings.json", (content) => {
      if (!content) return content;
      const { data, generateCode } = parseJson(content);
      const validate = data["eslint.validate"];
      if (validate && !validate.includes("svelte")) {
        validate.push("svelte");
      }
      return generateCode();
    });
    sv.file("eslint.config.js", (content) => {
      const { ast, generateCode } = parseScript(content);
      const eslintConfigs = [];
      const jsConfig = common.expressionFromString("js.configs.recommended");
      eslintConfigs.push(jsConfig);
      if (typescript) {
        const tsConfig = common.expressionFromString("ts.configs.recommended");
        eslintConfigs.push(common.createSpreadElement(tsConfig));
      }
      const svelteConfig = common.expressionFromString('svelte.configs["flat/recommended"]');
      eslintConfigs.push(common.createSpreadElement(svelteConfig));
      const globalsBrowser = common.createSpreadElement(
        common.expressionFromString("globals.browser")
      );
      const globalsNode = common.createSpreadElement(common.expressionFromString("globals.node"));
      const globalsObjLiteral = object$1.createEmpty();
      globalsObjLiteral.properties = [globalsBrowser, globalsNode];
      const globalsConfig = object$1.create({
        languageOptions: object$1.create({
          globals: globalsObjLiteral
        })
      });
      eslintConfigs.push(globalsConfig);
      if (typescript) {
        const svelteTSParserConfig = object$1.create({
          files: common.expressionFromString('["**/*.svelte"]'),
          languageOptions: object$1.create({
            parserOptions: object$1.create({
              parser: common.expressionFromString("ts.parser")
            })
          })
        });
        eslintConfigs.push(svelteTSParserConfig);
      }
      const ignoresConfig = object$1.create({
        ignores: common.expressionFromString('["build/", ".svelte-kit/", "dist/"]')
      });
      eslintConfigs.push(ignoresConfig);
      let exportExpression;
      if (typescript) {
        const tsConfigCall = _function.call("ts.config", []);
        tsConfigCall.arguments.push(...eslintConfigs);
        exportExpression = tsConfigCall;
      } else {
        const eslintArray = array$1.createEmpty();
        eslintConfigs.map((x) => array$1.push(eslintArray, x));
        exportExpression = eslintArray;
      }
      const defaultExport = exports$1.defaultExport(ast, exportExpression);
      if (defaultExport.value !== exportExpression) {
        log.warn("An eslint config is already defined. Skipping initialization.");
        return content;
      }
      if (!typescript)
        common.addJsDocTypeComment(defaultExport.astNode, "import('eslint').Linter.Config[]");
      if (typescript) imports.addDefault(ast, "typescript-eslint", "ts");
      imports.addDefault(ast, "globals", "globals");
      imports.addDefault(ast, "eslint-plugin-svelte", "svelte");
      imports.addDefault(ast, "@eslint/js", "js");
      return generateCode();
    });
    if (prettierInstalled) {
      sv.file("eslint.config.js", addEslintConfigPrettier);
    }
  }
});

const comma = ','.charCodeAt(0);
const semicolon = ';'.charCodeAt(0);
const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
const intToChar = new Uint8Array(64); // 64 possible chars.
const charToInt = new Uint8Array(128); // z is 122 in ASCII
for (let i = 0; i < chars.length; i++) {
    const c = chars.charCodeAt(i);
    intToChar[i] = c;
    charToInt[c] = i;
}
function encodeInteger(builder, num, relative) {
    let delta = num - relative;
    delta = delta < 0 ? (-delta << 1) | 1 : delta << 1;
    do {
        let clamped = delta & 0b011111;
        delta >>>= 5;
        if (delta > 0)
            clamped |= 0b100000;
        builder.write(intToChar[clamped]);
    } while (delta > 0);
    return num;
}

const bufLength = 1024 * 16;
// Provide a fallback for older environments.
const td = typeof TextDecoder !== 'undefined'
    ? /* #__PURE__ */ new TextDecoder()
    : typeof Buffer !== 'undefined'
        ? {
            decode(buf) {
                const out = Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);
                return out.toString();
            },
        }
        : {
            decode(buf) {
                let out = '';
                for (let i = 0; i < buf.length; i++) {
                    out += String.fromCharCode(buf[i]);
                }
                return out;
            },
        };
class StringWriter {
    constructor() {
        this.pos = 0;
        this.out = '';
        this.buffer = new Uint8Array(bufLength);
    }
    write(v) {
        const { buffer } = this;
        buffer[this.pos++] = v;
        if (this.pos === bufLength) {
            this.out += td.decode(buffer);
            this.pos = 0;
        }
    }
    flush() {
        const { buffer, out, pos } = this;
        return pos > 0 ? out + td.decode(buffer.subarray(0, pos)) : out;
    }
}
function encode(decoded) {
    const writer = new StringWriter();
    let sourcesIndex = 0;
    let sourceLine = 0;
    let sourceColumn = 0;
    let namesIndex = 0;
    for (let i = 0; i < decoded.length; i++) {
        const line = decoded[i];
        if (i > 0)
            writer.write(semicolon);
        if (line.length === 0)
            continue;
        let genColumn = 0;
        for (let j = 0; j < line.length; j++) {
            const segment = line[j];
            if (j > 0)
                writer.write(comma);
            genColumn = encodeInteger(writer, segment[0], genColumn);
            if (segment.length === 1)
                continue;
            sourcesIndex = encodeInteger(writer, segment[1], sourcesIndex);
            sourceLine = encodeInteger(writer, segment[2], sourceLine);
            sourceColumn = encodeInteger(writer, segment[3], sourceColumn);
            if (segment.length === 4)
                continue;
            namesIndex = encodeInteger(writer, segment[4], namesIndex);
        }
    }
    return writer.flush();
}

class BitSet {
	constructor(arg) {
		this.bits = arg instanceof BitSet ? arg.bits.slice() : [];
	}

	add(n) {
		this.bits[n >> 5] |= 1 << (n & 31);
	}

	has(n) {
		return !!(this.bits[n >> 5] & (1 << (n & 31)));
	}
}

class Chunk {
	constructor(start, end, content) {
		this.start = start;
		this.end = end;
		this.original = content;

		this.intro = '';
		this.outro = '';

		this.content = content;
		this.storeName = false;
		this.edited = false;

		{
			this.previous = null;
			this.next = null;
		}
	}

	appendLeft(content) {
		this.outro += content;
	}

	appendRight(content) {
		this.intro = this.intro + content;
	}

	clone() {
		const chunk = new Chunk(this.start, this.end, this.original);

		chunk.intro = this.intro;
		chunk.outro = this.outro;
		chunk.content = this.content;
		chunk.storeName = this.storeName;
		chunk.edited = this.edited;

		return chunk;
	}

	contains(index) {
		return this.start < index && index < this.end;
	}

	eachNext(fn) {
		let chunk = this;
		while (chunk) {
			fn(chunk);
			chunk = chunk.next;
		}
	}

	eachPrevious(fn) {
		let chunk = this;
		while (chunk) {
			fn(chunk);
			chunk = chunk.previous;
		}
	}

	edit(content, storeName, contentOnly) {
		this.content = content;
		if (!contentOnly) {
			this.intro = '';
			this.outro = '';
		}
		this.storeName = storeName;

		this.edited = true;

		return this;
	}

	prependLeft(content) {
		this.outro = content + this.outro;
	}

	prependRight(content) {
		this.intro = content + this.intro;
	}

	reset() {
		this.intro = '';
		this.outro = '';
		if (this.edited) {
			this.content = this.original;
			this.storeName = false;
			this.edited = false;
		}
	}

	split(index) {
		const sliceIndex = index - this.start;

		const originalBefore = this.original.slice(0, sliceIndex);
		const originalAfter = this.original.slice(sliceIndex);

		this.original = originalBefore;

		const newChunk = new Chunk(index, this.end, originalAfter);
		newChunk.outro = this.outro;
		this.outro = '';

		this.end = index;

		if (this.edited) {
			// after split we should save the edit content record into the correct chunk
			// to make sure sourcemap correct
			// For example:
			// '  test'.trim()
			//     split   -> '  ' + 'test'
			//   ✔️ edit    -> '' + 'test'
			//   ✖️ edit    -> 'test' + '' 
			// TODO is this block necessary?...
			newChunk.edit('', false);
			this.content = '';
		} else {
			this.content = originalBefore;
		}

		newChunk.next = this.next;
		if (newChunk.next) newChunk.next.previous = newChunk;
		newChunk.previous = this;
		this.next = newChunk;

		return newChunk;
	}

	toString() {
		return this.intro + this.content + this.outro;
	}

	trimEnd(rx) {
		this.outro = this.outro.replace(rx, '');
		if (this.outro.length) return true;

		const trimmed = this.content.replace(rx, '');

		if (trimmed.length) {
			if (trimmed !== this.content) {
				this.split(this.start + trimmed.length).edit('', undefined, true);
				if (this.edited) {
					// save the change, if it has been edited
					this.edit(trimmed, this.storeName, true);
				}
			}
			return true;
		} else {
			this.edit('', undefined, true);

			this.intro = this.intro.replace(rx, '');
			if (this.intro.length) return true;
		}
	}

	trimStart(rx) {
		this.intro = this.intro.replace(rx, '');
		if (this.intro.length) return true;

		const trimmed = this.content.replace(rx, '');

		if (trimmed.length) {
			if (trimmed !== this.content) {
				const newChunk = this.split(this.end - trimmed.length);
				if (this.edited) {
					// save the change, if it has been edited
					newChunk.edit(trimmed, this.storeName, true);
				}
				this.edit('', undefined, true);
			}
			return true;
		} else {
			this.edit('', undefined, true);

			this.outro = this.outro.replace(rx, '');
			if (this.outro.length) return true;
		}
	}
}

function getBtoa() {
	if (typeof globalThis !== 'undefined' && typeof globalThis.btoa === 'function') {
		return (str) => globalThis.btoa(unescape(encodeURIComponent(str)));
	} else if (typeof Buffer === 'function') {
		return (str) => Buffer.from(str, 'utf-8').toString('base64');
	} else {
		return () => {
			throw new Error('Unsupported environment: `window.btoa` or `Buffer` should be supported.');
		};
	}
}

const btoa = /*#__PURE__*/ getBtoa();

class SourceMap {
	constructor(properties) {
		this.version = 3;
		this.file = properties.file;
		this.sources = properties.sources;
		this.sourcesContent = properties.sourcesContent;
		this.names = properties.names;
		this.mappings = encode(properties.mappings);
		if (typeof properties.x_google_ignoreList !== 'undefined') {
			this.x_google_ignoreList = properties.x_google_ignoreList;
		}
	}

	toString() {
		return JSON.stringify(this);
	}

	toUrl() {
		return 'data:application/json;charset=utf-8;base64,' + btoa(this.toString());
	}
}

function guessIndent(code) {
	const lines = code.split('\n');

	const tabbed = lines.filter((line) => /^\t+/.test(line));
	const spaced = lines.filter((line) => /^ {2,}/.test(line));

	if (tabbed.length === 0 && spaced.length === 0) {
		return null;
	}

	// More lines tabbed than spaced? Assume tabs, and
	// default to tabs in the case of a tie (or nothing
	// to go on)
	if (tabbed.length >= spaced.length) {
		return '\t';
	}

	// Otherwise, we need to guess the multiple
	const min = spaced.reduce((previous, current) => {
		const numSpaces = /^ +/.exec(current)[0].length;
		return Math.min(numSpaces, previous);
	}, Infinity);

	return new Array(min + 1).join(' ');
}

function getRelativePath(from, to) {
	const fromParts = from.split(/[/\\]/);
	const toParts = to.split(/[/\\]/);

	fromParts.pop(); // get dirname

	while (fromParts[0] === toParts[0]) {
		fromParts.shift();
		toParts.shift();
	}

	if (fromParts.length) {
		let i = fromParts.length;
		while (i--) fromParts[i] = '..';
	}

	return fromParts.concat(toParts).join('/');
}

const toString$1 = Object.prototype.toString;

function isObject(thing) {
	return toString$1.call(thing) === '[object Object]';
}

function getLocator(source) {
	const originalLines = source.split('\n');
	const lineOffsets = [];

	for (let i = 0, pos = 0; i < originalLines.length; i++) {
		lineOffsets.push(pos);
		pos += originalLines[i].length + 1;
	}

	return function locate(index) {
		let i = 0;
		let j = lineOffsets.length;
		while (i < j) {
			const m = (i + j) >> 1;
			if (index < lineOffsets[m]) {
				j = m;
			} else {
				i = m + 1;
			}
		}
		const line = i - 1;
		const column = index - lineOffsets[line];
		return { line, column };
	};
}

const wordRegex = /\w/;

class Mappings {
	constructor(hires) {
		this.hires = hires;
		this.generatedCodeLine = 0;
		this.generatedCodeColumn = 0;
		this.raw = [];
		this.rawSegments = this.raw[this.generatedCodeLine] = [];
		this.pending = null;
	}

	addEdit(sourceIndex, content, loc, nameIndex) {
		if (content.length) {
			const contentLengthMinusOne = content.length - 1;
			let contentLineEnd = content.indexOf('\n', 0);
			let previousContentLineEnd = -1;
			// Loop through each line in the content and add a segment, but stop if the last line is empty,
			// else code afterwards would fill one line too many
			while (contentLineEnd >= 0 && contentLengthMinusOne > contentLineEnd) {
				const segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];
				if (nameIndex >= 0) {
					segment.push(nameIndex);
				}
				this.rawSegments.push(segment);

				this.generatedCodeLine += 1;
				this.raw[this.generatedCodeLine] = this.rawSegments = [];
				this.generatedCodeColumn = 0;

				previousContentLineEnd = contentLineEnd;
				contentLineEnd = content.indexOf('\n', contentLineEnd + 1);
			}

			const segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];
			if (nameIndex >= 0) {
				segment.push(nameIndex);
			}
			this.rawSegments.push(segment);

			this.advance(content.slice(previousContentLineEnd + 1));
		} else if (this.pending) {
			this.rawSegments.push(this.pending);
			this.advance(content);
		}

		this.pending = null;
	}

	addUneditedChunk(sourceIndex, chunk, original, loc, sourcemapLocations) {
		let originalCharIndex = chunk.start;
		let first = true;
		// when iterating each char, check if it's in a word boundary
		let charInHiresBoundary = false;

		while (originalCharIndex < chunk.end) {
			if (original[originalCharIndex] === '\n') {
				loc.line += 1;
				loc.column = 0;
				this.generatedCodeLine += 1;
				this.raw[this.generatedCodeLine] = this.rawSegments = [];
				this.generatedCodeColumn = 0;
				first = true;
			} else {
				if (this.hires || first || sourcemapLocations.has(originalCharIndex)) {
					const segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];

					if (this.hires === 'boundary') {
						// in hires "boundary", group segments per word boundary than per char
						if (wordRegex.test(original[originalCharIndex])) {
							// for first char in the boundary found, start the boundary by pushing a segment
							if (!charInHiresBoundary) {
								this.rawSegments.push(segment);
								charInHiresBoundary = true;
							}
						} else {
							// for non-word char, end the boundary by pushing a segment
							this.rawSegments.push(segment);
							charInHiresBoundary = false;
						}
					} else {
						this.rawSegments.push(segment);
					}
				}

				loc.column += 1;
				this.generatedCodeColumn += 1;
				first = false;
			}

			originalCharIndex += 1;
		}

		this.pending = null;
	}

	advance(str) {
		if (!str) return;

		const lines = str.split('\n');

		if (lines.length > 1) {
			for (let i = 0; i < lines.length - 1; i++) {
				this.generatedCodeLine++;
				this.raw[this.generatedCodeLine] = this.rawSegments = [];
			}
			this.generatedCodeColumn = 0;
		}

		this.generatedCodeColumn += lines[lines.length - 1].length;
	}
}

const n = '\n';

const warned = {
	insertLeft: false,
	insertRight: false,
	storeName: false,
};

class MagicString {
	constructor(string, options = {}) {
		const chunk = new Chunk(0, string.length, string);

		Object.defineProperties(this, {
			original: { writable: true, value: string },
			outro: { writable: true, value: '' },
			intro: { writable: true, value: '' },
			firstChunk: { writable: true, value: chunk },
			lastChunk: { writable: true, value: chunk },
			lastSearchedChunk: { writable: true, value: chunk },
			byStart: { writable: true, value: {} },
			byEnd: { writable: true, value: {} },
			filename: { writable: true, value: options.filename },
			indentExclusionRanges: { writable: true, value: options.indentExclusionRanges },
			sourcemapLocations: { writable: true, value: new BitSet() },
			storedNames: { writable: true, value: {} },
			indentStr: { writable: true, value: undefined },
			ignoreList: { writable: true, value: options.ignoreList },
		});

		this.byStart[0] = chunk;
		this.byEnd[string.length] = chunk;
	}

	addSourcemapLocation(char) {
		this.sourcemapLocations.add(char);
	}

	append(content) {
		if (typeof content !== 'string') throw new TypeError('outro content must be a string');

		this.outro += content;
		return this;
	}

	appendLeft(index, content) {
		if (typeof content !== 'string') throw new TypeError('inserted content must be a string');

		this._split(index);

		const chunk = this.byEnd[index];

		if (chunk) {
			chunk.appendLeft(content);
		} else {
			this.intro += content;
		}
		return this;
	}

	appendRight(index, content) {
		if (typeof content !== 'string') throw new TypeError('inserted content must be a string');

		this._split(index);

		const chunk = this.byStart[index];

		if (chunk) {
			chunk.appendRight(content);
		} else {
			this.outro += content;
		}
		return this;
	}

	clone() {
		const cloned = new MagicString(this.original, { filename: this.filename });

		let originalChunk = this.firstChunk;
		let clonedChunk = (cloned.firstChunk = cloned.lastSearchedChunk = originalChunk.clone());

		while (originalChunk) {
			cloned.byStart[clonedChunk.start] = clonedChunk;
			cloned.byEnd[clonedChunk.end] = clonedChunk;

			const nextOriginalChunk = originalChunk.next;
			const nextClonedChunk = nextOriginalChunk && nextOriginalChunk.clone();

			if (nextClonedChunk) {
				clonedChunk.next = nextClonedChunk;
				nextClonedChunk.previous = clonedChunk;

				clonedChunk = nextClonedChunk;
			}

			originalChunk = nextOriginalChunk;
		}

		cloned.lastChunk = clonedChunk;

		if (this.indentExclusionRanges) {
			cloned.indentExclusionRanges = this.indentExclusionRanges.slice();
		}

		cloned.sourcemapLocations = new BitSet(this.sourcemapLocations);

		cloned.intro = this.intro;
		cloned.outro = this.outro;

		return cloned;
	}

	generateDecodedMap(options) {
		options = options || {};

		const sourceIndex = 0;
		const names = Object.keys(this.storedNames);
		const mappings = new Mappings(options.hires);

		const locate = getLocator(this.original);

		if (this.intro) {
			mappings.advance(this.intro);
		}

		this.firstChunk.eachNext((chunk) => {
			const loc = locate(chunk.start);

			if (chunk.intro.length) mappings.advance(chunk.intro);

			if (chunk.edited) {
				mappings.addEdit(
					sourceIndex,
					chunk.content,
					loc,
					chunk.storeName ? names.indexOf(chunk.original) : -1,
				);
			} else {
				mappings.addUneditedChunk(sourceIndex, chunk, this.original, loc, this.sourcemapLocations);
			}

			if (chunk.outro.length) mappings.advance(chunk.outro);
		});

		return {
			file: options.file ? options.file.split(/[/\\]/).pop() : undefined,
			sources: [
				options.source ? getRelativePath(options.file || '', options.source) : options.file || '',
			],
			sourcesContent: options.includeContent ? [this.original] : undefined,
			names,
			mappings: mappings.raw,
			x_google_ignoreList: this.ignoreList ? [sourceIndex] : undefined,
		};
	}

	generateMap(options) {
		return new SourceMap(this.generateDecodedMap(options));
	}

	_ensureindentStr() {
		if (this.indentStr === undefined) {
			this.indentStr = guessIndent(this.original);
		}
	}

	_getRawIndentString() {
		this._ensureindentStr();
		return this.indentStr;
	}

	getIndentString() {
		this._ensureindentStr();
		return this.indentStr === null ? '\t' : this.indentStr;
	}

	indent(indentStr, options) {
		const pattern = /^[^\r\n]/gm;

		if (isObject(indentStr)) {
			options = indentStr;
			indentStr = undefined;
		}

		if (indentStr === undefined) {
			this._ensureindentStr();
			indentStr = this.indentStr || '\t';
		}

		if (indentStr === '') return this; // noop

		options = options || {};

		// Process exclusion ranges
		const isExcluded = {};

		if (options.exclude) {
			const exclusions =
				typeof options.exclude[0] === 'number' ? [options.exclude] : options.exclude;
			exclusions.forEach((exclusion) => {
				for (let i = exclusion[0]; i < exclusion[1]; i += 1) {
					isExcluded[i] = true;
				}
			});
		}

		let shouldIndentNextCharacter = options.indentStart !== false;
		const replacer = (match) => {
			if (shouldIndentNextCharacter) return `${indentStr}${match}`;
			shouldIndentNextCharacter = true;
			return match;
		};

		this.intro = this.intro.replace(pattern, replacer);

		let charIndex = 0;
		let chunk = this.firstChunk;

		while (chunk) {
			const end = chunk.end;

			if (chunk.edited) {
				if (!isExcluded[charIndex]) {
					chunk.content = chunk.content.replace(pattern, replacer);

					if (chunk.content.length) {
						shouldIndentNextCharacter = chunk.content[chunk.content.length - 1] === '\n';
					}
				}
			} else {
				charIndex = chunk.start;

				while (charIndex < end) {
					if (!isExcluded[charIndex]) {
						const char = this.original[charIndex];

						if (char === '\n') {
							shouldIndentNextCharacter = true;
						} else if (char !== '\r' && shouldIndentNextCharacter) {
							shouldIndentNextCharacter = false;

							if (charIndex === chunk.start) {
								chunk.prependRight(indentStr);
							} else {
								this._splitChunk(chunk, charIndex);
								chunk = chunk.next;
								chunk.prependRight(indentStr);
							}
						}
					}

					charIndex += 1;
				}
			}

			charIndex = chunk.end;
			chunk = chunk.next;
		}

		this.outro = this.outro.replace(pattern, replacer);

		return this;
	}

	insert() {
		throw new Error(
			'magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)',
		);
	}

	insertLeft(index, content) {
		if (!warned.insertLeft) {
			console.warn(
				'magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead',
			); // eslint-disable-line no-console
			warned.insertLeft = true;
		}

		return this.appendLeft(index, content);
	}

	insertRight(index, content) {
		if (!warned.insertRight) {
			console.warn(
				'magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead',
			); // eslint-disable-line no-console
			warned.insertRight = true;
		}

		return this.prependRight(index, content);
	}

	move(start, end, index) {
		if (index >= start && index <= end) throw new Error('Cannot move a selection inside itself');

		this._split(start);
		this._split(end);
		this._split(index);

		const first = this.byStart[start];
		const last = this.byEnd[end];

		const oldLeft = first.previous;
		const oldRight = last.next;

		const newRight = this.byStart[index];
		if (!newRight && last === this.lastChunk) return this;
		const newLeft = newRight ? newRight.previous : this.lastChunk;

		if (oldLeft) oldLeft.next = oldRight;
		if (oldRight) oldRight.previous = oldLeft;

		if (newLeft) newLeft.next = first;
		if (newRight) newRight.previous = last;

		if (!first.previous) this.firstChunk = last.next;
		if (!last.next) {
			this.lastChunk = first.previous;
			this.lastChunk.next = null;
		}

		first.previous = newLeft;
		last.next = newRight || null;

		if (!newLeft) this.firstChunk = first;
		if (!newRight) this.lastChunk = last;
		return this;
	}

	overwrite(start, end, content, options) {
		options = options || {};
		return this.update(start, end, content, { ...options, overwrite: !options.contentOnly });
	}

	update(start, end, content, options) {
		if (typeof content !== 'string') throw new TypeError('replacement content must be a string');

		if (this.original.length !== 0) {
			while (start < 0) start += this.original.length;
			while (end < 0) end += this.original.length;
		}

		if (end > this.original.length) throw new Error('end is out of bounds');
		if (start === end)
			throw new Error(
				'Cannot overwrite a zero-length range – use appendLeft or prependRight instead',
			);

		this._split(start);
		this._split(end);

		if (options === true) {
			if (!warned.storeName) {
				console.warn(
					'The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string',
				); // eslint-disable-line no-console
				warned.storeName = true;
			}

			options = { storeName: true };
		}
		const storeName = options !== undefined ? options.storeName : false;
		const overwrite = options !== undefined ? options.overwrite : false;

		if (storeName) {
			const original = this.original.slice(start, end);
			Object.defineProperty(this.storedNames, original, {
				writable: true,
				value: true,
				enumerable: true,
			});
		}

		const first = this.byStart[start];
		const last = this.byEnd[end];

		if (first) {
			let chunk = first;
			while (chunk !== last) {
				if (chunk.next !== this.byStart[chunk.end]) {
					throw new Error('Cannot overwrite across a split point');
				}
				chunk = chunk.next;
				chunk.edit('', false);
			}

			first.edit(content, storeName, !overwrite);
		} else {
			// must be inserting at the end
			const newChunk = new Chunk(start, end, '').edit(content, storeName);

			// TODO last chunk in the array may not be the last chunk, if it's moved...
			last.next = newChunk;
			newChunk.previous = last;
		}
		return this;
	}

	prepend(content) {
		if (typeof content !== 'string') throw new TypeError('outro content must be a string');

		this.intro = content + this.intro;
		return this;
	}

	prependLeft(index, content) {
		if (typeof content !== 'string') throw new TypeError('inserted content must be a string');

		this._split(index);

		const chunk = this.byEnd[index];

		if (chunk) {
			chunk.prependLeft(content);
		} else {
			this.intro = content + this.intro;
		}
		return this;
	}

	prependRight(index, content) {
		if (typeof content !== 'string') throw new TypeError('inserted content must be a string');

		this._split(index);

		const chunk = this.byStart[index];

		if (chunk) {
			chunk.prependRight(content);
		} else {
			this.outro = content + this.outro;
		}
		return this;
	}

	remove(start, end) {
		if (this.original.length !== 0) {
			while (start < 0) start += this.original.length;
			while (end < 0) end += this.original.length;
		}

		if (start === end) return this;

		if (start < 0 || end > this.original.length) throw new Error('Character is out of bounds');
		if (start > end) throw new Error('end must be greater than start');

		this._split(start);
		this._split(end);

		let chunk = this.byStart[start];

		while (chunk) {
			chunk.intro = '';
			chunk.outro = '';
			chunk.edit('');

			chunk = end > chunk.end ? this.byStart[chunk.end] : null;
		}
		return this;
	}

	reset(start, end) {
		if (this.original.length !== 0) {
			while (start < 0) start += this.original.length;
			while (end < 0) end += this.original.length;
		}

		if (start === end) return this;

		if (start < 0 || end > this.original.length) throw new Error('Character is out of bounds');
		if (start > end) throw new Error('end must be greater than start');

		this._split(start);
		this._split(end);

		let chunk = this.byStart[start];

		while (chunk) {
			chunk.reset();

			chunk = end > chunk.end ? this.byStart[chunk.end] : null;
		}
		return this;
	}

	lastChar() {
		if (this.outro.length) return this.outro[this.outro.length - 1];
		let chunk = this.lastChunk;
		do {
			if (chunk.outro.length) return chunk.outro[chunk.outro.length - 1];
			if (chunk.content.length) return chunk.content[chunk.content.length - 1];
			if (chunk.intro.length) return chunk.intro[chunk.intro.length - 1];
		} while ((chunk = chunk.previous));
		if (this.intro.length) return this.intro[this.intro.length - 1];
		return '';
	}

	lastLine() {
		let lineIndex = this.outro.lastIndexOf(n);
		if (lineIndex !== -1) return this.outro.substr(lineIndex + 1);
		let lineStr = this.outro;
		let chunk = this.lastChunk;
		do {
			if (chunk.outro.length > 0) {
				lineIndex = chunk.outro.lastIndexOf(n);
				if (lineIndex !== -1) return chunk.outro.substr(lineIndex + 1) + lineStr;
				lineStr = chunk.outro + lineStr;
			}

			if (chunk.content.length > 0) {
				lineIndex = chunk.content.lastIndexOf(n);
				if (lineIndex !== -1) return chunk.content.substr(lineIndex + 1) + lineStr;
				lineStr = chunk.content + lineStr;
			}

			if (chunk.intro.length > 0) {
				lineIndex = chunk.intro.lastIndexOf(n);
				if (lineIndex !== -1) return chunk.intro.substr(lineIndex + 1) + lineStr;
				lineStr = chunk.intro + lineStr;
			}
		} while ((chunk = chunk.previous));
		lineIndex = this.intro.lastIndexOf(n);
		if (lineIndex !== -1) return this.intro.substr(lineIndex + 1) + lineStr;
		return this.intro + lineStr;
	}

	slice(start = 0, end = this.original.length) {
		if (this.original.length !== 0) {
			while (start < 0) start += this.original.length;
			while (end < 0) end += this.original.length;
		}

		let result = '';

		// find start chunk
		let chunk = this.firstChunk;
		while (chunk && (chunk.start > start || chunk.end <= start)) {
			// found end chunk before start
			if (chunk.start < end && chunk.end >= end) {
				return result;
			}

			chunk = chunk.next;
		}

		if (chunk && chunk.edited && chunk.start !== start)
			throw new Error(`Cannot use replaced character ${start} as slice start anchor.`);

		const startChunk = chunk;
		while (chunk) {
			if (chunk.intro && (startChunk !== chunk || chunk.start === start)) {
				result += chunk.intro;
			}

			const containsEnd = chunk.start < end && chunk.end >= end;
			if (containsEnd && chunk.edited && chunk.end !== end)
				throw new Error(`Cannot use replaced character ${end} as slice end anchor.`);

			const sliceStart = startChunk === chunk ? start - chunk.start : 0;
			const sliceEnd = containsEnd ? chunk.content.length + end - chunk.end : chunk.content.length;

			result += chunk.content.slice(sliceStart, sliceEnd);

			if (chunk.outro && (!containsEnd || chunk.end === end)) {
				result += chunk.outro;
			}

			if (containsEnd) {
				break;
			}

			chunk = chunk.next;
		}

		return result;
	}

	// TODO deprecate this? not really very useful
	snip(start, end) {
		const clone = this.clone();
		clone.remove(0, start);
		clone.remove(end, clone.original.length);

		return clone;
	}

	_split(index) {
		if (this.byStart[index] || this.byEnd[index]) return;

		let chunk = this.lastSearchedChunk;
		const searchForward = index > chunk.end;

		while (chunk) {
			if (chunk.contains(index)) return this._splitChunk(chunk, index);

			chunk = searchForward ? this.byStart[chunk.end] : this.byEnd[chunk.start];
		}
	}

	_splitChunk(chunk, index) {
		if (chunk.edited && chunk.content.length) {
			// zero-length edited chunks are a special case (overlapping replacements)
			const loc = getLocator(this.original)(index);
			throw new Error(
				`Cannot split a chunk that has already been edited (${loc.line}:${loc.column} – "${chunk.original}")`,
			);
		}

		const newChunk = chunk.split(index);

		this.byEnd[index] = chunk;
		this.byStart[index] = newChunk;
		this.byEnd[newChunk.end] = newChunk;

		if (chunk === this.lastChunk) this.lastChunk = newChunk;

		this.lastSearchedChunk = chunk;
		return true;
	}

	toString() {
		let str = this.intro;

		let chunk = this.firstChunk;
		while (chunk) {
			str += chunk.toString();
			chunk = chunk.next;
		}

		return str + this.outro;
	}

	isEmpty() {
		let chunk = this.firstChunk;
		do {
			if (
				(chunk.intro.length && chunk.intro.trim()) ||
				(chunk.content.length && chunk.content.trim()) ||
				(chunk.outro.length && chunk.outro.trim())
			)
				return false;
		} while ((chunk = chunk.next));
		return true;
	}

	length() {
		let chunk = this.firstChunk;
		let length = 0;
		do {
			length += chunk.intro.length + chunk.content.length + chunk.outro.length;
		} while ((chunk = chunk.next));
		return length;
	}

	trimLines() {
		return this.trim('[\\r\\n]');
	}

	trim(charType) {
		return this.trimStart(charType).trimEnd(charType);
	}

	trimEndAborted(charType) {
		const rx = new RegExp((charType || '\\s') + '+$');

		this.outro = this.outro.replace(rx, '');
		if (this.outro.length) return true;

		let chunk = this.lastChunk;

		do {
			const end = chunk.end;
			const aborted = chunk.trimEnd(rx);

			// if chunk was trimmed, we have a new lastChunk
			if (chunk.end !== end) {
				if (this.lastChunk === chunk) {
					this.lastChunk = chunk.next;
				}

				this.byEnd[chunk.end] = chunk;
				this.byStart[chunk.next.start] = chunk.next;
				this.byEnd[chunk.next.end] = chunk.next;
			}

			if (aborted) return true;
			chunk = chunk.previous;
		} while (chunk);

		return false;
	}

	trimEnd(charType) {
		this.trimEndAborted(charType);
		return this;
	}
	trimStartAborted(charType) {
		const rx = new RegExp('^' + (charType || '\\s') + '+');

		this.intro = this.intro.replace(rx, '');
		if (this.intro.length) return true;

		let chunk = this.firstChunk;

		do {
			const end = chunk.end;
			const aborted = chunk.trimStart(rx);

			if (chunk.end !== end) {
				// special case...
				if (chunk === this.lastChunk) this.lastChunk = chunk.next;

				this.byEnd[chunk.end] = chunk;
				this.byStart[chunk.next.start] = chunk.next;
				this.byEnd[chunk.next.end] = chunk.next;
			}

			if (aborted) return true;
			chunk = chunk.next;
		} while (chunk);

		return false;
	}

	trimStart(charType) {
		this.trimStartAborted(charType);
		return this;
	}

	hasChanged() {
		return this.original !== this.toString();
	}

	_replaceRegexp(searchValue, replacement) {
		function getReplacement(match, str) {
			if (typeof replacement === 'string') {
				return replacement.replace(/\$(\$|&|\d+)/g, (_, i) => {
					// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace#specifying_a_string_as_a_parameter
					if (i === '$') return '$';
					if (i === '&') return match[0];
					const num = +i;
					if (num < match.length) return match[+i];
					return `$${i}`;
				});
			} else {
				return replacement(...match, match.index, str, match.groups);
			}
		}
		function matchAll(re, str) {
			let match;
			const matches = [];
			while ((match = re.exec(str))) {
				matches.push(match);
			}
			return matches;
		}
		if (searchValue.global) {
			const matches = matchAll(searchValue, this.original);
			matches.forEach((match) => {
				if (match.index != null) {
					const replacement = getReplacement(match, this.original);
					if (replacement !== match[0]) {
						this.overwrite(
							match.index,
							match.index + match[0].length,
							replacement
						);
					}
				}
			});
		} else {
			const match = this.original.match(searchValue);
			if (match && match.index != null) {
				const replacement = getReplacement(match, this.original);
				if (replacement !== match[0]) {
					this.overwrite(
						match.index,
						match.index + match[0].length,
						replacement
					);
				}
			}
		}
		return this;
	}

	_replaceString(string, replacement) {
		const { original } = this;
		const index = original.indexOf(string);

		if (index !== -1) {
			this.overwrite(index, index + string.length, replacement);
		}

		return this;
	}

	replace(searchValue, replacement) {
		if (typeof searchValue === 'string') {
			return this._replaceString(searchValue, replacement);
		}

		return this._replaceRegexp(searchValue, replacement);
	}

	_replaceAllString(string, replacement) {
		const { original } = this;
		const stringLength = string.length;
		for (
			let index = original.indexOf(string);
			index !== -1;
			index = original.indexOf(string, index + stringLength)
		) {
			const previous = original.slice(index, index + stringLength);
			if (previous !== replacement)
				this.overwrite(index, index + stringLength, replacement);
		}

		return this;
	}

	replaceAll(searchValue, replacement) {
		if (typeof searchValue === 'string') {
			return this._replaceAllString(searchValue, replacement);
		}

		if (!searchValue.global) {
			throw new TypeError(
				'MagicString.prototype.replaceAll called with a non-global RegExp argument',
			);
		}

		return this._replaceRegexp(searchValue, replacement);
	}
}

var __freeze = Object.freeze;
var __defProp$1 = Object.defineProperty;
var __template = (cooked, raw) => __freeze(__defProp$1(cooked, "raw", { value: __freeze(cooked.slice()) }));
var _a, _b;
const TABLE_TYPE = {
  mysql: "mysqlTable",
  postgresql: "pgTable",
  sqlite: "sqliteTable"
};
let drizzleDialect;
let schemaPath;
const options$3 = defineAddonOptions({
  demo: {
    type: "boolean",
    default: true,
    question: `Do you want to include a demo? ${picocolors.dim("(includes a login/register page)")}`
  }
});
var lucia = defineAddon({
  id: "lucia",
  shortDescription: "auth guide",
  homepage: "https://lucia-auth.com",
  options: options$3,
  setup: ({ kit, dependencyVersion, unsupported, dependsOn }) => {
    if (!kit) unsupported("Requires SvelteKit");
    if (!dependencyVersion("drizzle-orm")) dependsOn("drizzle");
  },
  run: ({ sv, typescript, options: options2, kit: kit$1, dependencyVersion }) => {
    const ext = typescript ? "ts" : "js";
    sv.dependency("@oslojs/crypto", "^1.0.1");
    sv.dependency("@oslojs/encoding", "^1.1.0");
    if (options2.demo) {
      sv.dependency("@node-rs/argon2", "^1.1.0");
    }
    sv.file(`drizzle.config.${ext}`, (content) => {
      const { ast, generateCode } = parseScript(content);
      const isProp = (name, node) => node.key.type === "Identifier" && node.key.name === name;
      walk$1.walk(ast, {}, {
        ObjectProperty(node) {
          if (isProp("dialect", node) && node.value.type === "StringLiteral") {
            drizzleDialect = node.value.value;
          }
          if (isProp("schema", node) && node.value.type === "StringLiteral") {
            schemaPath = node.value.value;
          }
        }
      });
      if (!drizzleDialect) {
        throw new Error("Failed to detect DB dialect in your `drizzle.config.[js|ts]` file");
      }
      if (!schemaPath) {
        throw new Error("Failed to find schema path in your `drizzle.config.[js|ts]` file");
      }
      return generateCode();
    });
    sv.file(schemaPath, (content) => {
      const { ast, generateCode } = parseScript(content);
      const createTable = (name) => _function.call(TABLE_TYPE[drizzleDialect], [name]);
      const userDecl = variables.declaration(ast, "const", "user", createTable("user"));
      const sessionDecl = variables.declaration(ast, "const", "session", createTable("session"));
      const user = exports$1.namedExport(ast, "user", userDecl);
      const session = exports$1.namedExport(ast, "session", sessionDecl);
      const userTable = getCallExpression(user);
      const sessionTable = getCallExpression(session);
      if (!userTable || !sessionTable) {
        throw new Error("failed to find call expression of `user` or `session`");
      }
      if (userTable.arguments.length === 1) {
        userTable.arguments.push(object$1.createEmpty());
      }
      if (sessionTable.arguments.length === 1) {
        sessionTable.arguments.push(object$1.createEmpty());
      }
      const userAttributes = userTable.arguments[1];
      const sessionAttributes = sessionTable.arguments[1];
      if (userAttributes?.type !== "ObjectExpression" || sessionAttributes?.type !== "ObjectExpression") {
        throw new Error("unexpected shape of `user` or `session` table definition");
      }
      if (drizzleDialect === "sqlite") {
        imports.addNamed(ast, "drizzle-orm/sqlite-core", {
          sqliteTable: "sqliteTable",
          text: "text",
          integer: "integer"
        });
        object$1.overrideProperties(userAttributes, {
          id: common.expressionFromString("text('id').primaryKey()")
        });
        if (options2.demo) {
          object$1.overrideProperties(userAttributes, {
            username: common.expressionFromString("text('username').notNull().unique()"),
            passwordHash: common.expressionFromString("text('password_hash').notNull()")
          });
        }
        object$1.overrideProperties(sessionAttributes, {
          id: common.expressionFromString("text('id').primaryKey()"),
          userId: common.expressionFromString(
            "text('user_id').notNull().references(() => user.id)"
          ),
          expiresAt: common.expressionFromString(
            "integer('expires_at', { mode: 'timestamp' }).notNull()"
          )
        });
      }
      if (drizzleDialect === "mysql") {
        imports.addNamed(ast, "drizzle-orm/mysql-core", {
          mysqlTable: "mysqlTable",
          varchar: "varchar",
          datetime: "datetime"
        });
        object$1.overrideProperties(userAttributes, {
          id: common.expressionFromString("varchar('id', { length: 255 }).primaryKey()")
        });
        if (options2.demo) {
          object$1.overrideProperties(userAttributes, {
            username: common.expressionFromString(
              "varchar('username', { length: 32 }).notNull().unique()"
            ),
            passwordHash: common.expressionFromString(
              "varchar('password_hash', { length: 255 }).notNull()"
            )
          });
        }
        object$1.overrideProperties(sessionAttributes, {
          id: common.expressionFromString("varchar('id', { length: 255 }).primaryKey()"),
          userId: common.expressionFromString(
            "varchar('user_id', { length: 255 }).notNull().references(() => user.id)"
          ),
          expiresAt: common.expressionFromString("datetime('expires_at').notNull()")
        });
      }
      if (drizzleDialect === "postgresql") {
        imports.addNamed(ast, "drizzle-orm/pg-core", {
          pgTable: "pgTable",
          text: "text",
          timestamp: "timestamp"
        });
        object$1.overrideProperties(userAttributes, {
          id: common.expressionFromString("text('id').primaryKey()")
        });
        if (options2.demo) {
          object$1.overrideProperties(userAttributes, {
            username: common.expressionFromString("text('username').notNull().unique()"),
            passwordHash: common.expressionFromString("text('password_hash').notNull()")
          });
        }
        object$1.overrideProperties(sessionAttributes, {
          id: common.expressionFromString("text('id').primaryKey()"),
          userId: common.expressionFromString(
            "text('user_id').notNull().references(() => user.id)"
          ),
          expiresAt: common.expressionFromString(
            "timestamp('expires_at', { withTimezone: true, mode: 'date' }).notNull()"
          )
        });
      }
      let code = generateCode();
      if (typescript) {
        if (!code.includes("export type Session =")) {
          code += "\n\nexport type Session = typeof session.$inferSelect;";
        }
        if (!code.includes("export type User =")) {
          code += "\n\nexport type User = typeof user.$inferSelect;";
        }
      }
      return code;
    });
    sv.file(`${kit$1?.libDirectory}/server/auth.${ext}`, (content) => {
      const { ast, generateCode } = parseScript(content);
      imports.addNamespace(ast, "$lib/server/db/schema", "table");
      imports.addNamed(ast, "$lib/server/db", { db: "db" });
      imports.addNamed(ast, "@oslojs/encoding", {
        encodeBase64url: "encodeBase64url",
        encodeHexLowerCase: "encodeHexLowerCase"
      });
      imports.addNamed(ast, "@oslojs/crypto/sha2", { sha256: "sha256" });
      imports.addNamed(ast, "drizzle-orm", { eq: "eq" });
      if (typescript) {
        imports.addNamed(ast, "@sveltejs/kit", { RequestEvent: "RequestEvent" }, true);
      }
      const ms = new MagicString(generateCode().trim());
      const [ts] = utils.createPrinter(typescript);
      if (!ms.original.includes("const DAY_IN_MS")) {
        ms.append("\n\nconst DAY_IN_MS = 1000 * 60 * 60 * 24;");
      }
      if (!ms.original.includes("export const sessionCookieName")) {
        ms.append("\n\nexport const sessionCookieName = 'auth-session';");
      }
      if (!ms.original.includes("export function generateSessionToken")) {
        const generateSessionToken = dedent`					
					export function generateSessionToken() {
						const bytes = crypto.getRandomValues(new Uint8Array(18));
						const token = encodeBase64url(bytes);
						return token;
					}`;
        ms.append(`

${generateSessionToken}`);
      }
      if (!ms.original.includes("async function createSession")) {
        const createSession = dedent`
					${ts("", "/**")}
					${ts("", " * @param {string} token")}
					${ts("", " * @param {string} userId")}
					${ts("", " */")}
					export async function createSession(token${ts(": string")}, userId${ts(": string")}) {
						const sessionId = encodeHexLowerCase(sha256(new TextEncoder().encode(token)));
						const session${ts(": table.Session")} = {
							id: sessionId,
							userId,
							expiresAt: new Date(Date.now() + DAY_IN_MS * 30)
						};
						await db.insert(table.session).values(session);
						return session;
					}`;
        ms.append(`

${createSession}`);
      }
      if (!ms.original.includes("async function validateSessionToken")) {
        const validateSessionToken = dedent`					
					${ts("", "/** @param {string} token */")}
					export async function validateSessionToken(token${ts(": string")}) {
						const sessionId = encodeHexLowerCase(sha256(new TextEncoder().encode(token)));
						const [result] = await db
							.select({
								// Adjust user table here to tweak returned data
								user: { id: table.user.id, username: table.user.username },
								session: table.session
							})
							.from(table.session)
							.innerJoin(table.user, eq(table.session.userId, table.user.id))
							.where(eq(table.session.id, sessionId));

						if (!result) {
							return { session: null, user: null };
						}
						const { session, user } = result;

						const sessionExpired = Date.now() >= session.expiresAt.getTime();
						if (sessionExpired) {
							await db.delete(table.session).where(eq(table.session.id, session.id));
							return { session: null, user: null };
						}

						const renewSession = Date.now() >= session.expiresAt.getTime() - DAY_IN_MS * 15;
						if (renewSession) {
							session.expiresAt = new Date(Date.now() + DAY_IN_MS * 30);
							await db
								.update(table.session)
								.set({ expiresAt: session.expiresAt })
								.where(eq(table.session.id, session.id));
						}

						return { session, user };
					}`;
        ms.append(`

${validateSessionToken}`);
      }
      if (typescript && !ms.original.includes("export type SessionValidationResult")) {
        const sessionType = "export type SessionValidationResult = Awaited<ReturnType<typeof validateSessionToken>>;";
        ms.append(`

${sessionType}`);
      }
      if (!ms.original.includes("async function invalidateSession")) {
        const invalidateSession = dedent`					
					${ts("", "/** @param {string} sessionId */")}
					export async function invalidateSession(sessionId${ts(": string")}) {
						await db.delete(table.session).where(eq(table.session.id, sessionId));
					}`;
        ms.append(`

${invalidateSession}`);
      }
      if (!ms.original.includes("export function setSessionTokenCookie")) {
        const setSessionTokenCookie = dedent`					
					${ts("", "/**")}
					${ts("", ' * @param {import("@sveltejs/kit").RequestEvent} event')}
					${ts("", " * @param {string} token")}
					${ts("", " * @param {Date} expiresAt")}
					${ts("", " */")}
					export function setSessionTokenCookie(event${ts(": RequestEvent")}, token${ts(": string")}, expiresAt${ts(": Date")}) {
						event.cookies.set(sessionCookieName, token, {
							expires: expiresAt,
							path: '/'
						});
					}`;
        ms.append(`

${setSessionTokenCookie}`);
      }
      if (!ms.original.includes("export function deleteSessionTokenCookie")) {
        const deleteSessionTokenCookie = dedent`					
					${ts("", '/** @param {import("@sveltejs/kit").RequestEvent} event */')}
					export function deleteSessionTokenCookie(event${ts(": RequestEvent")}) {
						event.cookies.delete(sessionCookieName, {
							path: '/'
						});
					}`;
        ms.append(`

${deleteSessionTokenCookie}`);
      }
      return ms.toString();
    });
    if (typescript) {
      sv.file("src/app.d.ts", (content) => {
        const { ast, generateCode } = parseScript(content);
        const locals = kit.addGlobalAppInterface(ast, "Locals");
        if (!locals) {
          throw new Error("Failed detecting `locals` interface in `src/app.d.ts`");
        }
        const user = locals.body.body.find((prop) => common.hasTypeProp("user", prop));
        const session = locals.body.body.find((prop) => common.hasTypeProp("session", prop));
        if (!user) {
          locals.body.body.push(createLuciaType("user"));
        }
        if (!session) {
          locals.body.body.push(createLuciaType("session"));
        }
        return generateCode();
      });
    }
    sv.file(`src/hooks.server.${ext}`, (content) => {
      const { ast, generateCode } = parseScript(content);
      imports.addNamespace(ast, "$lib/server/auth.js", "auth");
      kit.addHooksHandle(ast, typescript, "handleAuth", getAuthHandleContent());
      return generateCode();
    });
    if (options2.demo) {
      sv.file(`${kit$1?.routesDirectory}/demo/+page.svelte`, (content) => {
        return addToDemoPage(content, "lucia");
      });
      sv.file(`${kit$1.routesDirectory}/demo/lucia/login/+page.server.${ext}`, (content) => {
        if (content) {
          const filePath = `${kit$1.routesDirectory}/demo/lucia/login/+page.server.${typescript ? "ts" : "js"}`;
          log.warn(`Existing ${picocolors.yellow(filePath)} file. Could not update.`);
          return content;
        }
        const [ts] = utils.createPrinter(typescript);
        return dedent`
					import { hash, verify } from '@node-rs/argon2';
					import { encodeBase32LowerCase } from '@oslojs/encoding';
					import { fail, redirect } from '@sveltejs/kit';
					import { eq } from 'drizzle-orm';
					import * as auth from '$lib/server/auth';
					import { db } from '$lib/server/db';
					import * as table from '$lib/server/db/schema';
					${ts("import type { Actions, PageServerLoad } from './$types';\n")}
					export const load${ts(": PageServerLoad")} = async (event) => {
						if (event.locals.user) {
							return redirect(302, '/demo/lucia');
						}
						return {};
					};

					export const actions${ts(": Actions")} = {
						login: async (event) => {
							const formData = await event.request.formData();
							const username = formData.get('username');
							const password = formData.get('password');

							if (!validateUsername(username)) {
								return fail(400, { message: 'Invalid username' });
							}
							if (!validatePassword(password)) {
								return fail(400, { message: 'Invalid password' });
							}

							const results = await db
								.select()
								.from(table.user)
								.where(eq(table.user.username, username));

							const existingUser = results.at(0);
							if (!existingUser) {
								return fail(400, { message: 'Incorrect username or password' });
							}

							const validPassword = await verify(existingUser.passwordHash, password, {
								memoryCost: 19456,
								timeCost: 2,
								outputLen: 32,
								parallelism: 1,
							});
							if (!validPassword) {
								return fail(400, { message: 'Incorrect username or password' });
							}

							const sessionToken = auth.generateSessionToken();
							const session = await auth.createSession(sessionToken, existingUser.id);
							auth.setSessionTokenCookie(event, sessionToken, session.expiresAt);

							return redirect(302, '/demo/lucia');
						},
						register: async (event) => {
							const formData = await event.request.formData();
							const username = formData.get('username');
							const password = formData.get('password');

							if (!validateUsername(username)) {
								return fail(400, { message: 'Invalid username' });
							}
							if (!validatePassword(password)) {
								return fail(400, { message: 'Invalid password' });
							}

							const userId = generateUserId();
							const passwordHash = await hash(password, {
								// recommended minimum parameters
								memoryCost: 19456,
								timeCost: 2,
								outputLen: 32,
								parallelism: 1,
							});

							try {
								await db.insert(table.user).values({ id: userId, username, passwordHash });

								const sessionToken = auth.generateSessionToken();
								const session = await auth.createSession(sessionToken, userId);
								auth.setSessionTokenCookie(event, sessionToken, session.expiresAt);
							} catch (e) {
								return fail(500, { message: 'An error has occurred' });
							}
							return redirect(302, '/demo/lucia');
						},
					};

					function generateUserId() {
						// ID with 120 bits of entropy, or about the same as UUID v4.
						const bytes = crypto.getRandomValues(new Uint8Array(15));
						const id = encodeBase32LowerCase(bytes);
						return id;
					}

					function validateUsername(username${ts(": unknown")})${ts(": username is string")} {
						return (
							typeof username === 'string' &&
							username.length >= 3 &&
							username.length <= 31 &&
							/^[a-z0-9_-]+$/.test(username)
						);
					}

					function validatePassword(password${ts(": unknown")})${ts(": password is string")} {
						return (
							typeof password === 'string' &&
							password.length >= 6 &&
							password.length <= 255
						);
					}
				`;
      });
      sv.file(`${kit$1.routesDirectory}/demo/lucia/login/+page.svelte`, (content) => {
        if (content) {
          const filePath = `${kit$1.routesDirectory}/demo/lucia/login/+page.svelte`;
          log.warn(`Existing ${picocolors.yellow(filePath)} file. Could not update.`);
          return content;
        }
        const svelte5 = !!dependencyVersion("svelte")?.startsWith("5");
        const [ts, s5] = utils.createPrinter(typescript, svelte5);
        return dedent(_a || (_a = __template(["\n					<script ", ">\n						import { enhance } from '$app/forms';\n						", "\n						", "\n					<\/script>\n\n					<h1>Login/Register</h1>\n					<form method='post' action='?/login' use:enhance>\n						<label>\n							Username\n							<input name='username' />\n						</label>\n						<label>\n							Password\n							<input type='password' name='password' />\n						</label>\n						<button>Login</button>\n						<button formaction='?/register'>Register</button>\n					</form>\n					<p style='color: red'>{form?.message ?? ''}</p>\n				"])), ts("lang='ts'"), ts("import type { ActionData } from './$types';\n"), s5(`let { form }${ts(": { form: ActionData }")} = $props();`, `export let form${ts(": ActionData")};`));
      });
      sv.file(`${kit$1.routesDirectory}/demo/lucia/+page.server.${ext}`, (content) => {
        if (content) {
          const filePath = `${kit$1.routesDirectory}/demo/lucia/+page.server.${typescript ? "ts" : "js"}`;
          log.warn(`Existing ${picocolors.yellow(filePath)} file. Could not update.`);
          return content;
        }
        const [ts] = utils.createPrinter(typescript);
        return dedent`
					import * as auth from '$lib/server/auth';
					import { fail, redirect } from '@sveltejs/kit';
					${ts("import type { Actions, PageServerLoad } from './$types';\n")}
					export const load${ts(": PageServerLoad")} = async (event) => {
						if (!event.locals.user) {
							return redirect(302, '/demo/lucia/login');
						}
						return { user: event.locals.user };
					};

					export const actions${ts(": Actions")} = {
						logout: async (event) => {
							if (!event.locals.session) {
								return fail(401);
							}
							await auth.invalidateSession(event.locals.session.id);
							auth.deleteSessionTokenCookie(event);

							return redirect(302, '/demo/lucia/login');
						},
					};
				`;
      });
      sv.file(`${kit$1.routesDirectory}/demo/lucia/+page.svelte`, (content) => {
        if (content) {
          const filePath = `${kit$1.routesDirectory}/demo/lucia/+page.svelte`;
          log.warn(`Existing ${picocolors.yellow(filePath)} file. Could not update.`);
          return content;
        }
        const svelte5 = !!dependencyVersion("svelte")?.startsWith("5");
        const [ts, s5] = utils.createPrinter(typescript, svelte5);
        return dedent(_b || (_b = __template(["\n					<script ", ">\n						import { enhance } from '$app/forms';\n						", "\n						", "\n					<\/script>\n\n					<h1>Hi, {data.user.username}!</h1>\n					<p>Your user ID is {data.user.id}.</p>\n					<form method='post' action='?/logout' use:enhance>\n						<button>Sign out</button>\n					</form>\n				"])), ts("lang='ts'"), ts("import type { PageServerData } from './$types';\n"), s5(`let { data }${ts(": { data: PageServerData }")} = $props();`, `export let data${ts(": PageServerData")};`));
      });
    }
  },
  nextSteps: ({ highlighter, options: options2, packageManager }) => {
    const steps = [
      `Run ${highlighter.command(`${packageManager} run db:push`)} to update your database schema`
    ];
    if (options2.demo) {
      steps.push(`Visit ${highlighter.route("/demo/lucia")} route to view the demo`);
    }
    return steps;
  }
});
function createLuciaType(name) {
  return {
    type: "TSPropertySignature",
    key: {
      type: "Identifier",
      name
    },
    typeAnnotation: {
      type: "TSTypeAnnotation",
      typeAnnotation: {
        type: "TSIndexedAccessType",
        objectType: {
          type: "TSImportType",
          argument: { type: "StringLiteral", value: "$lib/server/auth" },
          qualifier: {
            type: "Identifier",
            name: "SessionValidationResult"
          }
        },
        indexType: {
          type: "TSLiteralType",
          literal: {
            type: "StringLiteral",
            value: name
          }
        }
      }
    }
  };
}
function getAuthHandleContent() {
  return `
		async ({ event, resolve }) => {
			const sessionToken = event.cookies.get(auth.sessionCookieName);
			if (!sessionToken) {
				event.locals.user = null;
				event.locals.session = null;
				return resolve(event);
			}

			const { session, user } = await auth.validateSessionToken(sessionToken);
			if (session) {
				auth.setSessionTokenCookie(event, sessionToken, session.expiresAt);
			} else {
				auth.deleteSessionTokenCookie(event);
			}

			event.locals.user = user;
			event.locals.session = session;

			return resolve(event);
		};`;
}
function getCallExpression(ast) {
  let callExpression;
  walk$1.walk(ast, {}, {
    CallExpression(node) {
      callExpression ?? (callExpression = node);
    }
  });
  return callExpression;
}

var mdsvex = defineAddon({
  id: "mdsvex",
  shortDescription: "svelte + markdown",
  homepage: "https://mdsvex.pngwn.io",
  options: {},
  run: ({ sv }) => {
    sv.devDependency("mdsvex", "^0.11.2");
    sv.file("svelte.config.js", (content) => {
      const { ast, generateCode } = parseScript(content);
      imports.addNamed(ast, "mdsvex", { mdsvex: "mdsvex" });
      const { value: exportDefault } = exports$1.defaultExport(ast, object$1.createEmpty());
      let preprocessorArray = object$1.property(exportDefault, "preprocess", array$1.createEmpty());
      const isArray = preprocessorArray.type === "ArrayExpression";
      if (!isArray) {
        const previousElement = preprocessorArray;
        preprocessorArray = array$1.createEmpty();
        array$1.push(preprocessorArray, previousElement);
        object$1.overrideProperty(exportDefault, "preprocess", preprocessorArray);
      }
      const mdsvexCall = _function.call("mdsvex", []);
      array$1.push(preprocessorArray, mdsvexCall);
      const extensionsArray = object$1.property(exportDefault, "extensions", array$1.createEmpty());
      array$1.push(extensionsArray, ".svelte");
      array$1.push(extensionsArray, ".svx");
      return generateCode();
    });
  }
});

function element(tagName, attributes = {}) {
  const element2 = new Element(tagName, {}, void 0, index.Tag);
  element2.attribs = attributes;
  return element2;
}
function appendElement(childNodes, elementToAppend) {
  childNodes.push(elementToAppend);
}
function addFromRawHtml(childNodes, html) {
  const document = parseHtml(html);
  for (const childNode of document.childNodes) {
    childNodes.push(childNode);
  }
}
function addSlot(jsAst, htmlAst, svelteVersion) {
  const slotSyntax = svelteVersion && (svelteVersion.startsWith("4") || svelteVersion.startsWith("3"));
  if (slotSyntax) {
    const slot = element("slot");
    appendElement(htmlAst.childNodes, slot);
    return;
  }
  addFromString(jsAst, "let { children } = $props();");
  addFromRawHtml(htmlAst.childNodes, "{@render children()}");
}

const DEFAULT_INLANG_PROJECT = {
  $schema: "https://inlang.com/schema/project-settings",
  modules: [
    "https://cdn.jsdelivr.net/npm/@inlang/message-lint-rule-empty-pattern@1/dist/index.js",
    "https://cdn.jsdelivr.net/npm/@inlang/message-lint-rule-identical-pattern@1/dist/index.js",
    "https://cdn.jsdelivr.net/npm/@inlang/message-lint-rule-missing-translation@1/dist/index.js",
    "https://cdn.jsdelivr.net/npm/@inlang/message-lint-rule-without-source@1/dist/index.js",
    "https://cdn.jsdelivr.net/npm/@inlang/message-lint-rule-valid-js-identifier@1/dist/index.js",
    "https://cdn.jsdelivr.net/npm/@inlang/plugin-message-format@2/dist/index.js",
    "https://cdn.jsdelivr.net/npm/@inlang/plugin-m-function-matcher@0/dist/index.js"
  ],
  "plugin.inlang.messageFormat": {
    pathPattern: "./messages/{languageTag}.json"
  }
};
const options$2 = defineAddonOptions({
  availableLanguageTags: {
    question: `Which languages would you like to support? ${picocolors.gray("(e.g. en,de-ch)")}`,
    type: "string",
    default: "en",
    validate(input) {
      const { invalidLanguageTags, validLanguageTags } = parseLanguageTagInput(input);
      if (invalidLanguageTags.length > 0) {
        if (invalidLanguageTags.length === 1) {
          return `The input "${invalidLanguageTags[0]}" is not a valid IETF BCP 47 language tag`;
        } else {
          const listFormat = new Intl.ListFormat("en", { style: "long", type: "conjunction" });
          return `The inputs ${listFormat.format(invalidLanguageTags.map((x) => `"${x}"`))} are not valid BCP47 language tags`;
        }
      }
      if (validLanguageTags.length === 0)
        return "Please enter at least one valid BCP47 language tag. Eg: en";
      return void 0;
    }
  },
  demo: {
    type: "boolean",
    default: true,
    question: "Do you want to include a demo?"
  }
});
var paraglide = defineAddon({
  id: "paraglide",
  shortDescription: "i18n",
  homepage: "https://inlang.com",
  options: options$2,
  setup: ({ kit, unsupported }) => {
    if (!kit) unsupported("Requires SvelteKit");
  },
  run: ({ sv, options: options2, typescript, kit: kit$1, dependencyVersion }) => {
    const ext = typescript ? "ts" : "js";
    if (!kit$1) throw new Error("SvelteKit is required");
    sv.dependency("@inlang/paraglide-sveltekit", "^0.11.1");
    sv.file("project.inlang/settings.json", (content) => {
      if (content) return content;
      const { data, generateCode } = parseJson(content);
      for (const key in DEFAULT_INLANG_PROJECT) {
        data[key] = DEFAULT_INLANG_PROJECT[key];
      }
      const { validLanguageTags: validLanguageTags2 } = parseLanguageTagInput(options2.availableLanguageTags);
      const sourceLanguageTag = validLanguageTags2[0];
      data.sourceLanguageTag = sourceLanguageTag;
      data.languageTags = validLanguageTags2;
      return generateCode();
    });
    sv.file(`vite.config.${ext}`, (content) => {
      const { ast, generateCode } = parseScript(content);
      const vitePluginName = "paraglide";
      imports.addNamed(ast, "@inlang/paraglide-sveltekit/vite", { paraglide: vitePluginName });
      const { value: rootObject } = exports$1.defaultExport(ast, _function.call("defineConfig", []));
      const param1 = _function.argumentByIndex(rootObject, 0, object$1.createEmpty());
      const pluginsArray = object$1.property(param1, "plugins", array$1.createEmpty());
      const pluginFunctionCall = _function.call(vitePluginName, []);
      const pluginConfig = object$1.create({
        project: common.createLiteral("./project.inlang"),
        outdir: common.createLiteral("./src/lib/paraglide")
      });
      _function.argumentByIndex(pluginFunctionCall, 0, pluginConfig);
      array$1.push(pluginsArray, pluginFunctionCall);
      return generateCode();
    });
    sv.file(`src/lib/i18n.${ext}`, (content) => {
      const { ast, generateCode } = parseScript(content);
      imports.addNamed(ast, "@inlang/paraglide-sveltekit", { createI18n: "createI18n" });
      imports.addDefault(ast, "$lib/paraglide/runtime", "* as runtime");
      const createI18nExpression = common.expressionFromString("createI18n(runtime)");
      const i18n = variables.declaration(ast, "const", "i18n", createI18nExpression);
      const existingExport = exports$1.namedExport(ast, "i18n", i18n);
      if (existingExport.declaration !== i18n) {
        log.warn("Setting up $lib/i18n failed because it already exports an i18n function");
      }
      return generateCode();
    });
    sv.file(`src/hooks.${ext}`, (content) => {
      const { ast, generateCode } = parseScript(content);
      imports.addNamed(ast, "$lib/i18n", { i18n: "i18n" });
      const expression = common.expressionFromString("i18n.reroute()");
      const rerouteIdentifier = variables.declaration(ast, "const", "reroute", expression);
      const existingExport = exports$1.namedExport(ast, "reroute", rerouteIdentifier);
      if (existingExport.declaration !== rerouteIdentifier) {
        log.warn("Adding the reroute hook automatically failed. Add it manually");
      }
      return generateCode();
    });
    sv.file(`src/hooks.server.${ext}`, (content) => {
      const { ast, generateCode } = parseScript(content);
      imports.addNamed(ast, "$lib/i18n", { i18n: "i18n" });
      const hookHandleContent = "i18n.handle()";
      kit.addHooksHandle(ast, typescript, "handleParaglide", hookHandleContent);
      return generateCode();
    });
    sv.file(`${kit$1.routesDirectory}/+layout.svelte`, (content) => {
      const { script, template, generateCode } = parseSvelte(content, { typescript });
      const paraglideComponentName = "ParaglideJS";
      imports.addNamed(script.ast, "@inlang/paraglide-sveltekit", {
        [paraglideComponentName]: paraglideComponentName
      });
      imports.addNamed(script.ast, "$lib/i18n", { i18n: "i18n" });
      if (template.source.length === 0) {
        const svelteVersion = dependencyVersion("svelte");
        if (!svelteVersion) throw new Error("Failed to determine svelte version");
        addSlot(script.ast, template.ast, svelteVersion);
      }
      const templateCode = new MagicString(template.generateCode());
      if (!templateCode.original.includes("<ParaglideJS")) {
        templateCode.indent();
        templateCode.prepend("<ParaglideJS {i18n}>\n");
        templateCode.append("\n</ParaglideJS>");
      }
      return generateCode({ script: script.generateCode(), template: templateCode.toString() });
    });
    sv.file("src/app.html", (content) => {
      const { ast, generateCode } = parseHtml$1(content);
      const htmlNode = ast.children.find(
        (child) => child.type === index.Tag && child.name === "html"
      );
      if (!htmlNode) {
        log.warn(
          "Could not find <html> node in app.html. You'll need to add the language placeholder manually"
        );
        return generateCode();
      }
      htmlNode.attribs = {
        ...htmlNode.attribs,
        lang: "%paraglide.lang%",
        dir: "%paraglide.textDirection%"
      };
      return generateCode();
    });
    if (options2.demo) {
      sv.file(`${kit$1.routesDirectory}/demo/+page.svelte`, (content) => {
        return addToDemoPage(content, "paraglide");
      });
      sv.file(`${kit$1.routesDirectory}/demo/paraglide/+page.svelte`, (content) => {
        const { script, template, generateCode } = parseSvelte(content, { typescript });
        imports.addDefault(script.ast, "$lib/paraglide/messages.js", "* as m");
        imports.addNamed(script.ast, "$app/navigation", { goto: "goto" });
        imports.addNamed(script.ast, "$app/stores", { page: "page" });
        imports.addNamed(script.ast, "$lib/i18n", { i18n: "i18n" });
        if (typescript) {
          imports.addNamed(
            script.ast,
            "$lib/paraglide/runtime",
            { AvailableLanguageTag: "AvailableLanguageTag" },
            true
          );
        }
        const [ts] = utils.createPrinter(typescript);
        const scriptCode = new MagicString(script.generateCode());
        if (!scriptCode.original.includes("function switchToLanguage")) {
          scriptCode.trim();
          scriptCode.append("\n\n");
          scriptCode.append(dedent`
						${ts("", "/**")} 
						${ts("", '* @param import("$lib/paraglide/runtime").AvailableLanguageTag newLanguage')} 
						${ts("", "*/")} 
						function switchToLanguage(newLanguage${ts(": AvailableLanguageTag")}) {
							const canonicalPath = i18n.route($page.url.pathname);
							const localisedPath = i18n.resolveRoute(canonicalPath, newLanguage);
							goto(localisedPath);
						}
					`);
        }
        const templateCode = new MagicString(template.source);
        templateCode.append("\n\n<h1>{m.hello_world({ name: 'SvelteKit User' })}</h1>\n");
        const { validLanguageTags: validLanguageTags2 } = parseLanguageTagInput(options2.availableLanguageTags);
        const links = validLanguageTags2.map(
          (x) => `${templateCode.getIndentString()}<button onclick={() => switchToLanguage('${x}')}>${x}</button>`
        ).join("\n");
        templateCode.append(`<div>
${links}
</div>`);
        return generateCode({ script: scriptCode.toString(), template: templateCode.toString() });
      });
    }
    const { validLanguageTags } = parseLanguageTagInput(options2.availableLanguageTags);
    for (const languageTag of validLanguageTags) {
      sv.file(`messages/${languageTag}.json`, (content) => {
        const { data, generateCode } = parseJson(content);
        data["$schema"] = "https://inlang.com/schema/inlang-message-format";
        data.hello_world = `Hello, {name} from ${languageTag}!`;
        return generateCode();
      });
    }
  },
  nextSteps: ({ highlighter }) => {
    const steps = [
      `Edit your messages in ${highlighter.path("messages/en.json")}`,
      "Consider installing the Sherlock IDE Extension"
    ];
    if (options$2.demo) {
      steps.push(`Visit ${highlighter.route("/demo/paraglide")} route to view the demo`);
    }
    return steps;
  }
});
const isValidLanguageTag = (languageTag) => (
  // Regex vendored in from https://github.com/opral/monorepo/blob/94c2298cc1da5378b908e4c160b0fa71a45caadb/inlang/source-code/versioned-interfaces/language-tag/src/interface.ts#L16
  RegExp(
    "^((?<grandfathered>(en-GB-oed|i-ami|i-bnn|i-default|i-enochian|i-hak|i-klingon|i-lux|i-mingo|i-navajo|i-pwn|i-tao|i-tay|i-tsu|sgn-BE-FR|sgn-BE-NL|sgn-CH-DE)|(art-lojban|cel-gaulish|no-bok|no-nyn|zh-guoyu|zh-hakka|zh-min|zh-min-nan|zh-xiang))|((?<language>([A-Za-z]{2,3}(-(?<extlang>[A-Za-z]{3}(-[A-Za-z]{3}){0,2}))?))(-(?<script>[A-Za-z]{4}))?(-(?<region>[A-Za-z]{2}|[0-9]{3}))?(-(?<variant>[A-Za-z0-9]{5,8}|[0-9][A-Za-z0-9]{3}))*))$"
  ).test(languageTag)
);
function parseLanguageTagInput(input) {
  const probablyLanguageTags = input.replace(/[,:\s]/g, " ").split(" ").filter(Boolean).map((tag) => tag.toLowerCase());
  const validLanguageTags = [];
  const invalidLanguageTags = [];
  for (const tag of probablyLanguageTags) {
    if (isValidLanguageTag(tag)) validLanguageTags.push(tag);
    else invalidLanguageTags.push(tag);
  }
  return {
    validLanguageTags,
    invalidLanguageTags
  };
}

var playwright = defineAddon({
  id: "playwright",
  shortDescription: "browser testing",
  homepage: "https://playwright.dev",
  options: {},
  run: ({ sv, typescript }) => {
    const ext = typescript ? "ts" : "js";
    sv.devDependency("@playwright/test", "^1.45.3");
    sv.file("package.json", (content) => {
      const { data, generateCode } = parseJson(content);
      data.scripts ?? (data.scripts = {});
      const scripts = data.scripts;
      const TEST_CMD = "playwright test";
      const RUN_TEST = "npm run test:e2e";
      scripts["test:e2e"] ?? (scripts["test:e2e"] = TEST_CMD);
      scripts["test"] ?? (scripts["test"] = RUN_TEST);
      if (!scripts["test"].includes(RUN_TEST)) scripts["test"] += ` && ${RUN_TEST}`;
      return generateCode();
    });
    sv.file(".gitignore", (content) => {
      if (!content) return content;
      if (content.includes("test-results")) return content;
      return "test-results\n" + content.trim();
    });
    sv.file(`e2e/demo.test.${ext}`, (content) => {
      if (content) return content;
      return dedent`
				import { expect, test } from '@playwright/test';

				test('home page has expected h1', async ({ page }) => {
					await page.goto('/');
					await expect(page.locator('h1')).toBeVisible();
				});
				`;
    });
    sv.file(`playwright.config.${ext}`, (content) => {
      const { ast, generateCode } = parseScript(content);
      const defineConfig = common.expressionFromString("defineConfig({})");
      const defaultExport = exports$1.defaultExport(ast, defineConfig);
      const config = {
        webServer: object$1.create({
          command: common.createLiteral("npm run build && npm run preview"),
          port: common.expressionFromString("4173")
        }),
        testDir: common.createLiteral("e2e")
      };
      if (defaultExport.value.type === "CallExpression" && defaultExport.value.arguments[0]?.type === "ObjectExpression") {
        imports.addNamed(ast, "@playwright/test", { defineConfig: "defineConfig" });
        object$1.properties(defaultExport.value.arguments[0], config);
      } else if (defaultExport.value.type === "ObjectExpression") {
        object$1.properties(defaultExport.value, config);
      } else {
        log.warn("Unexpected playwright config for playwright add-on. Could not update.");
      }
      return generateCode();
    });
  }
});

var prettier = defineAddon({
  id: "prettier",
  shortDescription: "formatter",
  homepage: "https://prettier.io",
  options: {},
  run: ({ sv, dependencyVersion }) => {
    sv.devDependency("prettier", "^3.3.2");
    sv.devDependency("prettier-plugin-svelte", "^3.2.6");
    sv.file(".prettierignore", (content) => {
      if (content) return content;
      return dedent`
				# Package Managers
				package-lock.json
				pnpm-lock.yaml
				yarn.lock
			`;
    });
    sv.file(".prettierrc", (content) => {
      const { data, generateCode } = parseJson(content);
      if (Object.keys(data).length === 0) {
        data.useTabs = true;
        data.singleQuote = true;
        data.trailingComma = "none";
        data.printWidth = 100;
      }
      data.plugins ?? (data.plugins = []);
      data.overrides ?? (data.overrides = []);
      const plugins = data.plugins;
      if (!plugins.includes("prettier-plugin-svelte")) {
        data.plugins.unshift("prettier-plugin-svelte");
      }
      const overrides = data.overrides;
      const override = overrides.find((o) => o?.options?.parser === "svelte");
      if (!override) {
        overrides.push({ files: "*.svelte", options: { parser: "svelte" } });
      }
      return generateCode();
    });
    const eslintVersion = dependencyVersion("eslint");
    const eslintInstalled = hasEslint(eslintVersion);
    sv.file("package.json", (content) => {
      const { data, generateCode } = parseJson(content);
      data.scripts ?? (data.scripts = {});
      const scripts = data.scripts;
      const CHECK_CMD = "prettier --check .";
      scripts["format"] ?? (scripts["format"] = "prettier --write .");
      if (eslintInstalled) {
        scripts["lint"] ?? (scripts["lint"] = `${CHECK_CMD} && eslint .`);
        if (!scripts["lint"].includes(CHECK_CMD)) scripts["lint"] += ` && ${CHECK_CMD}`;
      } else {
        scripts["lint"] ?? (scripts["lint"] = CHECK_CMD);
      }
      return generateCode();
    });
    if (eslintVersion?.startsWith(SUPPORTED_ESLINT_VERSION) === false) {
      log.warn(
        `An older major version of ${picocolors.yellow(
          "eslint"
        )} was detected. Skipping ${picocolors.yellow("eslint-config-prettier")} installation.`
      );
    }
    if (eslintInstalled) {
      sv.devDependency("eslint-config-prettier", "^9.1.0");
      sv.file("eslint.config.js", addEslintConfigPrettier);
    }
  }
});
const SUPPORTED_ESLINT_VERSION = "9";
function hasEslint(version) {
  return !!version && version.startsWith(SUPPORTED_ESLINT_VERSION);
}

var storybook = defineAddon({
  id: "storybook",
  shortDescription: "frontend workshop",
  homepage: "https://storybook.js.org",
  options: {},
  run: async ({ sv }) => {
    await sv.execute(["storybook@latest", "init", "--skip-install", "--no-dev"], "inherit");
  }
});

function addImports(ast, imports) {
  let prev;
  const nodes = imports.map((param) => {
    const found = ast.nodes.find(
      (x) => x.type === "atrule" && x.name === "import" && x.params === param
    );
    if (found) return prev = found;
    const rule = new AtRule2({ name: "import", params: param });
    if (prev) ast.insertAfter(prev, rule);
    else ast.prepend(rule);
    return prev = rule;
  });
  return nodes;
}

const plugins = [
  {
    id: "typography",
    package: "@tailwindcss/typography",
    version: "^0.5.15",
    identifier: "typography"
  },
  {
    id: "forms",
    package: "@tailwindcss/forms",
    version: "^0.5.9",
    identifier: "forms"
  },
  {
    id: "container-queries",
    package: "@tailwindcss/container-queries",
    version: "^0.1.1",
    identifier: "containerQueries"
  }
];
const options$1 = defineAddonOptions({
  plugins: {
    type: "multiselect",
    question: "Which plugins would you like to add?",
    options: plugins.map((p) => ({ value: p.id, label: p.id, hint: p.package })),
    default: []
  }
});
var tailwindcss = defineAddon({
  id: "tailwindcss",
  alias: "tailwind",
  shortDescription: "css framework",
  homepage: "https://tailwindcss.com",
  options: options$1,
  run: ({ sv, options: options2, typescript, kit, dependencyVersion }) => {
    const ext = typescript ? "ts" : "js";
    const prettierInstalled = Boolean(dependencyVersion("prettier"));
    sv.devDependency("tailwindcss", "^3.4.9");
    sv.devDependency("autoprefixer", "^10.4.20");
    if (prettierInstalled) sv.devDependency("prettier-plugin-tailwindcss", "^0.6.5");
    for (const plugin of plugins) {
      if (!options2.plugins.includes(plugin.id)) continue;
      sv.dependency(plugin.package, plugin.version);
    }
    sv.file(`tailwind.config.${ext}`, (content) => {
      const { ast, generateCode } = parseScript(content);
      let root;
      const rootExport = object$1.createEmpty();
      if (typescript) {
        imports.addNamed(ast, "tailwindcss", { Config: "Config" }, true);
        root = common.satisfiesExpression(rootExport, "Config");
      }
      const { astNode: exportDeclaration, value: node } = exports$1.defaultExport(
        ast,
        root ?? rootExport
      );
      const config = node.type === "TSSatisfiesExpression" ? node.expression : node;
      if (config.type !== "ObjectExpression") {
        throw new Error(`Unexpected tailwind config shape: ${config.type}`);
      }
      if (!typescript) {
        common.addJsDocTypeComment(exportDeclaration, "import('tailwindcss').Config");
      }
      const contentArray = object$1.property(config, "content", array$1.createEmpty());
      array$1.push(contentArray, "./src/**/*.{html,js,svelte,ts}");
      const themeObject = object$1.property(config, "theme", object$1.createEmpty());
      object$1.property(themeObject, "extend", object$1.createEmpty());
      const pluginsArray = object$1.property(config, "plugins", array$1.createEmpty());
      for (const plugin of plugins) {
        if (!options2.plugins.includes(plugin.id)) continue;
        imports.addDefault(ast, plugin.package, plugin.identifier);
        array$1.push(pluginsArray, { type: "Identifier", name: plugin.identifier });
      }
      return generateCode();
    });
    sv.file("postcss.config.js", (content) => {
      const { ast, generateCode } = parseScript(content);
      const { value: rootObject } = exports$1.defaultExport(ast, object$1.createEmpty());
      const pluginsObject = object$1.property(rootObject, "plugins", object$1.createEmpty());
      object$1.property(pluginsObject, "tailwindcss", object$1.createEmpty());
      object$1.property(pluginsObject, "autoprefixer", object$1.createEmpty());
      return generateCode();
    });
    sv.file("src/app.css", (content) => {
      const layerImports = ["base", "components", "utilities"].map(
        (layer) => `tailwindcss/${layer}`
      );
      if (layerImports.every((i) => content.includes(i))) {
        return content;
      }
      const { ast, generateCode } = parseCss(content);
      const originalFirst = ast.first;
      const specifiers = layerImports.map((i) => `'${i}'`);
      const nodes = addImports(ast, specifiers);
      if (originalFirst !== ast.first && originalFirst?.type === "atrule" && originalFirst.name === "import") {
        originalFirst.raws.before = "\n";
      }
      nodes.shift();
      nodes.forEach((n) => n.raws.before = "\n");
      return generateCode();
    });
    if (!kit) {
      sv.file("src/App.svelte", (content) => {
        const { script, generateCode } = parseSvelte(content, { typescript });
        imports.addEmpty(script.ast, "./app.css");
        return generateCode({ script: script.generateCode() });
      });
    } else {
      sv.file(`${kit?.routesDirectory}/+layout.svelte`, (content) => {
        const { script, template, generateCode } = parseSvelte(content, { typescript });
        imports.addEmpty(script.ast, "../app.css");
        if (content.length === 0) {
          const svelteVersion = dependencyVersion("svelte");
          if (!svelteVersion) throw new Error("Failed to determine svelte version");
          addSlot(script.ast, template.ast, svelteVersion);
        }
        return generateCode({
          script: script.generateCode(),
          template: content.length === 0 ? template.generateCode() : void 0
        });
      });
    }
    if (dependencyVersion("prettier")) {
      sv.file(".prettierrc", (content) => {
        const { data, generateCode } = parseJson(content);
        const PLUGIN_NAME = "prettier-plugin-tailwindcss";
        data.plugins ?? (data.plugins = []);
        const plugins2 = data.plugins;
        if (!plugins2.includes(PLUGIN_NAME)) plugins2.push(PLUGIN_NAME);
        return generateCode();
      });
    }
  }
});

var vitest = defineAddon({
  id: "vitest",
  shortDescription: "unit testing",
  homepage: "https://vitest.dev",
  options: {},
  run: ({ sv, typescript }) => {
    const ext = typescript ? "ts" : "js";
    sv.devDependency("vitest", "^2.0.4");
    sv.file("package.json", (content) => {
      const { data, generateCode } = parseJson(content);
      data.scripts ?? (data.scripts = {});
      const scripts = data.scripts;
      const TEST_CMD = "vitest";
      const RUN_TEST = "npm run test:unit -- --run";
      scripts["test:unit"] ?? (scripts["test:unit"] = TEST_CMD);
      scripts["test"] ?? (scripts["test"] = RUN_TEST);
      if (!scripts["test"].includes(RUN_TEST)) scripts["test"] += ` && ${RUN_TEST}`;
      return generateCode();
    });
    sv.file(`src/demo.spec.${ext}`, (content) => {
      if (content) return content;
      return dedent`
				import { describe, it, expect } from 'vitest';

				describe('sum test', () => {
					it('adds 1 + 2 to equal 3', () => {
						expect(1 + 2).toBe(3);
					});
				});
			`;
    });
    sv.file(`vite.config.${ext}`, (content) => {
      const { ast, generateCode } = parseScript(content);
      const importDecls = ast.body.filter((n) => n.type === "ImportDeclaration");
      const defineConfigImportDecl = importDecls.find(
        (importDecl) => (importDecl.source.value === "vite" || importDecl.source.value === "vitest/config") && importDecl.importKind === "value" && importDecl.specifiers?.some(
          (specifier) => specifier.type === "ImportSpecifier" && specifier.imported.name === "defineConfig"
        )
      );
      if (defineConfigImportDecl?.specifiers?.length === 1) {
        const idxToRemove = ast.body.indexOf(defineConfigImportDecl);
        ast.body.splice(idxToRemove, 1);
      } else {
        const idxToRemove = defineConfigImportDecl?.specifiers?.findIndex(
          (s) => s.type === "ImportSpecifier" && s.imported.name === "defineConfig"
        );
        if (idxToRemove) defineConfigImportDecl?.specifiers?.splice(idxToRemove, 1);
      }
      const config = common.expressionFromString("defineConfig({})");
      const defaultExport = exports$1.defaultExport(ast, config);
      const test = object$1.create({
        include: common.expressionFromString("['src/**/*.{test,spec}.{js,ts}']")
      });
      if (defaultExport.value.type === "CallExpression" && defaultExport.value.arguments[0]?.type === "ObjectExpression") {
        const importSpecifier = defineConfigImportDecl?.specifiers?.find(
          (sp) => sp.type === "ImportSpecifier" && sp.imported.name === "defineConfig"
        );
        const defineConfigAlias = importSpecifier?.local?.name ?? "defineConfig";
        imports.addNamed(ast, "vitest/config", { defineConfig: defineConfigAlias });
        object$1.properties(defaultExport.value.arguments[0], { test });
      } else if (defaultExport.value.type === "ObjectExpression") {
        object$1.properties(defaultExport.value, { test });
      } else {
        log.warn("Unexpected vite config for vitest add-on. Could not update.");
      }
      return generateCode();
    });
  }
});

const officialAddons = [
  prettier,
  eslint,
  vitest,
  playwright,
  tailwindcss,
  drizzle,
  lucia,
  mdsvex,
  paraglide,
  storybook
];
function getAddonDetails(id) {
  const details = officialAddons.find((a) => a.id === id);
  if (!details) {
    throw new Error(`Invalid add-on: ${id}`);
  }
  return details;
}

function __variableDynamicImportRuntime0__(path) {
  switch (path) {
    case '../../../community-addons/unocss.ts': return import('./unocss-CQk-PWUl.js');
    case '../../../community-addons/unplugin-icons.ts': return import('./unplugin-icons-D6icB7Q_.js');
    default: return new Promise(function(resolve, reject) {
      (typeof queueMicrotask === 'function' ? queueMicrotask : setTimeout)(
        reject.bind(null, new Error("Unknown variable dynamic import: " + path))
      );
    })
   }
 }
const communityAddonIds = ["unocss","unplugin-icons"];async function getCommunityAddon(name) {
  const { default: details } = await __variableDynamicImportRuntime0__(`../../../community-addons/${name}.ts`);
  return details;
}

var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
class UnsupportedError extends Error {
  constructor(reasons) {
    super();
    __publicField(this, "name", "Unsupported Environment");
    __publicField(this, "reasons", []);
    this.reasons = reasons;
  }
}

const NO_PREFIX = "--no-";
let options = [];
function getLongFlag(flags) {
  return flags.split(",").map((f) => f.trim()).find((f) => f.startsWith("--"));
}
const helpConfig = {
  argumentDescription: formatDescription,
  optionDescription: formatDescription,
  visibleOptions(cmd) {
    options = cmd.options;
    const visible = cmd.options.filter((o) => !o.hidden);
    const show = [];
    for (const option of visible) {
      const flag = getLongFlag(option.flags);
      if (flag?.startsWith(NO_PREFIX)) {
        const stripped = flag.slice(NO_PREFIX.length);
        const isNoVariant = visible.some((o) => getLongFlag(o.flags)?.startsWith(`--${stripped}`));
        if (isNoVariant) continue;
      }
      show.push(option);
    }
    return show;
  },
  optionTerm(option) {
    const longFlag = getLongFlag(option.flags);
    const flag = longFlag?.split(" ").at(0);
    if (!flag || !longFlag) return option.flags;
    const noVariant = `--no-${flag.slice(2)}`;
    const hasVariant = options.some((o) => getLongFlag(o.flags) === noVariant);
    if (hasVariant) {
      return `--[no-]${longFlag.slice(2)}`;
    }
    return option.flags;
  }
};
function formatDescription(arg) {
  let output = arg.description;
  if (arg.defaultValue !== void 0 && String(arg.defaultValue)) {
    output += pc.dim(` (default: ${JSON.stringify(arg.defaultValue)})`);
  }
  if (arg.argChoices !== void 0 && String(arg.argChoices)) {
    output += pc.dim(` (choices: ${arg.argChoices.join(", ")})`);
  }
  return output;
}
async function runCommand(action) {
  try {
    intro(`Welcome to the Svelte CLI! ${pc.gray(`(v${pkg.version})`)}`);
    await action();
    outro("You're all set!");
  } catch (e) {
    if (e instanceof UnsupportedError) {
      const padding = getPadding(e.reasons.map((r) => r.id));
      const message = e.reasons.map((r) => `  ${r.id.padEnd(padding)}  ${pc.red(r.reason)}`).join("\n");
      log$1.error(`${e.name}

${message}`);
      log$1.message();
    } else if (e instanceof Error) {
      log$1.error(e.stack ?? String(e));
      log$1.message();
    }
    cancel("Operation failed.");
  }
}
function getPadding(lines) {
  const lengths = lines.map((s) => s.length);
  return Math.max(...lengths);
}

var tarStream = {};

var queueMicrotask_1;
var hasRequiredQueueMicrotask;

function requireQueueMicrotask () {
	if (hasRequiredQueueMicrotask) return queueMicrotask_1;
	hasRequiredQueueMicrotask = 1;
	queueMicrotask_1 = typeof queueMicrotask === 'function' ? queueMicrotask : (fn) => Promise.resolve().then(fn);
	return queueMicrotask_1;
}

var processNextTick = (typeof process !== 'undefined' && typeof process.nextTick === 'function')
  ? process.nextTick.bind(process)
  : requireQueueMicrotask();

var fixedSize = class FixedFIFO {
  constructor (hwm) {
    if (!(hwm > 0) || ((hwm - 1) & hwm) !== 0) throw new Error('Max size for a FixedFIFO should be a power of two')
    this.buffer = new Array(hwm);
    this.mask = hwm - 1;
    this.top = 0;
    this.btm = 0;
    this.next = null;
  }

  clear () {
    this.top = this.btm = 0;
    this.next = null;
    this.buffer.fill(undefined);
  }

  push (data) {
    if (this.buffer[this.top] !== undefined) return false
    this.buffer[this.top] = data;
    this.top = (this.top + 1) & this.mask;
    return true
  }

  shift () {
    const last = this.buffer[this.btm];
    if (last === undefined) return undefined
    this.buffer[this.btm] = undefined;
    this.btm = (this.btm + 1) & this.mask;
    return last
  }

  peek () {
    return this.buffer[this.btm]
  }

  isEmpty () {
    return this.buffer[this.btm] === undefined
  }
};

const FixedFIFO = fixedSize;

var fastFifo = class FastFIFO {
  constructor (hwm) {
    this.hwm = hwm || 16;
    this.head = new FixedFIFO(this.hwm);
    this.tail = this.head;
    this.length = 0;
  }

  clear () {
    this.head = this.tail;
    this.head.clear();
    this.length = 0;
  }

  push (val) {
    this.length++;
    if (!this.head.push(val)) {
      const prev = this.head;
      this.head = prev.next = new FixedFIFO(2 * this.head.buffer.length);
      this.head.push(val);
    }
  }

  shift () {
    if (this.length !== 0) this.length--;
    const val = this.tail.shift();
    if (val === undefined && this.tail.next) {
      const next = this.tail.next;
      this.tail.next = null;
      this.tail = next;
      return this.tail.shift()
    }

    return val
  }

  peek () {
    const val = this.tail.peek();
    if (val === undefined && this.tail.next) return this.tail.next.peek()
    return val
  }

  isEmpty () {
    return this.length === 0
  }
};

function isBuffer (value) {
  return Buffer.isBuffer(value) || value instanceof Uint8Array
}

function isEncoding (encoding) {
  return Buffer.isEncoding(encoding)
}

function alloc (size, fill, encoding) {
  return Buffer.alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  return Buffer.allocUnsafe(size)
}

function allocUnsafeSlow (size) {
  return Buffer.allocUnsafeSlow(size)
}

function byteLength (string, encoding) {
  return Buffer.byteLength(string, encoding)
}

function compare (a, b) {
  return Buffer.compare(a, b)
}

function concat (buffers, totalLength) {
  return Buffer.concat(buffers, totalLength)
}

function copy (source, target, targetStart, start, end) {
  return toBuffer(source).copy(target, targetStart, start, end)
}

function equals (a, b) {
  return toBuffer(a).equals(b)
}

function fill (buffer, value, offset, end, encoding) {
  return toBuffer(buffer).fill(value, offset, end, encoding)
}

function from (value, encodingOrOffset, length) {
  return Buffer.from(value, encodingOrOffset, length)
}

function includes (buffer, value, byteOffset, encoding) {
  return toBuffer(buffer).includes(value, byteOffset, encoding)
}

function indexOf$1 (buffer, value, byfeOffset, encoding) {
  return toBuffer(buffer).indexOf(value, byfeOffset, encoding)
}

function lastIndexOf (buffer, value, byteOffset, encoding) {
  return toBuffer(buffer).lastIndexOf(value, byteOffset, encoding)
}

function swap16 (buffer) {
  return toBuffer(buffer).swap16()
}

function swap32 (buffer) {
  return toBuffer(buffer).swap32()
}

function swap64 (buffer) {
  return toBuffer(buffer).swap64()
}

function toBuffer (buffer) {
  if (Buffer.isBuffer(buffer)) return buffer
  return Buffer.from(buffer.buffer, buffer.byteOffset, buffer.byteLength)
}

function toString (buffer, encoding, start, end) {
  return toBuffer(buffer).toString(encoding, start, end)
}

function write (buffer, string, offset, length, encoding) {
  return toBuffer(buffer).write(string, offset, length, encoding)
}

function writeDoubleLE (buffer, value, offset) {
  return toBuffer(buffer).writeDoubleLE(value, offset)
}

function writeFloatLE (buffer, value, offset) {
  return toBuffer(buffer).writeFloatLE(value, offset)
}

function writeUInt32LE (buffer, value, offset) {
  return toBuffer(buffer).writeUInt32LE(value, offset)
}

function writeInt32LE (buffer, value, offset) {
  return toBuffer(buffer).writeInt32LE(value, offset)
}

function readDoubleLE (buffer, offset) {
  return toBuffer(buffer).readDoubleLE(offset)
}

function readFloatLE (buffer, offset) {
  return toBuffer(buffer).readFloatLE(offset)
}

function readUInt32LE (buffer, offset) {
  return toBuffer(buffer).readUInt32LE(offset)
}

function readInt32LE (buffer, offset) {
  return toBuffer(buffer).readInt32LE(offset)
}

var b4a$5 = {
  isBuffer,
  isEncoding,
  alloc,
  allocUnsafe,
  allocUnsafeSlow,
  byteLength,
  compare,
  concat,
  copy,
  equals,
  fill,
  from,
  includes,
  indexOf: indexOf$1,
  lastIndexOf,
  swap16,
  swap32,
  swap64,
  toBuffer,
  toString,
  write,
  writeDoubleLE,
  writeFloatLE,
  writeUInt32LE,
  writeInt32LE,
  readDoubleLE,
  readFloatLE,
  readUInt32LE,
  readInt32LE
};

const b4a$4 = b4a$5;

var passThroughDecoder = class PassThroughDecoder {
  constructor (encoding) {
    this.encoding = encoding;
  }

  get remaining () {
    return 0
  }

  decode (tail) {
    return b4a$4.toString(tail, this.encoding)
  }

  flush () {
    return ''
  }
};

const b4a$3 = b4a$5;

/**
 * https://encoding.spec.whatwg.org/#utf-8-decoder
 */
var utf8Decoder = class UTF8Decoder {
  constructor () {
    this.codePoint = 0;
    this.bytesSeen = 0;
    this.bytesNeeded = 0;
    this.lowerBoundary = 0x80;
    this.upperBoundary = 0xbf;
  }

  get remaining () {
    return this.bytesSeen
  }

  decode (data) {
    // If we have a fast path, just sniff if the last part is a boundary
    if (this.bytesNeeded === 0) {
      let isBoundary = true;

      for (let i = Math.max(0, data.byteLength - 4), n = data.byteLength; i < n && isBoundary; i++) {
        isBoundary = data[i] <= 0x7f;
      }

      if (isBoundary) return b4a$3.toString(data, 'utf8')
    }

    let result = '';

    for (let i = 0, n = data.byteLength; i < n; i++) {
      const byte = data[i];

      if (this.bytesNeeded === 0) {
        if (byte <= 0x7f) {
          result += String.fromCharCode(byte);
        } else {
          this.bytesSeen = 1;

          if (byte >= 0xc2 && byte <= 0xdf) {
            this.bytesNeeded = 2;
            this.codePoint = byte & 0x1f;
          } else if (byte >= 0xe0 && byte <= 0xef) {
            if (byte === 0xe0) this.lowerBoundary = 0xa0;
            else if (byte === 0xed) this.upperBoundary = 0x9f;
            this.bytesNeeded = 3;
            this.codePoint = byte & 0xf;
          } else if (byte >= 0xf0 && byte <= 0xf4) {
            if (byte === 0xf0) this.lowerBoundary = 0x90;
            if (byte === 0xf4) this.upperBoundary = 0x8f;
            this.bytesNeeded = 4;
            this.codePoint = byte & 0x7;
          } else {
            result += '\ufffd';
          }
        }

        continue
      }

      if (byte < this.lowerBoundary || byte > this.upperBoundary) {
        this.codePoint = 0;
        this.bytesNeeded = 0;
        this.bytesSeen = 0;
        this.lowerBoundary = 0x80;
        this.upperBoundary = 0xbf;

        result += '\ufffd';

        continue
      }

      this.lowerBoundary = 0x80;
      this.upperBoundary = 0xbf;

      this.codePoint = (this.codePoint << 6) | (byte & 0x3f);
      this.bytesSeen++;

      if (this.bytesSeen !== this.bytesNeeded) continue

      result += String.fromCodePoint(this.codePoint);

      this.codePoint = 0;
      this.bytesNeeded = 0;
      this.bytesSeen = 0;
    }

    return result
  }

  flush () {
    const result = this.bytesNeeded > 0 ? '\ufffd' : '';

    this.codePoint = 0;
    this.bytesNeeded = 0;
    this.bytesSeen = 0;
    this.lowerBoundary = 0x80;
    this.upperBoundary = 0xbf;

    return result
  }
};

const PassThroughDecoder = passThroughDecoder;
const UTF8Decoder = utf8Decoder;

var textDecoder = class TextDecoder {
  constructor (encoding = 'utf8') {
    this.encoding = normalizeEncoding(encoding);

    switch (this.encoding) {
      case 'utf8':
        this.decoder = new UTF8Decoder();
        break
      case 'utf16le':
      case 'base64':
        throw new Error('Unsupported encoding: ' + this.encoding)
      default:
        this.decoder = new PassThroughDecoder(this.encoding);
    }
  }

  get remaining () {
    return this.decoder.remaining
  }

  push (data) {
    if (typeof data === 'string') return data
    return this.decoder.decode(data)
  }

  // For Node.js compatibility
  write (data) {
    return this.push(data)
  }

  end (data) {
    let result = '';
    if (data) result = this.push(data);
    result += this.decoder.flush();
    return result
  }
};

function normalizeEncoding (encoding) {
  encoding = encoding.toLowerCase();

  switch (encoding) {
    case 'utf8':
    case 'utf-8':
      return 'utf8'
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return 'utf16le'
    case 'latin1':
    case 'binary':
      return 'latin1'
    case 'base64':
    case 'ascii':
    case 'hex':
      return encoding
    default:
      throw new Error('Unknown encoding: ' + encoding)
  }
}

const { EventEmitter } = require$$5;
const STREAM_DESTROYED = new Error('Stream was destroyed');
const PREMATURE_CLOSE = new Error('Premature close');

const queueTick = processNextTick;
const FIFO$1 = fastFifo;
const TextDecoder$1 = textDecoder;

/* eslint-disable no-multi-spaces */

// 29 bits used total (4 from shared, 14 from read, and 11 from write)
const MAX = ((1 << 29) - 1);

// Shared state
const OPENING       = 0b0001;
const PREDESTROYING = 0b0010;
const DESTROYING    = 0b0100;
const DESTROYED     = 0b1000;

const NOT_OPENING = MAX ^ OPENING;
const NOT_PREDESTROYING = MAX ^ PREDESTROYING;

// Read state (4 bit offset from shared state)
const READ_ACTIVE           = 0b00000000000001 << 4;
const READ_UPDATING         = 0b00000000000010 << 4;
const READ_PRIMARY          = 0b00000000000100 << 4;
const READ_QUEUED           = 0b00000000001000 << 4;
const READ_RESUMED          = 0b00000000010000 << 4;
const READ_PIPE_DRAINED     = 0b00000000100000 << 4;
const READ_ENDING           = 0b00000001000000 << 4;
const READ_EMIT_DATA        = 0b00000010000000 << 4;
const READ_EMIT_READABLE    = 0b00000100000000 << 4;
const READ_EMITTED_READABLE = 0b00001000000000 << 4;
const READ_DONE             = 0b00010000000000 << 4;
const READ_NEXT_TICK        = 0b00100000000000 << 4;
const READ_NEEDS_PUSH       = 0b01000000000000 << 4;
const READ_READ_AHEAD       = 0b10000000000000 << 4;

// Combined read state
const READ_FLOWING = READ_RESUMED | READ_PIPE_DRAINED;
const READ_ACTIVE_AND_NEEDS_PUSH = READ_ACTIVE | READ_NEEDS_PUSH;
const READ_PRIMARY_AND_ACTIVE = READ_PRIMARY | READ_ACTIVE;
const READ_EMIT_READABLE_AND_QUEUED = READ_EMIT_READABLE | READ_QUEUED;
const READ_RESUMED_READ_AHEAD = READ_RESUMED | READ_READ_AHEAD;

const READ_NOT_ACTIVE             = MAX ^ READ_ACTIVE;
const READ_NON_PRIMARY            = MAX ^ READ_PRIMARY;
const READ_NON_PRIMARY_AND_PUSHED = MAX ^ (READ_PRIMARY | READ_NEEDS_PUSH);
const READ_PUSHED                 = MAX ^ READ_NEEDS_PUSH;
const READ_PAUSED                 = MAX ^ READ_RESUMED;
const READ_NOT_QUEUED             = MAX ^ (READ_QUEUED | READ_EMITTED_READABLE);
const READ_NOT_ENDING             = MAX ^ READ_ENDING;
const READ_PIPE_NOT_DRAINED       = MAX ^ READ_FLOWING;
const READ_NOT_NEXT_TICK          = MAX ^ READ_NEXT_TICK;
const READ_NOT_UPDATING           = MAX ^ READ_UPDATING;
const READ_NO_READ_AHEAD          = MAX ^ READ_READ_AHEAD;
const READ_PAUSED_NO_READ_AHEAD   = MAX ^ READ_RESUMED_READ_AHEAD;

// Write state (18 bit offset, 4 bit offset from shared state and 14 from read state)
const WRITE_ACTIVE     = 0b00000000001 << 18;
const WRITE_UPDATING   = 0b00000000010 << 18;
const WRITE_PRIMARY    = 0b00000000100 << 18;
const WRITE_QUEUED     = 0b00000001000 << 18;
const WRITE_UNDRAINED  = 0b00000010000 << 18;
const WRITE_DONE       = 0b00000100000 << 18;
const WRITE_EMIT_DRAIN = 0b00001000000 << 18;
const WRITE_NEXT_TICK  = 0b00010000000 << 18;
const WRITE_WRITING    = 0b00100000000 << 18;
const WRITE_FINISHING  = 0b01000000000 << 18;
const WRITE_CORKED     = 0b10000000000 << 18;

const WRITE_NOT_ACTIVE    = MAX ^ (WRITE_ACTIVE | WRITE_WRITING);
const WRITE_NON_PRIMARY   = MAX ^ WRITE_PRIMARY;
const WRITE_NOT_FINISHING = MAX ^ WRITE_FINISHING;
const WRITE_DRAINED       = MAX ^ WRITE_UNDRAINED;
const WRITE_NOT_QUEUED    = MAX ^ WRITE_QUEUED;
const WRITE_NOT_NEXT_TICK = MAX ^ WRITE_NEXT_TICK;
const WRITE_NOT_UPDATING  = MAX ^ WRITE_UPDATING;
const WRITE_NOT_CORKED    = MAX ^ WRITE_CORKED;

// Combined shared state
const ACTIVE = READ_ACTIVE | WRITE_ACTIVE;
const NOT_ACTIVE = MAX ^ ACTIVE;
const DONE = READ_DONE | WRITE_DONE;
const DESTROY_STATUS = DESTROYING | DESTROYED | PREDESTROYING;
const OPEN_STATUS = DESTROY_STATUS | OPENING;
const AUTO_DESTROY = DESTROY_STATUS | DONE;
const NON_PRIMARY = WRITE_NON_PRIMARY & READ_NON_PRIMARY;
const ACTIVE_OR_TICKING = WRITE_NEXT_TICK | READ_NEXT_TICK;
const TICKING = ACTIVE_OR_TICKING & NOT_ACTIVE;
const IS_OPENING = OPEN_STATUS | TICKING;

// Combined shared state and read state
const READ_PRIMARY_STATUS = OPEN_STATUS | READ_ENDING | READ_DONE;
const READ_STATUS = OPEN_STATUS | READ_DONE | READ_QUEUED;
const READ_ENDING_STATUS = OPEN_STATUS | READ_ENDING | READ_QUEUED;
const READ_READABLE_STATUS = OPEN_STATUS | READ_EMIT_READABLE | READ_QUEUED | READ_EMITTED_READABLE;
const SHOULD_NOT_READ = OPEN_STATUS | READ_ACTIVE | READ_ENDING | READ_DONE | READ_NEEDS_PUSH | READ_READ_AHEAD;
const READ_BACKPRESSURE_STATUS = DESTROY_STATUS | READ_ENDING | READ_DONE;
const READ_UPDATE_SYNC_STATUS = READ_UPDATING | OPEN_STATUS | READ_NEXT_TICK | READ_PRIMARY;

// Combined write state
const WRITE_PRIMARY_STATUS = OPEN_STATUS | WRITE_FINISHING | WRITE_DONE;
const WRITE_QUEUED_AND_UNDRAINED = WRITE_QUEUED | WRITE_UNDRAINED;
const WRITE_QUEUED_AND_ACTIVE = WRITE_QUEUED | WRITE_ACTIVE;
const WRITE_DRAIN_STATUS = WRITE_QUEUED | WRITE_UNDRAINED | OPEN_STATUS | WRITE_ACTIVE;
const WRITE_STATUS = OPEN_STATUS | WRITE_ACTIVE | WRITE_QUEUED | WRITE_CORKED;
const WRITE_PRIMARY_AND_ACTIVE = WRITE_PRIMARY | WRITE_ACTIVE;
const WRITE_ACTIVE_AND_WRITING = WRITE_ACTIVE | WRITE_WRITING;
const WRITE_FINISHING_STATUS = OPEN_STATUS | WRITE_FINISHING | WRITE_QUEUED_AND_ACTIVE | WRITE_DONE;
const WRITE_BACKPRESSURE_STATUS = WRITE_UNDRAINED | DESTROY_STATUS | WRITE_FINISHING | WRITE_DONE;
const WRITE_UPDATE_SYNC_STATUS = WRITE_UPDATING | OPEN_STATUS | WRITE_NEXT_TICK | WRITE_PRIMARY;

const asyncIterator = Symbol.asyncIterator || Symbol('asyncIterator');

class WritableState {
  constructor (stream, { highWaterMark = 16384, map = null, mapWritable, byteLength, byteLengthWritable } = {}) {
    this.stream = stream;
    this.queue = new FIFO$1();
    this.highWaterMark = highWaterMark;
    this.buffered = 0;
    this.error = null;
    this.pipeline = null;
    this.drains = null; // if we add more seldomly used helpers we might them into a subobject so its a single ptr
    this.byteLength = byteLengthWritable || byteLength || defaultByteLength;
    this.map = mapWritable || map;
    this.afterWrite = afterWrite.bind(this);
    this.afterUpdateNextTick = updateWriteNT.bind(this);
  }

  get ended () {
    return (this.stream._duplexState & WRITE_DONE) !== 0
  }

  push (data) {
    if (this.map !== null) data = this.map(data);

    this.buffered += this.byteLength(data);
    this.queue.push(data);

    if (this.buffered < this.highWaterMark) {
      this.stream._duplexState |= WRITE_QUEUED;
      return true
    }

    this.stream._duplexState |= WRITE_QUEUED_AND_UNDRAINED;
    return false
  }

  shift () {
    const data = this.queue.shift();

    this.buffered -= this.byteLength(data);
    if (this.buffered === 0) this.stream._duplexState &= WRITE_NOT_QUEUED;

    return data
  }

  end (data) {
    if (typeof data === 'function') this.stream.once('finish', data);
    else if (data !== undefined && data !== null) this.push(data);
    this.stream._duplexState = (this.stream._duplexState | WRITE_FINISHING) & WRITE_NON_PRIMARY;
  }

  autoBatch (data, cb) {
    const buffer = [];
    const stream = this.stream;

    buffer.push(data);
    while ((stream._duplexState & WRITE_STATUS) === WRITE_QUEUED_AND_ACTIVE) {
      buffer.push(stream._writableState.shift());
    }

    if ((stream._duplexState & OPEN_STATUS) !== 0) return cb(null)
    stream._writev(buffer, cb);
  }

  update () {
    const stream = this.stream;

    stream._duplexState |= WRITE_UPDATING;

    do {
      while ((stream._duplexState & WRITE_STATUS) === WRITE_QUEUED) {
        const data = this.shift();
        stream._duplexState |= WRITE_ACTIVE_AND_WRITING;
        stream._write(data, this.afterWrite);
      }

      if ((stream._duplexState & WRITE_PRIMARY_AND_ACTIVE) === 0) this.updateNonPrimary();
    } while (this.continueUpdate() === true)

    stream._duplexState &= WRITE_NOT_UPDATING;
  }

  updateNonPrimary () {
    const stream = this.stream;

    if ((stream._duplexState & WRITE_FINISHING_STATUS) === WRITE_FINISHING) {
      stream._duplexState = (stream._duplexState | WRITE_ACTIVE) & WRITE_NOT_FINISHING;
      stream._final(afterFinal.bind(this));
      return
    }

    if ((stream._duplexState & DESTROY_STATUS) === DESTROYING) {
      if ((stream._duplexState & ACTIVE_OR_TICKING) === 0) {
        stream._duplexState |= ACTIVE;
        stream._destroy(afterDestroy.bind(this));
      }
      return
    }

    if ((stream._duplexState & IS_OPENING) === OPENING) {
      stream._duplexState = (stream._duplexState | ACTIVE) & NOT_OPENING;
      stream._open(afterOpen.bind(this));
    }
  }

  continueUpdate () {
    if ((this.stream._duplexState & WRITE_NEXT_TICK) === 0) return false
    this.stream._duplexState &= WRITE_NOT_NEXT_TICK;
    return true
  }

  updateCallback () {
    if ((this.stream._duplexState & WRITE_UPDATE_SYNC_STATUS) === WRITE_PRIMARY) this.update();
    else this.updateNextTick();
  }

  updateNextTick () {
    if ((this.stream._duplexState & WRITE_NEXT_TICK) !== 0) return
    this.stream._duplexState |= WRITE_NEXT_TICK;
    if ((this.stream._duplexState & WRITE_UPDATING) === 0) queueTick(this.afterUpdateNextTick);
  }
}

class ReadableState {
  constructor (stream, { highWaterMark = 16384, map = null, mapReadable, byteLength, byteLengthReadable } = {}) {
    this.stream = stream;
    this.queue = new FIFO$1();
    this.highWaterMark = highWaterMark === 0 ? 1 : highWaterMark;
    this.buffered = 0;
    this.readAhead = highWaterMark > 0;
    this.error = null;
    this.pipeline = null;
    this.byteLength = byteLengthReadable || byteLength || defaultByteLength;
    this.map = mapReadable || map;
    this.pipeTo = null;
    this.afterRead = afterRead.bind(this);
    this.afterUpdateNextTick = updateReadNT.bind(this);
  }

  get ended () {
    return (this.stream._duplexState & READ_DONE) !== 0
  }

  pipe (pipeTo, cb) {
    if (this.pipeTo !== null) throw new Error('Can only pipe to one destination')
    if (typeof cb !== 'function') cb = null;

    this.stream._duplexState |= READ_PIPE_DRAINED;
    this.pipeTo = pipeTo;
    this.pipeline = new Pipeline(this.stream, pipeTo, cb);

    if (cb) this.stream.on('error', noop$5); // We already error handle this so supress crashes

    if (isStreamx(pipeTo)) {
      pipeTo._writableState.pipeline = this.pipeline;
      if (cb) pipeTo.on('error', noop$5); // We already error handle this so supress crashes
      pipeTo.on('finish', this.pipeline.finished.bind(this.pipeline)); // TODO: just call finished from pipeTo itself
    } else {
      const onerror = this.pipeline.done.bind(this.pipeline, pipeTo);
      const onclose = this.pipeline.done.bind(this.pipeline, pipeTo, null); // onclose has a weird bool arg
      pipeTo.on('error', onerror);
      pipeTo.on('close', onclose);
      pipeTo.on('finish', this.pipeline.finished.bind(this.pipeline));
    }

    pipeTo.on('drain', afterDrain.bind(this));
    this.stream.emit('piping', pipeTo);
    pipeTo.emit('pipe', this.stream);
  }

  push (data) {
    const stream = this.stream;

    if (data === null) {
      this.highWaterMark = 0;
      stream._duplexState = (stream._duplexState | READ_ENDING) & READ_NON_PRIMARY_AND_PUSHED;
      return false
    }

    if (this.map !== null) {
      data = this.map(data);
      if (data === null) {
        stream._duplexState &= READ_PUSHED;
        return this.buffered < this.highWaterMark
      }
    }

    this.buffered += this.byteLength(data);
    this.queue.push(data);

    stream._duplexState = (stream._duplexState | READ_QUEUED) & READ_PUSHED;

    return this.buffered < this.highWaterMark
  }

  shift () {
    const data = this.queue.shift();

    this.buffered -= this.byteLength(data);
    if (this.buffered === 0) this.stream._duplexState &= READ_NOT_QUEUED;
    return data
  }

  unshift (data) {
    const pending = [this.map !== null ? this.map(data) : data];
    while (this.buffered > 0) pending.push(this.shift());

    for (let i = 0; i < pending.length - 1; i++) {
      const data = pending[i];
      this.buffered += this.byteLength(data);
      this.queue.push(data);
    }

    this.push(pending[pending.length - 1]);
  }

  read () {
    const stream = this.stream;

    if ((stream._duplexState & READ_STATUS) === READ_QUEUED) {
      const data = this.shift();
      if (this.pipeTo !== null && this.pipeTo.write(data) === false) stream._duplexState &= READ_PIPE_NOT_DRAINED;
      if ((stream._duplexState & READ_EMIT_DATA) !== 0) stream.emit('data', data);
      return data
    }

    if (this.readAhead === false) {
      stream._duplexState |= READ_READ_AHEAD;
      this.updateNextTick();
    }

    return null
  }

  drain () {
    const stream = this.stream;

    while ((stream._duplexState & READ_STATUS) === READ_QUEUED && (stream._duplexState & READ_FLOWING) !== 0) {
      const data = this.shift();
      if (this.pipeTo !== null && this.pipeTo.write(data) === false) stream._duplexState &= READ_PIPE_NOT_DRAINED;
      if ((stream._duplexState & READ_EMIT_DATA) !== 0) stream.emit('data', data);
    }
  }

  update () {
    const stream = this.stream;

    stream._duplexState |= READ_UPDATING;

    do {
      this.drain();

      while (this.buffered < this.highWaterMark && (stream._duplexState & SHOULD_NOT_READ) === READ_READ_AHEAD) {
        stream._duplexState |= READ_ACTIVE_AND_NEEDS_PUSH;
        stream._read(this.afterRead);
        this.drain();
      }

      if ((stream._duplexState & READ_READABLE_STATUS) === READ_EMIT_READABLE_AND_QUEUED) {
        stream._duplexState |= READ_EMITTED_READABLE;
        stream.emit('readable');
      }

      if ((stream._duplexState & READ_PRIMARY_AND_ACTIVE) === 0) this.updateNonPrimary();
    } while (this.continueUpdate() === true)

    stream._duplexState &= READ_NOT_UPDATING;
  }

  updateNonPrimary () {
    const stream = this.stream;

    if ((stream._duplexState & READ_ENDING_STATUS) === READ_ENDING) {
      stream._duplexState = (stream._duplexState | READ_DONE) & READ_NOT_ENDING;
      stream.emit('end');
      if ((stream._duplexState & AUTO_DESTROY) === DONE) stream._duplexState |= DESTROYING;
      if (this.pipeTo !== null) this.pipeTo.end();
    }

    if ((stream._duplexState & DESTROY_STATUS) === DESTROYING) {
      if ((stream._duplexState & ACTIVE_OR_TICKING) === 0) {
        stream._duplexState |= ACTIVE;
        stream._destroy(afterDestroy.bind(this));
      }
      return
    }

    if ((stream._duplexState & IS_OPENING) === OPENING) {
      stream._duplexState = (stream._duplexState | ACTIVE) & NOT_OPENING;
      stream._open(afterOpen.bind(this));
    }
  }

  continueUpdate () {
    if ((this.stream._duplexState & READ_NEXT_TICK) === 0) return false
    this.stream._duplexState &= READ_NOT_NEXT_TICK;
    return true
  }

  updateCallback () {
    if ((this.stream._duplexState & READ_UPDATE_SYNC_STATUS) === READ_PRIMARY) this.update();
    else this.updateNextTick();
  }

  updateNextTick () {
    if ((this.stream._duplexState & READ_NEXT_TICK) !== 0) return
    this.stream._duplexState |= READ_NEXT_TICK;
    if ((this.stream._duplexState & READ_UPDATING) === 0) queueTick(this.afterUpdateNextTick);
  }
}

class TransformState {
  constructor (stream) {
    this.data = null;
    this.afterTransform = afterTransform.bind(stream);
    this.afterFinal = null;
  }
}

class Pipeline {
  constructor (src, dst, cb) {
    this.from = src;
    this.to = dst;
    this.afterPipe = cb;
    this.error = null;
    this.pipeToFinished = false;
  }

  finished () {
    this.pipeToFinished = true;
  }

  done (stream, err) {
    if (err) this.error = err;

    if (stream === this.to) {
      this.to = null;

      if (this.from !== null) {
        if ((this.from._duplexState & READ_DONE) === 0 || !this.pipeToFinished) {
          this.from.destroy(this.error || new Error('Writable stream closed prematurely'));
        }
        return
      }
    }

    if (stream === this.from) {
      this.from = null;

      if (this.to !== null) {
        if ((stream._duplexState & READ_DONE) === 0) {
          this.to.destroy(this.error || new Error('Readable stream closed before ending'));
        }
        return
      }
    }

    if (this.afterPipe !== null) this.afterPipe(this.error);
    this.to = this.from = this.afterPipe = null;
  }
}

function afterDrain () {
  this.stream._duplexState |= READ_PIPE_DRAINED;
  this.updateCallback();
}

function afterFinal (err) {
  const stream = this.stream;
  if (err) stream.destroy(err);
  if ((stream._duplexState & DESTROY_STATUS) === 0) {
    stream._duplexState |= WRITE_DONE;
    stream.emit('finish');
  }
  if ((stream._duplexState & AUTO_DESTROY) === DONE) {
    stream._duplexState |= DESTROYING;
  }

  stream._duplexState &= WRITE_NOT_ACTIVE;

  // no need to wait the extra tick here, so we short circuit that
  if ((stream._duplexState & WRITE_UPDATING) === 0) this.update();
  else this.updateNextTick();
}

function afterDestroy (err) {
  const stream = this.stream;

  if (!err && this.error !== STREAM_DESTROYED) err = this.error;
  if (err) stream.emit('error', err);
  stream._duplexState |= DESTROYED;
  stream.emit('close');

  const rs = stream._readableState;
  const ws = stream._writableState;

  if (rs !== null && rs.pipeline !== null) rs.pipeline.done(stream, err);

  if (ws !== null) {
    while (ws.drains !== null && ws.drains.length > 0) ws.drains.shift().resolve(false);
    if (ws.pipeline !== null) ws.pipeline.done(stream, err);
  }
}

function afterWrite (err) {
  const stream = this.stream;

  if (err) stream.destroy(err);
  stream._duplexState &= WRITE_NOT_ACTIVE;

  if (this.drains !== null) tickDrains(this.drains);

  if ((stream._duplexState & WRITE_DRAIN_STATUS) === WRITE_UNDRAINED) {
    stream._duplexState &= WRITE_DRAINED;
    if ((stream._duplexState & WRITE_EMIT_DRAIN) === WRITE_EMIT_DRAIN) {
      stream.emit('drain');
    }
  }

  this.updateCallback();
}

function afterRead (err) {
  if (err) this.stream.destroy(err);
  this.stream._duplexState &= READ_NOT_ACTIVE;
  if (this.readAhead === false && (this.stream._duplexState & READ_RESUMED) === 0) this.stream._duplexState &= READ_NO_READ_AHEAD;
  this.updateCallback();
}

function updateReadNT () {
  if ((this.stream._duplexState & READ_UPDATING) === 0) {
    this.stream._duplexState &= READ_NOT_NEXT_TICK;
    this.update();
  }
}

function updateWriteNT () {
  if ((this.stream._duplexState & WRITE_UPDATING) === 0) {
    this.stream._duplexState &= WRITE_NOT_NEXT_TICK;
    this.update();
  }
}

function tickDrains (drains) {
  for (let i = 0; i < drains.length; i++) {
    // drains.writes are monotonic, so if one is 0 its always the first one
    if (--drains[i].writes === 0) {
      drains.shift().resolve(true);
      i--;
    }
  }
}

function afterOpen (err) {
  const stream = this.stream;

  if (err) stream.destroy(err);

  if ((stream._duplexState & DESTROYING) === 0) {
    if ((stream._duplexState & READ_PRIMARY_STATUS) === 0) stream._duplexState |= READ_PRIMARY;
    if ((stream._duplexState & WRITE_PRIMARY_STATUS) === 0) stream._duplexState |= WRITE_PRIMARY;
    stream.emit('open');
  }

  stream._duplexState &= NOT_ACTIVE;

  if (stream._writableState !== null) {
    stream._writableState.updateCallback();
  }

  if (stream._readableState !== null) {
    stream._readableState.updateCallback();
  }
}

function afterTransform (err, data) {
  if (data !== undefined && data !== null) this.push(data);
  this._writableState.afterWrite(err);
}

function newListener (name) {
  if (this._readableState !== null) {
    if (name === 'data') {
      this._duplexState |= (READ_EMIT_DATA | READ_RESUMED_READ_AHEAD);
      this._readableState.updateNextTick();
    }
    if (name === 'readable') {
      this._duplexState |= READ_EMIT_READABLE;
      this._readableState.updateNextTick();
    }
  }

  if (this._writableState !== null) {
    if (name === 'drain') {
      this._duplexState |= WRITE_EMIT_DRAIN;
      this._writableState.updateNextTick();
    }
  }
}

class Stream extends EventEmitter {
  constructor (opts) {
    super();

    this._duplexState = 0;
    this._readableState = null;
    this._writableState = null;

    if (opts) {
      if (opts.open) this._open = opts.open;
      if (opts.destroy) this._destroy = opts.destroy;
      if (opts.predestroy) this._predestroy = opts.predestroy;
      if (opts.signal) {
        opts.signal.addEventListener('abort', abort.bind(this));
      }
    }

    this.on('newListener', newListener);
  }

  _open (cb) {
    cb(null);
  }

  _destroy (cb) {
    cb(null);
  }

  _predestroy () {
    // does nothing
  }

  get readable () {
    return this._readableState !== null ? true : undefined
  }

  get writable () {
    return this._writableState !== null ? true : undefined
  }

  get destroyed () {
    return (this._duplexState & DESTROYED) !== 0
  }

  get destroying () {
    return (this._duplexState & DESTROY_STATUS) !== 0
  }

  destroy (err) {
    if ((this._duplexState & DESTROY_STATUS) === 0) {
      if (!err) err = STREAM_DESTROYED;
      this._duplexState = (this._duplexState | DESTROYING) & NON_PRIMARY;

      if (this._readableState !== null) {
        this._readableState.highWaterMark = 0;
        this._readableState.error = err;
      }
      if (this._writableState !== null) {
        this._writableState.highWaterMark = 0;
        this._writableState.error = err;
      }

      this._duplexState |= PREDESTROYING;
      this._predestroy();
      this._duplexState &= NOT_PREDESTROYING;

      if (this._readableState !== null) this._readableState.updateNextTick();
      if (this._writableState !== null) this._writableState.updateNextTick();
    }
  }
}

let Readable$2 = class Readable extends Stream {
  constructor (opts) {
    super(opts);

    this._duplexState |= OPENING | WRITE_DONE | READ_READ_AHEAD;
    this._readableState = new ReadableState(this, opts);

    if (opts) {
      if (this._readableState.readAhead === false) this._duplexState &= READ_NO_READ_AHEAD;
      if (opts.read) this._read = opts.read;
      if (opts.eagerOpen) this._readableState.updateNextTick();
      if (opts.encoding) this.setEncoding(opts.encoding);
    }
  }

  setEncoding (encoding) {
    const dec = new TextDecoder$1(encoding);
    const map = this._readableState.map || echo$1;
    this._readableState.map = mapOrSkip;
    return this

    function mapOrSkip (data) {
      const next = dec.push(data);
      return next === '' && (data.byteLength !== 0 || dec.remaining > 0) ? null : map(next)
    }
  }

  _read (cb) {
    cb(null);
  }

  pipe (dest, cb) {
    this._readableState.updateNextTick();
    this._readableState.pipe(dest, cb);
    return dest
  }

  read () {
    this._readableState.updateNextTick();
    return this._readableState.read()
  }

  push (data) {
    this._readableState.updateNextTick();
    return this._readableState.push(data)
  }

  unshift (data) {
    this._readableState.updateNextTick();
    return this._readableState.unshift(data)
  }

  resume () {
    this._duplexState |= READ_RESUMED_READ_AHEAD;
    this._readableState.updateNextTick();
    return this
  }

  pause () {
    this._duplexState &= (this._readableState.readAhead === false ? READ_PAUSED_NO_READ_AHEAD : READ_PAUSED);
    return this
  }

  static _fromAsyncIterator (ite, opts) {
    let destroy;

    const rs = new Readable({
      ...opts,
      read (cb) {
        ite.next().then(push).then(cb.bind(null, null)).catch(cb);
      },
      predestroy () {
        destroy = ite.return();
      },
      destroy (cb) {
        if (!destroy) return cb(null)
        destroy.then(cb.bind(null, null)).catch(cb);
      }
    });

    return rs

    function push (data) {
      if (data.done) rs.push(null);
      else rs.push(data.value);
    }
  }

  static from (data, opts) {
    if (isReadStreamx(data)) return data
    if (data[asyncIterator]) return this._fromAsyncIterator(data[asyncIterator](), opts)
    if (!Array.isArray(data)) data = data === undefined ? [] : [data];

    let i = 0;
    return new Readable({
      ...opts,
      read (cb) {
        this.push(i === data.length ? null : data[i++]);
        cb(null);
      }
    })
  }

  static isBackpressured (rs) {
    return (rs._duplexState & READ_BACKPRESSURE_STATUS) !== 0 || rs._readableState.buffered >= rs._readableState.highWaterMark
  }

  static isPaused (rs) {
    return (rs._duplexState & READ_RESUMED) === 0
  }

  [asyncIterator] () {
    const stream = this;

    let error = null;
    let promiseResolve = null;
    let promiseReject = null;

    this.on('error', (err) => { error = err; });
    this.on('readable', onreadable);
    this.on('close', onclose);

    return {
      [asyncIterator] () {
        return this
      },
      next () {
        return new Promise(function (resolve, reject) {
          promiseResolve = resolve;
          promiseReject = reject;
          const data = stream.read();
          if (data !== null) ondata(data);
          else if ((stream._duplexState & DESTROYED) !== 0) ondata(null);
        })
      },
      return () {
        return destroy(null)
      },
      throw (err) {
        return destroy(err)
      }
    }

    function onreadable () {
      if (promiseResolve !== null) ondata(stream.read());
    }

    function onclose () {
      if (promiseResolve !== null) ondata(null);
    }

    function ondata (data) {
      if (promiseReject === null) return
      if (error) promiseReject(error);
      else if (data === null && (stream._duplexState & READ_DONE) === 0) promiseReject(STREAM_DESTROYED);
      else promiseResolve({ value: data, done: data === null });
      promiseReject = promiseResolve = null;
    }

    function destroy (err) {
      stream.destroy(err);
      return new Promise((resolve, reject) => {
        if (stream._duplexState & DESTROYED) return resolve({ value: undefined, done: true })
        stream.once('close', function () {
          if (err) reject(err);
          else resolve({ value: undefined, done: true });
        });
      })
    }
  }
};

let Writable$2 = class Writable extends Stream {
  constructor (opts) {
    super(opts);

    this._duplexState |= OPENING | READ_DONE;
    this._writableState = new WritableState(this, opts);

    if (opts) {
      if (opts.writev) this._writev = opts.writev;
      if (opts.write) this._write = opts.write;
      if (opts.final) this._final = opts.final;
      if (opts.eagerOpen) this._writableState.updateNextTick();
    }
  }

  cork () {
    this._duplexState |= WRITE_CORKED;
  }

  uncork () {
    this._duplexState &= WRITE_NOT_CORKED;
    this._writableState.updateNextTick();
  }

  _writev (batch, cb) {
    cb(null);
  }

  _write (data, cb) {
    this._writableState.autoBatch(data, cb);
  }

  _final (cb) {
    cb(null);
  }

  static isBackpressured (ws) {
    return (ws._duplexState & WRITE_BACKPRESSURE_STATUS) !== 0
  }

  static drained (ws) {
    if (ws.destroyed) return Promise.resolve(false)
    const state = ws._writableState;
    const pending = (isWritev(ws) ? Math.min(1, state.queue.length) : state.queue.length);
    const writes = pending + ((ws._duplexState & WRITE_WRITING) ? 1 : 0);
    if (writes === 0) return Promise.resolve(true)
    if (state.drains === null) state.drains = [];
    return new Promise((resolve) => {
      state.drains.push({ writes, resolve });
    })
  }

  write (data) {
    this._writableState.updateNextTick();
    return this._writableState.push(data)
  }

  end (data) {
    this._writableState.updateNextTick();
    this._writableState.end(data);
    return this
  }
};

class Duplex extends Readable$2 { // and Writable
  constructor (opts) {
    super(opts);

    this._duplexState = OPENING | (this._duplexState & READ_READ_AHEAD);
    this._writableState = new WritableState(this, opts);

    if (opts) {
      if (opts.writev) this._writev = opts.writev;
      if (opts.write) this._write = opts.write;
      if (opts.final) this._final = opts.final;
    }
  }

  cork () {
    this._duplexState |= WRITE_CORKED;
  }

  uncork () {
    this._duplexState &= WRITE_NOT_CORKED;
    this._writableState.updateNextTick();
  }

  _writev (batch, cb) {
    cb(null);
  }

  _write (data, cb) {
    this._writableState.autoBatch(data, cb);
  }

  _final (cb) {
    cb(null);
  }

  write (data) {
    this._writableState.updateNextTick();
    return this._writableState.push(data)
  }

  end (data) {
    this._writableState.updateNextTick();
    this._writableState.end(data);
    return this
  }
}

class Transform extends Duplex {
  constructor (opts) {
    super(opts);
    this._transformState = new TransformState(this);

    if (opts) {
      if (opts.transform) this._transform = opts.transform;
      if (opts.flush) this._flush = opts.flush;
    }
  }

  _write (data, cb) {
    if (this._readableState.buffered >= this._readableState.highWaterMark) {
      this._transformState.data = data;
    } else {
      this._transform(data, this._transformState.afterTransform);
    }
  }

  _read (cb) {
    if (this._transformState.data !== null) {
      const data = this._transformState.data;
      this._transformState.data = null;
      cb(null);
      this._transform(data, this._transformState.afterTransform);
    } else {
      cb(null);
    }
  }

  destroy (err) {
    super.destroy(err);
    if (this._transformState.data !== null) {
      this._transformState.data = null;
      this._transformState.afterTransform();
    }
  }

  _transform (data, cb) {
    cb(null, data);
  }

  _flush (cb) {
    cb(null);
  }

  _final (cb) {
    this._transformState.afterFinal = cb;
    this._flush(transformAfterFlush.bind(this));
  }
}

class PassThrough extends Transform {}

function transformAfterFlush (err, data) {
  const cb = this._transformState.afterFinal;
  if (err) return cb(err)
  if (data !== null && data !== undefined) this.push(data);
  this.push(null);
  cb(null);
}

function pipelinePromise (...streams) {
  return new Promise((resolve, reject) => {
    return pipeline(...streams, (err) => {
      if (err) return reject(err)
      resolve();
    })
  })
}

function pipeline (stream, ...streams) {
  const all = Array.isArray(stream) ? [...stream, ...streams] : [stream, ...streams];
  const done = (all.length && typeof all[all.length - 1] === 'function') ? all.pop() : null;

  if (all.length < 2) throw new Error('Pipeline requires at least 2 streams')

  let src = all[0];
  let dest = null;
  let error = null;

  for (let i = 1; i < all.length; i++) {
    dest = all[i];

    if (isStreamx(src)) {
      src.pipe(dest, onerror);
    } else {
      errorHandle(src, true, i > 1, onerror);
      src.pipe(dest);
    }

    src = dest;
  }

  if (done) {
    let fin = false;

    const autoDestroy = isStreamx(dest) || !!(dest._writableState && dest._writableState.autoDestroy);

    dest.on('error', (err) => {
      if (error === null) error = err;
    });

    dest.on('finish', () => {
      fin = true;
      if (!autoDestroy) done(error);
    });

    if (autoDestroy) {
      dest.on('close', () => done(error || (fin ? null : PREMATURE_CLOSE)));
    }
  }

  return dest

  function errorHandle (s, rd, wr, onerror) {
    s.on('error', onerror);
    s.on('close', onclose);

    function onclose () {
      if (s._readableState && !s._readableState.ended) return onerror(PREMATURE_CLOSE)
      if (wr && s._writableState && !s._writableState.ended) return onerror(PREMATURE_CLOSE)
    }
  }

  function onerror (err) {
    if (!err || error) return
    error = err;

    for (const s of all) {
      s.destroy(err);
    }
  }
}

function echo$1 (s) {
  return s
}

function isStream (stream) {
  return !!stream._readableState || !!stream._writableState
}

function isStreamx (stream) {
  return typeof stream._duplexState === 'number' && isStream(stream)
}

function isEnded (stream) {
  return !!stream._readableState && stream._readableState.ended
}

function isFinished (stream) {
  return !!stream._writableState && stream._writableState.ended
}

function getStreamError$2 (stream, opts = {}) {
  const err = (stream._readableState && stream._readableState.error) || (stream._writableState && stream._writableState.error);

  // avoid implicit errors by default
  return (!opts.all && err === STREAM_DESTROYED) ? null : err
}

function isReadStreamx (stream) {
  return isStreamx(stream) && stream.readable
}

function isTypedArray (data) {
  return typeof data === 'object' && data !== null && typeof data.byteLength === 'number'
}

function defaultByteLength (data) {
  return isTypedArray(data) ? data.byteLength : 1024
}

function noop$5 () {}

function abort () {
  this.destroy(new Error('Stream aborted.'));
}

function isWritev (s) {
  return s._writev !== Writable$2.prototype._writev && s._writev !== Duplex.prototype._writev
}

var streamx = {
  pipeline,
  pipelinePromise,
  isStream,
  isStreamx,
  isEnded,
  isFinished,
  getStreamError: getStreamError$2,
  Stream,
  Writable: Writable$2,
  Readable: Readable$2,
  Duplex,
  Transform,
  // Export PassThrough for compatibility with Node.js core's stream module
  PassThrough
};

var headers$2 = {};

const b4a$2 = b4a$5;

const ZEROS = '0000000000000000000';
const SEVENS = '7777777777777777777';
const ZERO_OFFSET = '0'.charCodeAt(0);
const USTAR_MAGIC = b4a$2.from([0x75, 0x73, 0x74, 0x61, 0x72, 0x00]); // ustar\x00
const USTAR_VER = b4a$2.from([ZERO_OFFSET, ZERO_OFFSET]);
const GNU_MAGIC = b4a$2.from([0x75, 0x73, 0x74, 0x61, 0x72, 0x20]); // ustar\x20
const GNU_VER = b4a$2.from([0x20, 0x00]);
const MASK = 0o7777;
const MAGIC_OFFSET = 257;
const VERSION_OFFSET = 263;

headers$2.decodeLongPath = function decodeLongPath (buf, encoding) {
  return decodeStr(buf, 0, buf.length, encoding)
};

headers$2.encodePax = function encodePax (opts) { // TODO: encode more stuff in pax
  let result = '';
  if (opts.name) result += addLength(' path=' + opts.name + '\n');
  if (opts.linkname) result += addLength(' linkpath=' + opts.linkname + '\n');
  const pax = opts.pax;
  if (pax) {
    for (const key in pax) {
      result += addLength(' ' + key + '=' + pax[key] + '\n');
    }
  }
  return b4a$2.from(result)
};

headers$2.decodePax = function decodePax (buf) {
  const result = {};

  while (buf.length) {
    let i = 0;
    while (i < buf.length && buf[i] !== 32) i++;
    const len = parseInt(b4a$2.toString(buf.subarray(0, i)), 10);
    if (!len) return result

    const b = b4a$2.toString(buf.subarray(i + 1, len - 1));
    const keyIndex = b.indexOf('=');
    if (keyIndex === -1) return result
    result[b.slice(0, keyIndex)] = b.slice(keyIndex + 1);

    buf = buf.subarray(len);
  }

  return result
};

headers$2.encode = function encode (opts) {
  const buf = b4a$2.alloc(512);
  let name = opts.name;
  let prefix = '';

  if (opts.typeflag === 5 && name[name.length - 1] !== '/') name += '/';
  if (b4a$2.byteLength(name) !== name.length) return null // utf-8

  while (b4a$2.byteLength(name) > 100) {
    const i = name.indexOf('/');
    if (i === -1) return null
    prefix += prefix ? '/' + name.slice(0, i) : name.slice(0, i);
    name = name.slice(i + 1);
  }

  if (b4a$2.byteLength(name) > 100 || b4a$2.byteLength(prefix) > 155) return null
  if (opts.linkname && b4a$2.byteLength(opts.linkname) > 100) return null

  b4a$2.write(buf, name);
  b4a$2.write(buf, encodeOct(opts.mode & MASK, 6), 100);
  b4a$2.write(buf, encodeOct(opts.uid, 6), 108);
  b4a$2.write(buf, encodeOct(opts.gid, 6), 116);
  encodeSize(opts.size, buf, 124);
  b4a$2.write(buf, encodeOct((opts.mtime.getTime() / 1000) | 0, 11), 136);

  buf[156] = ZERO_OFFSET + toTypeflag(opts.type);

  if (opts.linkname) b4a$2.write(buf, opts.linkname, 157);

  b4a$2.copy(USTAR_MAGIC, buf, MAGIC_OFFSET);
  b4a$2.copy(USTAR_VER, buf, VERSION_OFFSET);
  if (opts.uname) b4a$2.write(buf, opts.uname, 265);
  if (opts.gname) b4a$2.write(buf, opts.gname, 297);
  b4a$2.write(buf, encodeOct(opts.devmajor || 0, 6), 329);
  b4a$2.write(buf, encodeOct(opts.devminor || 0, 6), 337);

  if (prefix) b4a$2.write(buf, prefix, 345);

  b4a$2.write(buf, encodeOct(cksum(buf), 6), 148);

  return buf
};

headers$2.decode = function decode (buf, filenameEncoding, allowUnknownFormat) {
  let typeflag = buf[156] === 0 ? 0 : buf[156] - ZERO_OFFSET;

  let name = decodeStr(buf, 0, 100, filenameEncoding);
  const mode = decodeOct(buf, 100, 8);
  const uid = decodeOct(buf, 108, 8);
  const gid = decodeOct(buf, 116, 8);
  const size = decodeOct(buf, 124, 12);
  const mtime = decodeOct(buf, 136, 12);
  const type = toType(typeflag);
  const linkname = buf[157] === 0 ? null : decodeStr(buf, 157, 100, filenameEncoding);
  const uname = decodeStr(buf, 265, 32);
  const gname = decodeStr(buf, 297, 32);
  const devmajor = decodeOct(buf, 329, 8);
  const devminor = decodeOct(buf, 337, 8);

  const c = cksum(buf);

  // checksum is still initial value if header was null.
  if (c === 8 * 32) return null

  // valid checksum
  if (c !== decodeOct(buf, 148, 8)) throw new Error('Invalid tar header. Maybe the tar is corrupted or it needs to be gunzipped?')

  if (isUSTAR(buf)) {
    // ustar (posix) format.
    // prepend prefix, if present.
    if (buf[345]) name = decodeStr(buf, 345, 155, filenameEncoding) + '/' + name;
  } else if (isGNU(buf)) ; else {
    if (!allowUnknownFormat) {
      throw new Error('Invalid tar header: unknown format.')
    }
  }

  // to support old tar versions that use trailing / to indicate dirs
  if (typeflag === 0 && name && name[name.length - 1] === '/') typeflag = 5;

  return {
    name,
    mode,
    uid,
    gid,
    size,
    mtime: new Date(1000 * mtime),
    type,
    linkname,
    uname,
    gname,
    devmajor,
    devminor,
    pax: null
  }
};

function isUSTAR (buf) {
  return b4a$2.equals(USTAR_MAGIC, buf.subarray(MAGIC_OFFSET, MAGIC_OFFSET + 6))
}

function isGNU (buf) {
  return b4a$2.equals(GNU_MAGIC, buf.subarray(MAGIC_OFFSET, MAGIC_OFFSET + 6)) &&
    b4a$2.equals(GNU_VER, buf.subarray(VERSION_OFFSET, VERSION_OFFSET + 2))
}

function clamp (index, len, defaultValue) {
  if (typeof index !== 'number') return defaultValue
  index = ~~index; // Coerce to integer.
  if (index >= len) return len
  if (index >= 0) return index
  index += len;
  if (index >= 0) return index
  return 0
}

function toType (flag) {
  switch (flag) {
    case 0:
      return 'file'
    case 1:
      return 'link'
    case 2:
      return 'symlink'
    case 3:
      return 'character-device'
    case 4:
      return 'block-device'
    case 5:
      return 'directory'
    case 6:
      return 'fifo'
    case 7:
      return 'contiguous-file'
    case 72:
      return 'pax-header'
    case 55:
      return 'pax-global-header'
    case 27:
      return 'gnu-long-link-path'
    case 28:
    case 30:
      return 'gnu-long-path'
  }

  return null
}

function toTypeflag (flag) {
  switch (flag) {
    case 'file':
      return 0
    case 'link':
      return 1
    case 'symlink':
      return 2
    case 'character-device':
      return 3
    case 'block-device':
      return 4
    case 'directory':
      return 5
    case 'fifo':
      return 6
    case 'contiguous-file':
      return 7
    case 'pax-header':
      return 72
  }

  return 0
}

function indexOf (block, num, offset, end) {
  for (; offset < end; offset++) {
    if (block[offset] === num) return offset
  }
  return end
}

function cksum (block) {
  let sum = 8 * 32;
  for (let i = 0; i < 148; i++) sum += block[i];
  for (let j = 156; j < 512; j++) sum += block[j];
  return sum
}

function encodeOct (val, n) {
  val = val.toString(8);
  if (val.length > n) return SEVENS.slice(0, n) + ' '
  return ZEROS.slice(0, n - val.length) + val + ' '
}

function encodeSizeBin (num, buf, off) {
  buf[off] = 0x80;
  for (let i = 11; i > 0; i--) {
    buf[off + i] = num & 0xff;
    num = Math.floor(num / 0x100);
  }
}

function encodeSize (num, buf, off) {
  if (num.toString(8).length > 11) {
    encodeSizeBin(num, buf, off);
  } else {
    b4a$2.write(buf, encodeOct(num, 11), off);
  }
}

/* Copied from the node-tar repo and modified to meet
 * tar-stream coding standard.
 *
 * Source: https://github.com/npm/node-tar/blob/51b6627a1f357d2eb433e7378e5f05e83b7aa6cd/lib/header.js#L349
 */
function parse256 (buf) {
  // first byte MUST be either 80 or FF
  // 80 for positive, FF for 2's comp
  let positive;
  if (buf[0] === 0x80) positive = true;
  else if (buf[0] === 0xFF) positive = false;
  else return null

  // build up a base-256 tuple from the least sig to the highest
  const tuple = [];
  let i;
  for (i = buf.length - 1; i > 0; i--) {
    const byte = buf[i];
    if (positive) tuple.push(byte);
    else tuple.push(0xFF - byte);
  }

  let sum = 0;
  const l = tuple.length;
  for (i = 0; i < l; i++) {
    sum += tuple[i] * Math.pow(256, i);
  }

  return positive ? sum : -1 * sum
}

function decodeOct (val, offset, length) {
  val = val.subarray(offset, offset + length);
  offset = 0;

  // If prefixed with 0x80 then parse as a base-256 integer
  if (val[offset] & 0x80) {
    return parse256(val)
  } else {
    // Older versions of tar can prefix with spaces
    while (offset < val.length && val[offset] === 32) offset++;
    const end = clamp(indexOf(val, 32, offset, val.length), val.length, val.length);
    while (offset < end && val[offset] === 0) offset++;
    if (end === offset) return 0
    return parseInt(b4a$2.toString(val.subarray(offset, end)), 8)
  }
}

function decodeStr (val, offset, length, encoding) {
  return b4a$2.toString(val.subarray(offset, indexOf(val, 0, offset, offset + length)), encoding)
}

function addLength (str) {
  const len = b4a$2.byteLength(str);
  let digits = Math.floor(Math.log(len) / Math.log(10)) + 1;
  if (len + digits >= Math.pow(10, digits)) digits++;

  return (len + digits) + str
}

const { Writable: Writable$1, Readable: Readable$1, getStreamError: getStreamError$1 } = streamx;
const FIFO = fastFifo;
const b4a$1 = b4a$5;
const headers$1 = headers$2;

const EMPTY = b4a$1.alloc(0);

class BufferList {
  constructor () {
    this.buffered = 0;
    this.shifted = 0;
    this.queue = new FIFO();

    this._offset = 0;
  }

  push (buffer) {
    this.buffered += buffer.byteLength;
    this.queue.push(buffer);
  }

  shiftFirst (size) {
    return this._buffered === 0 ? null : this._next(size)
  }

  shift (size) {
    if (size > this.buffered) return null
    if (size === 0) return EMPTY

    let chunk = this._next(size);

    if (size === chunk.byteLength) return chunk // likely case

    const chunks = [chunk];

    while ((size -= chunk.byteLength) > 0) {
      chunk = this._next(size);
      chunks.push(chunk);
    }

    return b4a$1.concat(chunks)
  }

  _next (size) {
    const buf = this.queue.peek();
    const rem = buf.byteLength - this._offset;

    if (size >= rem) {
      const sub = this._offset ? buf.subarray(this._offset, buf.byteLength) : buf;
      this.queue.shift();
      this._offset = 0;
      this.buffered -= rem;
      this.shifted += rem;
      return sub
    }

    this.buffered -= size;
    this.shifted += size;

    return buf.subarray(this._offset, (this._offset += size))
  }
}

class Source extends Readable$1 {
  constructor (self, header, offset) {
    super();

    this.header = header;
    this.offset = offset;

    this._parent = self;
  }

  _read (cb) {
    if (this.header.size === 0) {
      this.push(null);
    }
    if (this._parent._stream === this) {
      this._parent._update();
    }
    cb(null);
  }

  _predestroy () {
    this._parent.destroy(getStreamError$1(this));
  }

  _detach () {
    if (this._parent._stream === this) {
      this._parent._stream = null;
      this._parent._missing = overflow$1(this.header.size);
      this._parent._update();
    }
  }

  _destroy (cb) {
    this._detach();
    cb(null);
  }
}

class Extract extends Writable$1 {
  constructor (opts) {
    super(opts);

    if (!opts) opts = {};

    this._buffer = new BufferList();
    this._offset = 0;
    this._header = null;
    this._stream = null;
    this._missing = 0;
    this._longHeader = false;
    this._callback = noop$4;
    this._locked = false;
    this._finished = false;
    this._pax = null;
    this._paxGlobal = null;
    this._gnuLongPath = null;
    this._gnuLongLinkPath = null;
    this._filenameEncoding = opts.filenameEncoding || 'utf-8';
    this._allowUnknownFormat = !!opts.allowUnknownFormat;
    this._unlockBound = this._unlock.bind(this);
  }

  _unlock (err) {
    this._locked = false;

    if (err) {
      this.destroy(err);
      this._continueWrite(err);
      return
    }

    this._update();
  }

  _consumeHeader () {
    if (this._locked) return false

    this._offset = this._buffer.shifted;

    try {
      this._header = headers$1.decode(this._buffer.shift(512), this._filenameEncoding, this._allowUnknownFormat);
    } catch (err) {
      this._continueWrite(err);
      return false
    }

    if (!this._header) return true

    switch (this._header.type) {
      case 'gnu-long-path':
      case 'gnu-long-link-path':
      case 'pax-global-header':
      case 'pax-header':
        this._longHeader = true;
        this._missing = this._header.size;
        return true
    }

    this._locked = true;
    this._applyLongHeaders();

    if (this._header.size === 0 || this._header.type === 'directory') {
      this.emit('entry', this._header, this._createStream(), this._unlockBound);
      return true
    }

    this._stream = this._createStream();
    this._missing = this._header.size;

    this.emit('entry', this._header, this._stream, this._unlockBound);
    return true
  }

  _applyLongHeaders () {
    if (this._gnuLongPath) {
      this._header.name = this._gnuLongPath;
      this._gnuLongPath = null;
    }

    if (this._gnuLongLinkPath) {
      this._header.linkname = this._gnuLongLinkPath;
      this._gnuLongLinkPath = null;
    }

    if (this._pax) {
      if (this._pax.path) this._header.name = this._pax.path;
      if (this._pax.linkpath) this._header.linkname = this._pax.linkpath;
      if (this._pax.size) this._header.size = parseInt(this._pax.size, 10);
      this._header.pax = this._pax;
      this._pax = null;
    }
  }

  _decodeLongHeader (buf) {
    switch (this._header.type) {
      case 'gnu-long-path':
        this._gnuLongPath = headers$1.decodeLongPath(buf, this._filenameEncoding);
        break
      case 'gnu-long-link-path':
        this._gnuLongLinkPath = headers$1.decodeLongPath(buf, this._filenameEncoding);
        break
      case 'pax-global-header':
        this._paxGlobal = headers$1.decodePax(buf);
        break
      case 'pax-header':
        this._pax = this._paxGlobal === null
          ? headers$1.decodePax(buf)
          : Object.assign({}, this._paxGlobal, headers$1.decodePax(buf));
        break
    }
  }

  _consumeLongHeader () {
    this._longHeader = false;
    this._missing = overflow$1(this._header.size);

    const buf = this._buffer.shift(this._header.size);

    try {
      this._decodeLongHeader(buf);
    } catch (err) {
      this._continueWrite(err);
      return false
    }

    return true
  }

  _consumeStream () {
    const buf = this._buffer.shiftFirst(this._missing);
    if (buf === null) return false

    this._missing -= buf.byteLength;
    const drained = this._stream.push(buf);

    if (this._missing === 0) {
      this._stream.push(null);
      if (drained) this._stream._detach();
      return drained && this._locked === false
    }

    return drained
  }

  _createStream () {
    return new Source(this, this._header, this._offset)
  }

  _update () {
    while (this._buffer.buffered > 0 && !this.destroying) {
      if (this._missing > 0) {
        if (this._stream !== null) {
          if (this._consumeStream() === false) return
          continue
        }

        if (this._longHeader === true) {
          if (this._missing > this._buffer.buffered) break
          if (this._consumeLongHeader() === false) return false
          continue
        }

        const ignore = this._buffer.shiftFirst(this._missing);
        if (ignore !== null) this._missing -= ignore.byteLength;
        continue
      }

      if (this._buffer.buffered < 512) break
      if (this._stream !== null || this._consumeHeader() === false) return
    }

    this._continueWrite(null);
  }

  _continueWrite (err) {
    const cb = this._callback;
    this._callback = noop$4;
    cb(err);
  }

  _write (data, cb) {
    this._callback = cb;
    this._buffer.push(data);
    this._update();
  }

  _final (cb) {
    this._finished = this._missing === 0 && this._buffer.buffered === 0;
    cb(this._finished ? null : new Error('Unexpected end of data'));
  }

  _predestroy () {
    this._continueWrite(null);
  }

  _destroy (cb) {
    if (this._stream) this._stream.destroy(getStreamError$1(this));
    cb(null);
  }

  [Symbol.asyncIterator] () {
    let error = null;

    let promiseResolve = null;
    let promiseReject = null;

    let entryStream = null;
    let entryCallback = null;

    const extract = this;

    this.on('entry', onentry);
    this.on('error', (err) => { error = err; });
    this.on('close', onclose);

    return {
      [Symbol.asyncIterator] () {
        return this
      },
      next () {
        return new Promise(onnext)
      },
      return () {
        return destroy(null)
      },
      throw (err) {
        return destroy(err)
      }
    }

    function consumeCallback (err) {
      if (!entryCallback) return
      const cb = entryCallback;
      entryCallback = null;
      cb(err);
    }

    function onnext (resolve, reject) {
      if (error) {
        return reject(error)
      }

      if (entryStream) {
        resolve({ value: entryStream, done: false });
        entryStream = null;
        return
      }

      promiseResolve = resolve;
      promiseReject = reject;

      consumeCallback(null);

      if (extract._finished && promiseResolve) {
        promiseResolve({ value: undefined, done: true });
        promiseResolve = promiseReject = null;
      }
    }

    function onentry (header, stream, callback) {
      entryCallback = callback;
      stream.on('error', noop$4); // no way around this due to tick sillyness

      if (promiseResolve) {
        promiseResolve({ value: stream, done: false });
        promiseResolve = promiseReject = null;
      } else {
        entryStream = stream;
      }
    }

    function onclose () {
      consumeCallback(error);
      if (!promiseResolve) return
      if (error) promiseReject(error);
      else promiseResolve({ value: undefined, done: true });
      promiseResolve = promiseReject = null;
    }

    function destroy (err) {
      extract.destroy(err);
      consumeCallback(err);
      return new Promise((resolve, reject) => {
        if (extract.destroyed) return resolve({ value: undefined, done: true })
        extract.once('close', function () {
          if (err) reject(err);
          else resolve({ value: undefined, done: true });
        });
      })
    }
  }
}

var extract$1 = function extract (opts) {
  return new Extract(opts)
};

function noop$4 () {}

function overflow$1 (size) {
  size &= 511;
  return size && 512 - size
}

var constants$2 = {exports: {}};

const constants$1 = { // just for envs without fs
  S_IFMT: 61440,
  S_IFDIR: 16384,
  S_IFCHR: 8192,
  S_IFBLK: 24576,
  S_IFIFO: 4096,
  S_IFLNK: 40960
};

try {
  constants$2.exports = require('fs').constants || constants$1;
} catch {
  constants$2.exports = constants$1;
}

var constantsExports = constants$2.exports;

const { Readable, Writable, getStreamError } = streamx;
const b4a = b4a$5;

const constants = constantsExports;
const headers = headers$2;

const DMODE = 0o755;
const FMODE = 0o644;

const END_OF_TAR = b4a.alloc(1024);

class Sink extends Writable {
  constructor (pack, header, callback) {
    super({ mapWritable, eagerOpen: true });

    this.written = 0;
    this.header = header;

    this._callback = callback;
    this._linkname = null;
    this._isLinkname = header.type === 'symlink' && !header.linkname;
    this._isVoid = header.type !== 'file' && header.type !== 'contiguous-file';
    this._finished = false;
    this._pack = pack;
    this._openCallback = null;

    if (this._pack._stream === null) this._pack._stream = this;
    else this._pack._pending.push(this);
  }

  _open (cb) {
    this._openCallback = cb;
    if (this._pack._stream === this) this._continueOpen();
  }

  _continuePack (err) {
    if (this._callback === null) return

    const callback = this._callback;
    this._callback = null;

    callback(err);
  }

  _continueOpen () {
    if (this._pack._stream === null) this._pack._stream = this;

    const cb = this._openCallback;
    this._openCallback = null;
    if (cb === null) return

    if (this._pack.destroying) return cb(new Error('pack stream destroyed'))
    if (this._pack._finalized) return cb(new Error('pack stream is already finalized'))

    this._pack._stream = this;

    if (!this._isLinkname) {
      this._pack._encode(this.header);
    }

    if (this._isVoid) {
      this._finish();
      this._continuePack(null);
    }

    cb(null);
  }

  _write (data, cb) {
    if (this._isLinkname) {
      this._linkname = this._linkname ? b4a.concat([this._linkname, data]) : data;
      return cb(null)
    }

    if (this._isVoid) {
      if (data.byteLength > 0) {
        return cb(new Error('No body allowed for this entry'))
      }
      return cb()
    }

    this.written += data.byteLength;
    if (this._pack.push(data)) return cb()
    this._pack._drain = cb;
  }

  _finish () {
    if (this._finished) return
    this._finished = true;

    if (this._isLinkname) {
      this.header.linkname = this._linkname ? b4a.toString(this._linkname, 'utf-8') : '';
      this._pack._encode(this.header);
    }

    overflow(this._pack, this.header.size);

    this._pack._done(this);
  }

  _final (cb) {
    if (this.written !== this.header.size) { // corrupting tar
      return cb(new Error('Size mismatch'))
    }

    this._finish();
    cb(null);
  }

  _getError () {
    return getStreamError(this) || new Error('tar entry destroyed')
  }

  _predestroy () {
    this._pack.destroy(this._getError());
  }

  _destroy (cb) {
    this._pack._done(this);

    this._continuePack(this._finished ? null : this._getError());

    cb();
  }
}

class Pack extends Readable {
  constructor (opts) {
    super(opts);
    this._drain = noop$3;
    this._finalized = false;
    this._finalizing = false;
    this._pending = [];
    this._stream = null;
  }

  entry (header, buffer, callback) {
    if (this._finalized || this.destroying) throw new Error('already finalized or destroyed')

    if (typeof buffer === 'function') {
      callback = buffer;
      buffer = null;
    }

    if (!callback) callback = noop$3;

    if (!header.size || header.type === 'symlink') header.size = 0;
    if (!header.type) header.type = modeToType(header.mode);
    if (!header.mode) header.mode = header.type === 'directory' ? DMODE : FMODE;
    if (!header.uid) header.uid = 0;
    if (!header.gid) header.gid = 0;
    if (!header.mtime) header.mtime = new Date();

    if (typeof buffer === 'string') buffer = b4a.from(buffer);

    const sink = new Sink(this, header, callback);

    if (b4a.isBuffer(buffer)) {
      header.size = buffer.byteLength;
      sink.write(buffer);
      sink.end();
      return sink
    }

    if (sink._isVoid) {
      return sink
    }

    return sink
  }

  finalize () {
    if (this._stream || this._pending.length > 0) {
      this._finalizing = true;
      return
    }

    if (this._finalized) return
    this._finalized = true;

    this.push(END_OF_TAR);
    this.push(null);
  }

  _done (stream) {
    if (stream !== this._stream) return

    this._stream = null;

    if (this._finalizing) this.finalize();
    if (this._pending.length) this._pending.shift()._continueOpen();
  }

  _encode (header) {
    if (!header.pax) {
      const buf = headers.encode(header);
      if (buf) {
        this.push(buf);
        return
      }
    }
    this._encodePax(header);
  }

  _encodePax (header) {
    const paxHeader = headers.encodePax({
      name: header.name,
      linkname: header.linkname,
      pax: header.pax
    });

    const newHeader = {
      name: 'PaxHeader',
      mode: header.mode,
      uid: header.uid,
      gid: header.gid,
      size: paxHeader.byteLength,
      mtime: header.mtime,
      type: 'pax-header',
      linkname: header.linkname && 'PaxHeader',
      uname: header.uname,
      gname: header.gname,
      devmajor: header.devmajor,
      devminor: header.devminor
    };

    this.push(headers.encode(newHeader));
    this.push(paxHeader);
    overflow(this, paxHeader.byteLength);

    newHeader.size = header.size;
    newHeader.type = header.type;
    this.push(headers.encode(newHeader));
  }

  _doDrain () {
    const drain = this._drain;
    this._drain = noop$3;
    drain();
  }

  _predestroy () {
    const err = getStreamError(this);

    if (this._stream) this._stream.destroy(err);

    while (this._pending.length) {
      const stream = this._pending.shift();
      stream.destroy(err);
      stream._continueOpen();
    }

    this._doDrain();
  }

  _read (cb) {
    this._doDrain();
    cb();
  }
}

var pack = function pack (opts) {
  return new Pack(opts)
};

function modeToType (mode) {
  switch (mode & constants.S_IFMT) {
    case constants.S_IFBLK: return 'block-device'
    case constants.S_IFCHR: return 'character-device'
    case constants.S_IFDIR: return 'directory'
    case constants.S_IFIFO: return 'fifo'
    case constants.S_IFLNK: return 'symlink'
  }

  return 'file'
}

function noop$3 () {}

function overflow (self, size) {
  size &= 511;
  if (size) self.push(END_OF_TAR.subarray(0, 512 - size));
}

function mapWritable (buf) {
  return b4a.isBuffer(buf) ? buf : b4a.from(buf)
}

tarStream.extract = extract$1;
tarStream.pack = pack;

var once$3 = {exports: {}};

// Returns a wrapper function that returns a wrapped callback
// The wrapper function should do some stuff, and return a
// presumably different callback function.
// This makes sure that own properties are retained, so that
// decorations and such are not lost along the way.
var wrappy_1 = wrappy$1;
function wrappy$1 (fn, cb) {
  if (fn && cb) return wrappy$1(fn)(cb)

  if (typeof fn !== 'function')
    throw new TypeError('need wrapper function')

  Object.keys(fn).forEach(function (k) {
    wrapper[k] = fn[k];
  });

  return wrapper

  function wrapper() {
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }
    var ret = fn.apply(this, args);
    var cb = args[args.length-1];
    if (typeof ret === 'function' && ret !== cb) {
      Object.keys(cb).forEach(function (k) {
        ret[k] = cb[k];
      });
    }
    return ret
  }
}

var wrappy = wrappy_1;
once$3.exports = wrappy(once$2);
once$3.exports.strict = wrappy(onceStrict);

once$2.proto = once$2(function () {
  Object.defineProperty(Function.prototype, 'once', {
    value: function () {
      return once$2(this)
    },
    configurable: true
  });

  Object.defineProperty(Function.prototype, 'onceStrict', {
    value: function () {
      return onceStrict(this)
    },
    configurable: true
  });
});

function once$2 (fn) {
  var f = function () {
    if (f.called) return f.value
    f.called = true;
    return f.value = fn.apply(this, arguments)
  };
  f.called = false;
  return f
}

function onceStrict (fn) {
  var f = function () {
    if (f.called)
      throw new Error(f.onceError)
    f.called = true;
    return f.value = fn.apply(this, arguments)
  };
  var name = fn.name || 'Function wrapped with `once`';
  f.onceError = name + " shouldn't be called more than once";
  f.called = false;
  return f
}

var onceExports = once$3.exports;

var once$1 = onceExports;

var noop$2 = function() {};

var isRequest$1 = function(stream) {
	return stream.setHeader && typeof stream.abort === 'function';
};

var isChildProcess = function(stream) {
	return stream.stdio && Array.isArray(stream.stdio) && stream.stdio.length === 3
};

var eos$1 = function(stream, opts, callback) {
	if (typeof opts === 'function') return eos$1(stream, null, opts);
	if (!opts) opts = {};

	callback = once$1(callback || noop$2);

	var ws = stream._writableState;
	var rs = stream._readableState;
	var readable = opts.readable || (opts.readable !== false && stream.readable);
	var writable = opts.writable || (opts.writable !== false && stream.writable);
	var cancelled = false;

	var onlegacyfinish = function() {
		if (!stream.writable) onfinish();
	};

	var onfinish = function() {
		writable = false;
		if (!readable) callback.call(stream);
	};

	var onend = function() {
		readable = false;
		if (!writable) callback.call(stream);
	};

	var onexit = function(exitCode) {
		callback.call(stream, exitCode ? new Error('exited with error code: ' + exitCode) : null);
	};

	var onerror = function(err) {
		callback.call(stream, err);
	};

	var onclose = function() {
		process.nextTick(onclosenexttick);
	};

	var onclosenexttick = function() {
		if (cancelled) return;
		if (readable && !(rs && (rs.ended && !rs.destroyed))) return callback.call(stream, new Error('premature close'));
		if (writable && !(ws && (ws.ended && !ws.destroyed))) return callback.call(stream, new Error('premature close'));
	};

	var onrequest = function() {
		stream.req.on('finish', onfinish);
	};

	if (isRequest$1(stream)) {
		stream.on('complete', onfinish);
		stream.on('abort', onclose);
		if (stream.req) onrequest();
		else stream.on('request', onrequest);
	} else if (writable && !ws) { // legacy streams
		stream.on('end', onlegacyfinish);
		stream.on('close', onlegacyfinish);
	}

	if (isChildProcess(stream)) stream.on('exit', onexit);

	stream.on('end', onend);
	stream.on('finish', onfinish);
	if (opts.error !== false) stream.on('error', onerror);
	stream.on('close', onclose);

	return function() {
		cancelled = true;
		stream.removeListener('complete', onfinish);
		stream.removeListener('abort', onclose);
		stream.removeListener('request', onrequest);
		if (stream.req) stream.req.removeListener('finish', onfinish);
		stream.removeListener('end', onlegacyfinish);
		stream.removeListener('close', onlegacyfinish);
		stream.removeListener('finish', onfinish);
		stream.removeListener('exit', onexit);
		stream.removeListener('end', onend);
		stream.removeListener('error', onerror);
		stream.removeListener('close', onclose);
	};
};

var endOfStream = eos$1;

var once = onceExports;
var eos = endOfStream;
var fs$1;

try {
  fs$1 = require('fs'); // we only need fs to get the ReadStream and WriteStream prototypes
} catch (e) {}

var noop$1 = function () {};
var ancient = /^v?\.0/.test(process.version);

var isFn = function (fn) {
  return typeof fn === 'function'
};

var isFS = function (stream) {
  if (!ancient) return false // newer node version do not need to care about fs is a special way
  if (!fs$1) return false // browser
  return (stream instanceof (fs$1.ReadStream || noop$1) || stream instanceof (fs$1.WriteStream || noop$1)) && isFn(stream.close)
};

var isRequest = function (stream) {
  return stream.setHeader && isFn(stream.abort)
};

var destroyer = function (stream, reading, writing, callback) {
  callback = once(callback);

  var closed = false;
  stream.on('close', function () {
    closed = true;
  });

  eos(stream, {readable: reading, writable: writing}, function (err) {
    if (err) return callback(err)
    closed = true;
    callback();
  });

  var destroyed = false;
  return function (err) {
    if (closed) return
    if (destroyed) return
    destroyed = true;

    if (isFS(stream)) return stream.close(noop$1) // use close for fs streams to avoid fd leaks
    if (isRequest(stream)) return stream.abort() // request.destroy just do .end - .abort is what we want

    if (isFn(stream.destroy)) return stream.destroy()

    callback(err || new Error('stream was destroyed'));
  }
};

var call = function (fn) {
  fn();
};

var pipe = function (from, to) {
  return from.pipe(to)
};

var pump$1 = function () {
  var streams = Array.prototype.slice.call(arguments);
  var callback = isFn(streams[streams.length - 1] || noop$1) && streams.pop() || noop$1;

  if (Array.isArray(streams[0])) streams = streams[0];
  if (streams.length < 2) throw new Error('pump requires two streams per minimum')

  var error;
  var destroys = streams.map(function (stream, i) {
    var reading = i < streams.length - 1;
    var writing = i > 0;
    return destroyer(stream, reading, writing, function (err) {
      if (!error) error = err;
      if (err) destroys.forEach(call);
      if (reading) return
      destroys.forEach(call);
      callback(error);
    })
  });

  return streams.reduce(pipe)
};

var pump_1 = pump$1;

const tar = tarStream;
const pump = pump_1;
const fs = require$$1$1;
const path = require$$1$1$1;

const win32 = (commonjsGlobal.Bare?.platform || process.platform) === 'win32';

function head (list) {
  return list.length ? list[list.length - 1] : null
}

function processGetuid () {
  return process.getuid ? process.getuid() : -1
}

function processUmask () {
  return process.umask ? process.umask() : 0
}

var extract = function extract (cwd, opts) {
  if (!cwd) cwd = '.';
  if (!opts) opts = {};

  const xfs = opts.fs || fs;
  const ignore = opts.ignore || opts.filter || noop;
  const mapStream = opts.mapStream || echo;
  const own = opts.chown !== false && !win32 && processGetuid() === 0;
  const extract = opts.extract || tar.extract();
  const stack = [];
  const now = new Date();
  const umask = typeof opts.umask === 'number' ? ~opts.umask : ~processUmask();
  const strict = opts.strict !== false;

  let map = opts.map || noop;
  let dmode = typeof opts.dmode === 'number' ? opts.dmode : 0;
  let fmode = typeof opts.fmode === 'number' ? opts.fmode : 0;

  if (opts.strip) map = strip(map, opts.strip);

  if (opts.readable) {
    dmode |= parseInt(555, 8);
    fmode |= parseInt(444, 8);
  }
  if (opts.writable) {
    dmode |= parseInt(333, 8);
    fmode |= parseInt(222, 8);
  }

  extract.on('entry', onentry);

  if (opts.finish) extract.on('finish', opts.finish);

  return extract

  function onentry (header, stream, next) {
    header = map(header) || header;
    header.name = normalize(header.name);

    const name = path.join(cwd, path.join('/', header.name));

    if (ignore(name, header)) {
      stream.resume();
      return next()
    }

    if (header.type === 'directory') {
      stack.push([name, header.mtime]);
      return mkdirfix(name, {
        fs: xfs,
        own,
        uid: header.uid,
        gid: header.gid,
        mode: header.mode
      }, stat)
    }

    const dir = path.dirname(name);

    validate(xfs, dir, path.join(cwd, '.'), function (err, valid) {
      if (err) return next(err)
      if (!valid) return next(new Error(dir + ' is not a valid path'))

      mkdirfix(dir, {
        fs: xfs,
        own,
        uid: header.uid,
        gid: header.gid,
        // normally, the folders with rights and owner should be part of the TAR file
        // if this is not the case, create folder for same user as file and with
        // standard permissions of 0o755 (rwxr-xr-x)
        mode: 0o755
      }, function (err) {
        if (err) return next(err)

        switch (header.type) {
          case 'file': return onfile()
          case 'link': return onlink()
          case 'symlink': return onsymlink()
        }

        if (strict) return next(new Error('unsupported type for ' + name + ' (' + header.type + ')'))

        stream.resume();
        next();
      });
    });

    function stat (err) {
      if (err) return next(err)
      utimes(name, header, function (err) {
        if (err) return next(err)
        if (win32) return next()
        chperm(name, header, next);
      });
    }

    function onsymlink () {
      if (win32) return next() // skip symlinks on win for now before it can be tested
      xfs.unlink(name, function () {
        xfs.symlink(header.linkname, name, stat);
      });
    }

    function onlink () {
      if (win32) return next() // skip links on win for now before it can be tested
      xfs.unlink(name, function () {
        const srcpath = path.join(cwd, path.join('/', header.linkname));

        xfs.link(srcpath, name, function (err) {
          if (err && err.code === 'EPERM' && opts.hardlinkAsFilesFallback) {
            stream = xfs.createReadStream(srcpath);
            return onfile()
          }

          stat(err);
        });
      });
    }

    function onfile () {
      const ws = xfs.createWriteStream(name);
      const rs = mapStream(stream, header);

      ws.on('error', function (err) { // always forward errors on destroy
        rs.destroy(err);
      });

      pump(rs, ws, function (err) {
        if (err) return next(err)
        ws.on('close', stat);
      });
    }
  }

  function utimesParent (name, cb) { // we just set the mtime on the parent dir again everytime we write an entry
    let top;
    while ((top = head(stack)) && name.slice(0, top[0].length) !== top[0]) stack.pop();
    if (!top) return cb()
    xfs.utimes(top[0], now, top[1], cb);
  }

  function utimes (name, header, cb) {
    if (opts.utimes === false) return cb()

    if (header.type === 'directory') return xfs.utimes(name, now, header.mtime, cb)
    if (header.type === 'symlink') return utimesParent(name, cb) // TODO: how to set mtime on link?

    xfs.utimes(name, now, header.mtime, function (err) {
      if (err) return cb(err)
      utimesParent(name, cb);
    });
  }

  function chperm (name, header, cb) {
    const link = header.type === 'symlink';

    /* eslint-disable n/no-deprecated-api */
    const chmod = link ? xfs.lchmod : xfs.chmod;
    const chown = link ? xfs.lchown : xfs.chown;
    /* eslint-enable n/no-deprecated-api */

    if (!chmod) return cb()

    const mode = (header.mode | (header.type === 'directory' ? dmode : fmode)) & umask;

    if (chown && own) chown.call(xfs, name, header.uid, header.gid, onchown);
    else onchown(null);

    function onchown (err) {
      if (err) return cb(err)
      if (!chmod) return cb()
      chmod.call(xfs, name, mode, cb);
    }
  }

  function mkdirfix (name, opts, cb) {
    // when mkdir is called on an existing directory, the permissions
    // will be overwritten (?), to avoid this we check for its existance first
    xfs.stat(name, function (err) {
      if (!err) return cb(null)
      if (err.code !== 'ENOENT') return cb(err)
      xfs.mkdir(name, { mode: opts.mode, recursive: true }, function (err, made) {
        if (err) return cb(err)
        chperm(name, opts, cb);
      });
    });
  }
};

function validate (fs, name, root, cb) {
  if (name === root) return cb(null, true)
  fs.lstat(name, function (err, st) {
    if (err && err.code === 'ENOENT') return validate(fs, path.join(name, '..'), root, cb)
    else if (err) return cb(err)
    cb(null, st.isDirectory());
  });
}

function noop () {}

function echo (name) {
  return name
}

function normalize (name) {
  return win32 ? name.replace(/\\/g, '/').replace(/[:?<>|]/g, '_') : name
}

function strip (map, level) {
  return function (header) {
    header.name = header.name.split('/').slice(level).join('/');

    const linkname = header.linkname;
    if (linkname && (header.type === 'link' || path.isAbsolute(linkname))) {
      header.linkname = linkname.split('/').slice(level).join('/');
    }

    return map(header)
  }
}

const NODE_MODULES = fileURLToPath(new URL("../node_modules", import.meta.url));
const REGISTRY = "https://registry.npmjs.org";
const Directive = { file: "file:", npm: "npm:" };
function verifyPackage(pkg, specifier) {
  const deps = { ...pkg.dependencies, ...pkg.peerDependencies };
  if (!deps["@sveltejs/cli-core"]) {
    throw new Error(
      `Invalid add-on package specified: '${specifier}' is missing a dependency on '@sveltejs/cli-core' in its 'package.json'`
    );
  }
  for (const dep of Object.keys(deps)) {
    if (dep === "@sveltejs/cli-core") continue;
    throw new Error(
      `Invalid add-on package detected: '${specifier}'
Community addons should not have any external 'dependencies' besides '@sveltejs/cli-core'. Consider bundling your dependencies if they are necessary`
    );
  }
}
async function downloadPackage(options) {
  const { pkg } = options;
  if (options.path) {
    const dest = path$2.join(NODE_MODULES, pkg.name.split("/").join(path$2.sep));
    if (fs$3.existsSync(dest)) {
      fs$3.rmSync(dest);
    }
    const dir = path$2.dirname(dest);
    if (!fs$3.existsSync(dir)) {
      fs$3.mkdirSync(dir, { recursive: true });
    }
    fs$3.symlinkSync(options.path, dest);
    const { default: details2 } = await import(pkg.name);
    return details2;
  }
  const tarballUrl = pkg.dist.tarball;
  const data = await fetch(tarballUrl);
  if (!data.body) throw new Error(`Unexpected response: '${tarballUrl}' responded with no body`);
  await pipeline$1(
    data.body,
    createGunzip(),
    extract(NODE_MODULES, {
      map: (header) => {
        header.name = header.name.replace("package", pkg.name);
        return header;
      }
    })
  );
  const { default: details } = await import(pkg.name);
  return details;
}
async function getPackageJSON({ cwd, packageName }) {
  let npm = packageName;
  if (packageName.startsWith(Directive.file)) {
    const pkgPath = path$2.resolve(cwd, packageName.slice(Directive.file.length));
    const pkgJSONPath = path$2.resolve(pkgPath, "package.json");
    const json = fs$3.readFileSync(pkgJSONPath, "utf8");
    const pkg2 = JSON.parse(json);
    verifyPackage(pkg2, packageName);
    return { path: pkgPath, pkg: pkg2, repo: pkgPath };
  }
  if (packageName.startsWith(Directive.npm)) {
    npm = packageName.slice(Directive.npm.length);
  }
  const pkg = await fetchPackageJSON(npm);
  verifyPackage(pkg, packageName);
  return {
    pkg,
    // fallback to providing the NPM package URL
    repo: pkg.repository?.url ?? `https://www.npmjs.com/package/${npm}`
  };
}
async function fetchPackageJSON(packageName) {
  let pkgName = packageName;
  let scope = "";
  if (packageName.startsWith("@")) {
    const [org, name2] = pkgName.split("/", 2);
    scope = `${org}/`;
    pkgName = name2;
  }
  const [name, tag = "latest"] = pkgName.split("@");
  const pkgUrl = `${REGISTRY}/${scope + name}/${tag}`;
  const resp = await fetch(pkgUrl);
  if (resp.status === 404) {
    throw new Error(`Package '${packageName}' doesn't exist in the registry: '${pkgUrl}'`);
  }
  if (resp.status < 200 && resp.status >= 300) {
    throw new Error(`Failed to fetch '${pkgUrl}' - GET ${resp.status}`);
  }
  return await resp.json();
}

function getGlobalPreconditions(cwd, addons, addonSetupResult) {
  return {
    name: "global checks",
    preconditions: [
      {
        name: "clean working directory",
        run: async () => {
          try {
            const { stdout } = await be("git", ["status", "--short"], {
              nodeOptions: { cwd },
              throwOnError: true
            });
            if (stdout) {
              return { success: false, message: "Found modified files" };
            }
            return { success: true, message: void 0 };
          } catch {
            return { success: true, message: "Not a git repository" };
          }
        }
      },
      {
        name: "unsupported add-ons",
        run: () => {
          const reasons = addons.flatMap(
            (a) => addonSetupResult[a.id].unsupported.map((reason) => ({ id: a.id, reason }))
          );
          if (reasons.length === 0) {
            return { success: true, message: void 0 };
          }
          throw new UnsupportedError(reasons);
        }
      }
    ]
  };
}

const AddonsSchema = array(string());
const AddonOptionFlagsSchema = object({
  tailwindcss: optional(array(string())),
  drizzle: optional(array(string())),
  lucia: optional(array(string())),
  paraglide: optional(array(string()))
});
const OptionsSchema$1 = strictObject({
  cwd: string(),
  install: boolean(),
  preconditions: boolean(),
  community: optional(union([AddonsSchema, boolean()])),
  ...AddonOptionFlagsSchema.entries
});
const aliases = officialAddons.map((c) => c.alias).filter((v2) => v2 !== void 0);
const addonsOptions = getAddonOptionFlags();
const communityDetails = [];
const defaultPkgPath = up();
const defaultCwd = defaultPkgPath ? path$2.dirname(defaultPkgPath) : void 0;
const add = new Command("add").description("applies specified add-ons into a project").argument("[add-on...]", "add-ons to install").option("-C, --cwd <path>", "path to working directory", defaultCwd).option("--no-install", "skip installing dependencies").option("--no-preconditions", "skip validating preconditions").configureHelp(helpConfig).action((addonArgs, opts) => {
  if (opts.cwd === void 0) {
    console.error(
      "Invalid workspace: Please verify that you are inside of a Svelte project. You can also specify the working directory with `--cwd <path>`"
    );
    process$1$1.exit(1);
  } else if (!fs$3.existsSync(path$2.resolve(opts.cwd, "package.json"))) {
    console.error(
      `Invalid workspace: Path '${path$2.resolve(opts.cwd)}' is not a valid workspace.`
    );
    process$1$1.exit(1);
  }
  const specifiedAddons = parse(AddonsSchema, addonArgs);
  const options = parse(OptionsSchema$1, opts);
  const addonIds = officialAddons.map((addon) => addon.id);
  const invalidAddons = specifiedAddons.filter(
    (a) => !addonIds.includes(a) && !aliases.includes(a)
  );
  if (invalidAddons.length > 0) {
    console.error(`Invalid add-ons specified: ${invalidAddons.join(", ")}`);
    process$1$1.exit(1);
  }
  const selectedAddons = transformAliases(specifiedAddons);
  runCommand(async () => {
    const { nextSteps } = await runAddCommand(options, selectedAddons);
    if (nextSteps) box(nextSteps, "Next steps");
  });
});
for (const option of addonsOptions) {
  add.addOption(option);
}
async function runAddCommand(options, selectedAddonIds) {
  var _a;
  const selectedAddons = selectedAddonIds.map((id) => ({
    type: "official",
    addon: getAddonDetails(id)
  }));
  const official = {};
  const community = {};
  for (const addonOption of addonsOptions) {
    const addonId = addonOption.attributeName();
    const specifiedOptions = options[addonId];
    if (!specifiedOptions) continue;
    const details2 = getAddonDetails(addonId);
    if (!selectedAddons.find((d) => d.addon === details2)) {
      selectedAddons.push({ type: "official", addon: details2 });
    }
    official[addonId] ?? (official[addonId] = {});
    const optionEntries = Object.entries(details2.options);
    for (const specifiedOption of specifiedOptions) {
      if (!specifiedOption || specifiedOption === "none") continue;
      const optionEntry = optionEntries.find(([id, question2]) => {
        if (question2.type === "boolean") {
          return id === specifiedOption || `no-${id}` === specifiedOption;
        }
        if (question2.type === "select" || question2.type === "multiselect") {
          return question2.options.some((o) => o.value === specifiedOption);
        }
      });
      if (!optionEntry) {
        const { choices } = getOptionChoices(details2);
        throw new Error(
          `Invalid '--${addonId}' option: '${specifiedOption}'
Available options: ${choices.join(", ")}`
        );
      }
      const [questionId, question] = optionEntry;
      let existingOption = official[addonId][questionId];
      if (existingOption !== void 0) {
        if (typeof existingOption === "boolean") {
          existingOption = existingOption ? questionId : `no-${questionId}`;
        }
        throw new Error(
          `Conflicting '--${addonId}' option: '${specifiedOption}' conflicts with '${existingOption}'`
        );
      }
      official[addonId][questionId] = question.type === "boolean" ? !specifiedOption.startsWith("no-") : specifiedOption;
    }
    for (const [id, question] of Object.entries(details2.options)) {
      if (question.condition?.(official[addonId]) !== false) {
        (_a = official[addonId])[id] ?? (_a[id] = question.default);
      } else {
        if (official[addonId][id] !== void 0) {
          throw new Error(
            `Incompatible '--${addonId}' option specified: '${official[addonId][id]}'`
          );
        }
      }
    }
  }
  if (options.community === true) {
    const communityAddons = await Promise.all(
      communityAddonIds.map(async (id) => await getCommunityAddon(id))
    );
    const promptOptions = communityAddons.map((addon) => ({
      value: addon.id,
      label: addon.id,
      hint: "https://www.npmjs.com/package/" + addon.id
    }));
    const selected = await multiselect({
      message: "Which community tools would you like to add to your project?",
      options: promptOptions,
      required: false
    });
    if (isCancel(selected)) {
      cancel("Operation cancelled.");
      process$1$1.exit(1);
    } else if (selected.length === 0) {
      cancel("No add-ons selected. Exiting.");
      process$1$1.exit(1);
    }
    options.community = selected;
  }
  if (Array.isArray(options.community) && options.community.length > 0) {
    const addons = options.community.map((id) => {
      const hasDirective = Object.values(Directive).some((directive) => id.startsWith(directive));
      if (hasDirective) return id;
      const validAddon = communityAddonIds.includes(id);
      if (!validAddon) {
        throw new Error(
          `Invalid community add-on specified: '${id}'
Available options: ${communityAddonIds.join(", ")}`
        );
      }
      return id;
    });
    const { start, stop } = spinner();
    try {
      start("Resolving community add-on packages");
      const pkgs = await Promise.all(
        addons.map(async (id) => {
          return await getPackageJSON({ cwd: options.cwd, packageName: id });
        })
      );
      stop("Resolved community add-on packages");
      log$1.warn(
        "The Svelte maintainers have not reviewed community add-ons for malicious code. Use at your discretion."
      );
      const paddingName = getPadding(pkgs.map(({ pkg: pkg2 }) => pkg2.name));
      const paddingVersion = getPadding(pkgs.map(({ pkg: pkg2 }) => `(v${pkg2.version})`));
      const packageInfos = pkgs.map(({ pkg: pkg2, repo: _repo }) => {
        const name = pc.yellowBright(pkg2.name.padEnd(paddingName));
        const version = pc.dim(`(v${pkg2.version})`.padEnd(paddingVersion));
        const repo = pc.dim(`(${_repo})`);
        return `${name} ${version} ${repo}`;
      });
      log$1.message(packageInfos.join("\n"));
      const confirm$1 = await confirm({ message: "Would you like to continue?" });
      if (confirm$1 !== true) {
        cancel("Operation cancelled.");
        process$1$1.exit(1);
      }
      start("Downloading community add-on packages");
      const details2 = await Promise.all(pkgs.map(async (opts) => downloadPackage(opts)));
      for (const addon of details2) {
        const id = addon.id;
        community[id] ?? (community[id] = {});
        communityDetails.push(addon);
        selectedAddons.push({ type: "community", addon });
      }
      stop("Downloaded community add-on packages");
    } catch (err) {
      stop("Failed to resolve community add-on packages", 1);
      throw err;
    }
  }
  let workspace = createWorkspace({ cwd: options.cwd });
  const addonSetupResults = setupAddons(officialAddons, workspace);
  if (selectedAddons.length === 0) {
    const addonOptions = officialAddons.filter(({ id }) => addonSetupResults[id].unsupported.length === 0).map(({ id, homepage, shortDescription }) => ({
      label: id,
      value: id,
      hint: `${shortDescription} - ${homepage}`
    }));
    const selected = await multiselect({
      message: `What would you like to add to your project? ${pc.dim("(use arrow keys / space bar)")}`,
      options: addonOptions,
      required: false
    });
    if (isCancel(selected)) {
      cancel("Operation cancelled.");
      process$1$1.exit(1);
    }
    for (const id of selected) {
      const addon = officialAddons.find((addon2) => addon2.id === id);
      selectedAddons.push({ type: "official", addon });
    }
  }
  for (const { addon } of selectedAddons) {
    workspace = createWorkspace(workspace);
    const setupResult = addonSetupResults[addon.id];
    const missingDependencies = setupResult.dependsOn.filter(
      (depId) => !selectedAddons.some((a) => a.addon.id === depId)
    );
    for (const depId of missingDependencies) {
      const dependency = officialAddons.find((a) => a.id === depId);
      if (!dependency) throw new Error(`'${addon.id}' depends on an invalid add-on: '${depId}'`);
      const install = await confirm({
        message: `The ${pc.bold(pc.cyan(addon.id))} add-on requires ${pc.bold(pc.cyan(depId))} to also be setup. ${pc.green("Include it?")}`
      });
      if (install !== true) {
        cancel("Operation cancelled.");
        process$1$1.exit(1);
      }
      selectedAddons.push({ type: "official", addon: dependency });
    }
  }
  if (options.preconditions && selectedAddons.length > 0) {
    const addons = selectedAddons.map(({ addon }) => addon);
    const { preconditions } = getGlobalPreconditions(options.cwd, addons, addonSetupResults);
    const fails = [];
    for (const condition of preconditions) {
      const { message, success } = await condition.run();
      if (!success) fails.push({ name: condition.name, message });
    }
    if (fails.length > 0) {
      const message = fails.map(({ name, message: message2 }) => pc.yellow(`${name} (${message2})`)).join("\n- ");
      note(`- ${message}`, "Preconditions not met");
      const force = await confirm({
        message: "Preconditions failed. Do you wish to continue?",
        initialValue: false
      });
      if (isCancel(force) || !force) {
        cancel("Operation cancelled.");
        process$1$1.exit(1);
      }
    }
  }
  for (const { addon, type } of selectedAddons) {
    const addonId = addon.id;
    const questionPrefix = selectedAddons.length > 1 ? `${addon.id}: ` : "";
    let values = {};
    if (type === "official") {
      official[addonId] ?? (official[addonId] = {});
      values = official[addonId];
    }
    if (type === "community") {
      community[addonId] ?? (community[addonId] = {});
      values = community[addonId];
    }
    for (const [questionId, question] of Object.entries(addon.options)) {
      const shouldAsk = question.condition?.(values);
      if (shouldAsk === false || values[questionId] !== void 0) continue;
      let answer;
      const message = questionPrefix + question.question;
      if (question.type === "boolean") {
        answer = await confirm({ message, initialValue: question.default });
      }
      if (question.type === "select") {
        answer = await select({
          message,
          initialValue: question.default,
          options: question.options
        });
      }
      if (question.type === "multiselect") {
        answer = await multiselect({
          message,
          initialValues: question.default,
          required: false,
          options: question.options
        });
      }
      if (question.type === "string" || question.type === "number") {
        answer = await text({
          message,
          initialValue: question.default.toString(),
          placeholder: question.placeholder,
          validate: question.validate
        });
        if (question.type === "number") {
          answer = Number(answer);
        }
      }
      if (isCancel(answer)) {
        cancel("Operation cancelled.");
        process$1$1.exit(1);
      }
      values[questionId] = answer;
    }
  }
  if (selectedAddons.length === 0) return { packageManager: null };
  let packageManager;
  if (options.install) {
    packageManager = await packageManagerPrompt(options.cwd);
    if (packageManager) workspace.packageManager = packageManager;
  }
  const officialDetails = Object.keys(official).map((id) => getAddonDetails(id));
  const commDetails = Object.keys(community).map(
    (id) => communityDetails.find((a) => a.id === id)
  );
  const details = officialDetails.concat(commDetails);
  const addonMap = Object.assign({}, ...details.map((a) => ({ [a.id]: a })));
  const filesToFormat = await applyAddons({
    workspace,
    addonSetupResults,
    addons: addonMap,
    options: official
  });
  log$1.success("Successfully setup add-ons");
  if (packageManager && options.install) {
    await installDependencies(packageManager, options.cwd);
  }
  workspace = createWorkspace(workspace);
  if (filesToFormat.length > 0 && packageManager && !!workspace.dependencyVersion("prettier")) {
    const { start, stop } = spinner();
    start("Formatting modified files");
    try {
      await formatFiles({ packageManager, cwd: options.cwd, paths: filesToFormat });
      stop("Successfully formatted modified files");
    } catch (e) {
      stop("Failed to format files");
      if (e instanceof Error) log$1.error(e.message);
    }
  }
  const highlighter = getHighlighter();
  const nextSteps = selectedAddons.filter(({ addon }) => addon.nextSteps).map(({ addon }) => {
    let addonMessage = "";
    if (selectedAddons.length > 1) {
      addonMessage = `${pc.green(addon.id)}:
`;
    }
    const addonNextSteps = addon.nextSteps({
      ...workspace,
      options: official[addon.id],
      highlighter
    });
    addonMessage += `- ${addonNextSteps.join("\n- ")}`;
    return addonMessage;
  }).join("\n\n") || void 0;
  return { nextSteps, packageManager };
}
function transformAliases(ids) {
  const set = /* @__PURE__ */ new Set();
  for (const id of ids) {
    if (aliases.includes(id)) {
      const addon = officialAddons.find((a) => a.alias === id);
      set.add(addon.id);
    } else {
      set.add(id);
    }
  }
  return Array.from(set);
}
function getAddonOptionFlags() {
  const options = [];
  for (const addon of officialAddons) {
    const id = addon.id;
    const details = getAddonDetails(id);
    if (Object.values(details.options).length === 0) continue;
    const { defaults, groups } = getOptionChoices(details);
    const choices = Object.entries(groups).map(([group, choices2]) => `${pc.dim(`${group}:`)} ${choices2.join(", ")}`).join("\n");
    const preset = defaults.join(", ") || "none";
    const option = new Option(
      `--${id} [options...]`,
      `${id} add-on options ${pc.dim(`(preset: ${preset})`)}
${choices}`
    ).preset(preset).argParser((value, prev) => {
      prev ?? (prev = []);
      prev = prev.concat(value.split(/\s|,/));
      return prev;
    });
    options.push(option);
  }
  return options;
}
function getOptionChoices(details) {
  const choices = [];
  const defaults = [];
  const groups = {};
  const options = {};
  for (const [id, question] of Object.entries(details.options)) {
    let values = [];
    const applyDefault = question.condition?.(options) !== false;
    if (question.type === "boolean") {
      values = [id, `no-${id}`];
      if (applyDefault) {
        options[id] = question.default;
        defaults.push(question.default ? values[0] : values[1]);
      }
    }
    if (question.type === "select") {
      values = question.options.map((o) => o.value);
      if (applyDefault) {
        options[id] = question.default;
        defaults.push(question.default);
      }
    }
    if (question.type === "multiselect") {
      values = question.options.map((o) => o.value);
      if (applyDefault) {
        options[id] = question.default;
        defaults.push(...question.default);
      }
    }
    choices.push(...values);
    const groupId = question.group ?? id;
    groups[groupId] ?? (groups[groupId] = []);
    groups[groupId].push(...values);
  }
  return { choices, defaults, groups };
}

const langs = ["ts", "jsdoc"];
const langMap = {
  ts: "typescript",
  jsdoc: "checkjs",
  false: "none"
};
const templateChoices = templates.map((t) => t.name);
const langOption = new Option("--types <lang>", "add type checking").choices(langs);
const templateOption = new Option("--template <type>", "template to scaffold").choices(
  templateChoices
);
const ProjectPathSchema = optional(string());
const OptionsSchema = strictObject({
  types: pipe$1(
    optional(union([picklist(langs), boolean()])),
    transform((lang) => langMap[String(lang)])
  ),
  addOns: boolean(),
  install: boolean(),
  template: optional(picklist(templateChoices))
});
const create = new Command("create").description("scaffolds a new SvelteKit project").argument("[path]", "where the project will be created").addOption(templateOption).addOption(langOption).option("--no-types").option("--no-add-ons", "skips interactive add-on installer").option("--no-install", "skip installing dependencies").configureHelp(helpConfig).action((projectPath, opts) => {
  const cwd = parse(ProjectPathSchema, projectPath);
  const options = parse(OptionsSchema, opts);
  runCommand(async () => {
    const { directory, addOnNextSteps, packageManager } = await createProject(cwd, options);
    const highlight = (str) => pc.bold(pc.cyan(str));
    let i = 1;
    const initialSteps = [];
    const relative = path$2.relative(process$1$1.cwd(), directory);
    const pm = packageManager ?? detectSync({ cwd: directory })?.name ?? getUserAgent() ?? "npm";
    if (relative !== "") {
      const pathHasSpaces = relative.includes(" ");
      initialSteps.push(
        `${i++}: ${highlight(`cd ${pathHasSpaces ? `"${relative}"` : relative}`)}`
      );
    }
    if (!packageManager) {
      initialSteps.push(`${i++}: ${highlight(`${pm} install`)}`);
    }
    const pmRun = pm === "npm" ? "npm run dev --" : `${pm} dev`;
    const steps = [
      ...initialSteps,
      `${i++}: ${highlight('git init && git add -A && git commit -m "Initial commit"')} (optional)`,
      `${i++}: ${highlight(`${pmRun} --open`)}`,
      "",
      `To close the dev server, hit ${highlight("Ctrl-C")}`,
      "",
      `Stuck? Visit us at ${pc.cyan("https://svelte.dev/chat")}`
    ];
    box(steps.join("\n"), "Project next steps");
    if (addOnNextSteps) box(addOnNextSteps, "Add-on next steps");
  });
});
async function createProject(cwd, options) {
  const { directory, template, language } = await group(
    {
      directory: () => {
        if (cwd) {
          return Promise.resolve(path$2.resolve(cwd));
        }
        const defaultPath = "./";
        return text({
          message: "Where would you like your project to be created?",
          placeholder: `  (hit Enter to use '${defaultPath}')`,
          defaultValue: defaultPath
        });
      },
      force: async ({ results: { directory: directory2 } }) => {
        if (fs$3.existsSync(directory2) && fs$3.readdirSync(directory2).filter((x) => !x.startsWith(".git")).length > 0) {
          const force = await confirm({
            message: "Directory not empty. Continue?",
            initialValue: false
          });
          if (isCancel(force) || !force) {
            cancel("Exiting.");
            process$1$1.exit(0);
          }
        }
      },
      template: () => {
        if (options.template) return Promise.resolve(options.template);
        return select({
          message: "Which template would you like?",
          initialValue: "minimal",
          options: templates.map((t) => ({ label: t.title, value: t.name, hint: t.description }))
        });
      },
      language: () => {
        if (options.types) return Promise.resolve(options.types);
        return select({
          message: "Add type checking with Typescript?",
          initialValue: "typescript",
          options: [
            { label: "Yes, using Typescript syntax", value: "typescript" },
            { label: "Yes, using Javascript with JSDoc comments", value: "checkjs" },
            { label: "No", value: "none" }
          ]
        });
      }
    },
    {
      onCancel: () => {
        cancel("Operation cancelled.");
        process$1$1.exit(0);
      }
    }
  );
  const projectPath = path$2.resolve(directory);
  create$1(projectPath, {
    name: path$2.basename(projectPath),
    template,
    types: language
  });
  log$1.success("Project created");
  let packageManager;
  let addOnNextSteps;
  const installDeps = async () => {
    packageManager = await packageManagerPrompt(projectPath);
    if (packageManager) await installDependencies(packageManager, projectPath);
  };
  if (options.addOns) {
    const { nextSteps, packageManager: pm } = await runAddCommand(
      { cwd: projectPath, install: options.install, preconditions: false, community: [] },
      []
    );
    packageManager = pm;
    addOnNextSteps = nextSteps;
  } else if (options.install) {
    await installDeps();
  }
  if (packageManager === null && options.install) {
    await installDeps();
  }
  return { directory: projectPath, addOnNextSteps, packageManager };
}

const migrate = new Command("migrate").description("a CLI for migrating Svelte(Kit) codebases").argument("<migration>", "migration to run").option("-C, --cwd <path>", "path to working directory", process$1$1.cwd()).configureHelp({
  formatHelp() {
    runMigrate(process$1$1.cwd(), ["--help"]);
    return "";
  }
}).action((migration, options) => {
  runMigrate(options.cwd, [migration]);
});
function runMigrate(cwd, args) {
  const pm = getUserAgent() ?? "npm";
  try {
    const cmdArgs = ["svelte-migrate@latest", ...args];
    if (pm === "npm") cmdArgs.unshift("--yes");
    const cmd = resolveCommand(pm, "execute", cmdArgs);
    execSync(`${cmd.command} ${cmd.args.join(" ")}`, { stdio: "inherit", cwd });
  } catch {
  }
}

const check = new Command("check").description("a CLI for checking your Svelte code").allowUnknownOption(true).option("-C, --cwd <path>", "path to working directory", process$1$1.cwd()).configureHelp({
  formatHelp() {
    runCheck(process$1$1.cwd(), ["--help"]);
    return "";
  }
}).action((options, check2) => {
  const cwd = options.cwd;
  const args = check2.args;
  runCheck(cwd, args);
});
function runCheck(cwd, args) {
  const pm = getUserAgent() ?? "npm";
  const resolved = from$1(cwd, "svelte-check");
  if (!resolved) {
    const cmd = resolveCommand(pm, "add", ["-D", "svelte-check"]);
    console.error(
      `'svelte-check' is not installed locally. Install it with: ${pc.bold(`${cmd.command} ${cmd.args.join(" ")}`)}`
    );
    process$1$1.exit(1);
  }
  try {
    const cmd = resolveCommand(pm, "execute-local", ["svelte-check", ...args]);
    execSync(`${cmd.command} ${cmd.args.join(" ")}`, { stdio: "inherit", cwd });
  } catch {
  }
}

program.name(pkg.name).version(pkg.version, "-v, --version").configureHelp(helpConfig);
program.addCommand(create).addCommand(add).addCommand(migrate).addCommand(check);
program.parse();
//# sourceMappingURL=bin.js.map
